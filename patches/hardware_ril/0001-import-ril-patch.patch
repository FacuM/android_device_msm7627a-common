From aec3c3781c7ded2b2d69b3307219555fe0c7e455 Mon Sep 17 00:00:00 2001
From: grace5921 <androidlover5842@gmail.com>
Date: Tue, 13 Dec 2016 16:13:32 +0530
Subject: [PATCH] import ril patch

Change-Id: I094a1219dbb618666b7b07f0518d79bbbb038962
---
 include/telephony/librilutils.h   |   38 -
 include/telephony/record_stream.h |   43 -
 include/telephony/ril.h           |  532 ++++---
 include/telephony/ril_log.h       |   25 +
 include/telephony/ril_msim.h      |   21 +-
 include/telephony/ril_qos.h       |  120 ++
 libril/Android.mk                 |   26 +-
 libril/ril.cpp                    | 1078 +++++++-------
 libril/ril_commands.h             |   42 +-
 libril/ril_event.cpp              |    7 +-
 libril/ril_unsol_commands.h       |   21 +-
 libril/rilj.h                     |   32 +
 librilutils/Android.mk            |   35 -
 librilutils/librilutils.c         |   24 -
 librilutils/record_stream.c       |  186 ---
 reference-ril/Android.mk          |    9 +-
 reference-ril/atchannel.c         |   70 +-
 reference-ril/msimreference-ril.c | 2774 +++++++++++++++++++++++++++++++++++++
 reference-ril/reference-ril.c     |  512 +++++--
 rild/Android.mk                   |    6 -
 rild/rild.c                       |  223 +--
 21 files changed, 4358 insertions(+), 1466 deletions(-)
 delete mode 100644 include/telephony/librilutils.h
 delete mode 100644 include/telephony/record_stream.h
 mode change 100644 => 100755 include/telephony/ril.h
 create mode 100644 include/telephony/ril_log.h
 create mode 100644 include/telephony/ril_qos.h
 mode change 100644 => 100755 libril/ril.cpp
 mode change 100644 => 100755 libril/ril_commands.h
 create mode 100644 libril/rilj.h
 delete mode 100644 librilutils/Android.mk
 delete mode 100644 librilutils/librilutils.c
 delete mode 100644 librilutils/record_stream.c
 create mode 100644 reference-ril/msimreference-ril.c

diff --git a/include/telephony/librilutils.h b/include/telephony/librilutils.h
deleted file mode 100644
index d06b3e9..0000000
--- a/include/telephony/librilutils.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef LIBRILUTILS_H
-#define LIBRILUTILS_H
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * Return system time in nanos.
- *
- * This is a monotonicly increasing clock and
- * return the same value as System.nanoTime in java.
- */
-uint64_t ril_nano_time();
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // LIBRILUTILS_H
diff --git a/include/telephony/record_stream.h b/include/telephony/record_stream.h
deleted file mode 100644
index 7a89ae4..0000000
--- a/include/telephony/record_stream.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * A simple utility for reading fixed records out of a stream fd
- */
-
-#ifndef _LIBRIL_RECORD_STREAM_H
-#define _LIBRIL_RECORD_STREAM_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-typedef struct RecordStream RecordStream;
-
-extern RecordStream *record_stream_new(int fd, size_t maxRecordLen);
-extern void record_stream_free(RecordStream *p_rs);
-
-extern int record_stream_get_next (RecordStream *p_rs, void ** p_outRecord,
-                                    size_t *p_outRecordLen);
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /*_LIBRIL_RECORD_STREAM_H*/
-
diff --git a/include/telephony/ril.h b/include/telephony/ril.h
old mode 100644
new mode 100755
index 47d8794..cb6e8cc
--- a/include/telephony/ril.h
+++ b/include/telephony/ril.h
@@ -1,7 +1,9 @@
 /*
- * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
- * Not a Contribution
  * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,8 +22,8 @@
 #define ANDROID_RIL_H 1
 
 #include <stdlib.h>
-#include <stdint.h>
 #include <telephony/ril_cdma_sms.h>
+#include <telephony/ril_qos.h>
 #include <telephony/ril_msim.h>
 #ifndef FEATURE_UNIT_TEST
 #include <sys/time.h>
@@ -31,23 +33,13 @@
 extern "C" {
 #endif
 
-#define RIL_VERSION 9     /* Current version */
-#ifdef LEGACY_RIL
-#define RIL_VERSION_MIN 2 /* Minimum RIL_VERSION supported */
-#else
+#define RIL_VERSION 7     /* Current version */
 #define RIL_VERSION_MIN 6 /* Minimum RIL_VERSION supported */
-#endif
 #define RIL_QCOM_VERSION 3 /* Qualcomm internal RIL version */
 
 #define CDMA_ALPHA_INFO_BUFFER_LENGTH 64
 #define CDMA_NUMBER_INFO_BUFFER_LENGTH 81
 
-#define MAX_RILDS 3
-#define MAX_SOCKET_NAME_LENGTH 6
-#define MAX_CLIENT_ID_LENGTH 2
-#define MAX_DEBUG_SOCKET_NAME_LENGTH 12
-#define MAX_QEMU_PIPE_NAME_LENGTH  11
-
 typedef void * RIL_Token;
 
 typedef enum {
@@ -83,10 +75,7 @@ typedef enum {
     RIL_E_SS_MODIFIED_TO_DIAL = 23,             /* SS request modified to DIAL */
     RIL_E_SS_MODIFIED_TO_USSD = 24,             /* SS request modified to USSD */
     RIL_E_SS_MODIFIED_TO_SS = 25,               /* SS request modified to different SS request */
-    RIL_E_SUBSCRIPTION_NOT_SUPPORTED = 26,      /* Subscription not supported by RIL */
-    RIL_E_MISSING_RESOURCE = 27,                /* No logical channel available */
-    RIL_E_NO_SUCH_ELEMENT = 28,                 /* Application not found on sim */
-    RIL_E_INVALID_PARAMETER = 29                /* TO DO: add description*/
+    RIL_E_SUBSCRIPTION_NOT_SUPPORTED = 26       /* Subscription not supported by RIL */
 } RIL_Errno;
 
 typedef enum {
@@ -133,9 +122,7 @@ typedef enum {
     RADIO_TECH_LTE = 14,
     RADIO_TECH_HSPAP = 15, // HSPA+
     RADIO_TECH_GSM = 16, // Only supports voice
-    RADIO_TECH_TD_SCDMA = 17,
-    RADIO_TECH_IWLAN = 18,
-    RADIO_TECH_DCHSPAP = 30
+    RADIO_TECH_TD_SCDMA = 17
 } RIL_RadioTechnology;
 
 // Do we want to split Data from Voice and the use
@@ -153,17 +140,7 @@ typedef enum {
     PREF_NET_TYPE_LTE_GSM_WCDMA            = 9, /* LTE, GSM/WCDMA */
     PREF_NET_TYPE_LTE_CMDA_EVDO_GSM_WCDMA  = 10, /* LTE, CDMA, EvDo, GSM/WCDMA */
     PREF_NET_TYPE_LTE_ONLY                 = 11, /* LTE only */
-    PREF_NET_TYPE_LTE_WCDMA                = 12, /* LTE/WCDMA */
-    PREF_NET_TYPE_TD_SCDMA_ONLY            = 13, /* TD-SCDMA only */
-    PREF_NET_TYPE_TD_SCDMA_WCDMA           = 14, /* TD-SCDMA and WCDMA */
-    PREF_NET_TYPE_TD_SCDMA_LTE             = 15, /* TD-SCDMA and LTE */
-    PREF_NET_TYPE_TD_SCDMA_GSM             = 16, /* TD-SCDMA and GSM */
-    PREF_NET_TYPE_TD_SCDMA_GSM_LTE         = 17, /* TD-SCDMA,GSM and LTE */
-    PREF_NET_TYPE_TD_SCDMA_GSM_WCDMA       = 18, /* TD-SCDMA, GSM/WCDMA */
-    PREF_NET_TYPE_TD_SCDMA_WCDMA_LTE       = 19, /* TD-SCDMA, WCDMA and LTE */
-    PREF_NET_TYPE_TD_SCDMA_GSM_WCDMA_LTE   = 20, /* TD-SCDMA, GSM/WCDMA and LTE */
-    PREF_NET_TYPE_TD_SCDMA_GSM_WCDMA_CDMA_EVDO_AUTO  = 21, /* TD-SCDMA, GSM/WCDMA, CDMA and EvDo */
-    PREF_NET_TYPE_TD_SCDMA_LTE_CDMA_EVDO_GSM_WCDMA   = 22  /* TD-SCDMA, LTE, CDMA, EvDo GSM/WCDMA */
+    PREF_NET_TYPE_LTE_WCDMA                = 12  /* LTE/WCDMA */
 } RIL_PreferredNetworkType;
 
 /* Source for cdma subscription */
@@ -246,15 +223,13 @@ typedef struct {
  */
 typedef struct {
     int             status;     /* A RIL_DataCallFailCause, 0 which is PDP_FAIL_NONE if no error */
-#ifndef HCRADIO
     int             suggestedRetryTime; /* If status != 0, this fields indicates the suggested retry
                                            back-off timer value RIL wants to override the one
                                            pre-configured in FW.
                                            The unit is miliseconds.
                                            The value < 0 means no value is suggested.
                                            The value 0 means retry should be done ASAP.
-                                           The value of INT_MAX(0x7fffffff) means no retry. */
-#endif
+                                           The value of MAX_INT(0x7fffffff) means no retry. */
     int             cid;        /* Context ID, uniquely identifies this call */
     int             active;     /* 0=inactive, 1=active/physical link down, 2=active/physical link up */
     char *          type;       /* One of the PDP_type values in TS 27.007 section 10.1.1.
@@ -291,10 +266,10 @@ typedef struct {
                                             */
 
     union {
-        /* Valid field if tech is RADIO_TECH_3GPP2. See RIL_REQUEST_CDMA_SEND_SMS */
+        /* Valid field if format is FORMAT_3GPP2. See RIL_REQUEST_CDMA_SEND_SMS */
         RIL_CDMA_SMS_Message* cdmaMessage;
 
-        /* Valid field if tech is RADIO_TECH_3GPP. See RIL_REQUEST_SEND_SMS */
+        /* Valid field if format is FORMAT_3GPP. See RIL_REQUEST_SEND_SMS */
         char**                gsmMessage;
     } message;
 } RIL_IMS_SMS_Message;
@@ -463,7 +438,6 @@ typedef enum {
     PDP_FAIL_SERVICE_OPTION_NOT_SUBSCRIBED = 0x21, /* no retry */
     PDP_FAIL_SERVICE_OPTION_OUT_OF_ORDER = 0x22,
     PDP_FAIL_NSAPI_IN_USE = 0x23,                  /* no retry */
-    PDP_FAIL_REGULAR_DEACTIVATION = 0x24,          /* restart radio */
     PDP_FAIL_ONLY_IPV4_ALLOWED = 0x32,             /* no retry */
     PDP_FAIL_ONLY_IPV6_ALLOWED = 0x33,             /* no retry */
     PDP_FAIL_ONLY_SINGLE_BEARER_ALLOWED = 0x34,
@@ -474,7 +448,7 @@ typedef enum {
     PDP_FAIL_DATA_REGISTRATION_FAIL = -2,
 
    /* reasons for data call drop - network/modem disconnect */
-    PDP_FAIL_SIGNAL_LOST = -3,
+    PDP_FAIL_SIGNAL_LOST = -3,            /* no retry */
     PDP_FAIL_PREF_RADIO_TECH_CHANGED = -4,/* preferred technology has changed, should retry
                                              with parameters appropriate for new technology */
     PDP_FAIL_RADIO_POWER_OFF = -5,        /* data call was disconnected because radio was resetting,
@@ -546,7 +520,14 @@ typedef enum {
     RIL_PERSOSUBSTATE_RUIM_RUIM_PUK             = 24
 } RIL_PersoSubstate;
 
+typedef struct {
+    RIL_PersoSubstate depersonalizationType;
+    char             *depersonalizationCode;
+} RIL_Depersonalization;
+
+
 typedef enum {
+    RIL_APPSTATE_ILLEGAL               = -1,
     RIL_APPSTATE_UNKNOWN               = 0,
     RIL_APPSTATE_DETECTED              = 1,
     RIL_APPSTATE_PIN                   = 2, /* If PIN1 or UPin is required */
@@ -714,10 +695,6 @@ typedef struct {
     int bitErrorRate;    /* bit error rate (0-7, 99) as defined in TS 27.007 8.5 */
 } RIL_GW_SignalStrength;
 
-typedef struct {
-    int signalStrength;  /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
-    int bitErrorRate;    /* bit error rate (0-7, 99) as defined in TS 27.007 8.5 */
-} RIL_SignalStrengthWcdma;
 
 typedef struct {
     int dbm;  /* Valid values are positive integers.  This value is the actual RSSI value
@@ -764,37 +741,11 @@ typedef struct {
 } RIL_LTE_SignalStrength;
 
 typedef struct {
-    int signalStrength;  /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
-    int rsrp;            /* The current Reference Signal Receive Power in dBm multipled by -1.
-                          * Range: 44 to 140 dBm
-                          * INT_MAX: 0x7FFFFFFF denotes invalid value.
-                          * Reference: 3GPP TS 36.133 9.1.4 */
-    int rsrq;            /* The current Reference Signal Receive Quality in dB multiplied by -1.
-                          * Range: 20 to 3 dB.
-                          * INT_MAX: 0x7FFFFFFF denotes invalid value.
-                          * Reference: 3GPP TS 36.133 9.1.7 */
-    int rssnr;           /* The current reference signal signal-to-noise ratio in 0.1 dB units.
-                          * Range: -200 to +300 (-200 = -20.0 dB, +300 = 30dB).
-                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
-                          * Reference: 3GPP TS 36.101 8.1.1 */
-    int cqi;             /* The current Channel Quality Indicator.
-                          * Range: 0 to 15.
-                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
-                          * Reference: 3GPP TS 36.101 9.2, 9.3, A.4 */
-    int timingAdvance;   /* timing advance in micro seconds for a one way trip from cell to device.
-                          * Approximate distance can be calculated using 300m/us * timingAdvance.
-                          * Range: 0 to 0x7FFFFFFE
-                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
-                          * Reference: 3GPP 36.321 section 6.1.3.5
-                          * also: http://www.cellular-planningoptimization.com/2010/02/timing-advance-with-calculation.html */
-} RIL_LTE_SignalStrength_v8;
-
-typedef struct {
     int rscp;    /* The Received Signal Code Power in dBm multipled by -1.
                   * Range : 25 to 120
                   * INT_MAX: 0x7FFFFFFF denotes invalid value.
                   * Reference: 3GPP TS 25.123, section 9.1.1.1 */
-} RIL_TD_SCDMA_SignalStrength_CAF;
+} RIL_TD_SCDMA_SignalStrength;
 
 /* Deprecated, use RIL_SignalStrength_v6 */
 typedef struct {
@@ -814,113 +765,9 @@ typedef struct {
     RIL_GW_SignalStrength       GW_SignalStrength;
     RIL_CDMA_SignalStrength     CDMA_SignalStrength;
     RIL_EVDO_SignalStrength     EVDO_SignalStrength;
-    RIL_LTE_SignalStrength_v8   LTE_SignalStrength;
-} RIL_SignalStrength_v8;
-
-typedef struct {
-    RIL_GW_SignalStrength           GW_SignalStrength;
-    RIL_CDMA_SignalStrength         CDMA_SignalStrength;
-    RIL_EVDO_SignalStrength         EVDO_SignalStrength;
-    RIL_LTE_SignalStrength_v8       LTE_SignalStrength;
-    RIL_TD_SCDMA_SignalStrength_CAF TD_SCDMA_SignalStrength;
-} RIL_SignalStrength_v9_CAF;
-
-/** RIL_CellIdentityGsm */
-typedef struct {
-    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown */
-    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown */
-    int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
-    int cid;    /* 16-bit GSM Cell Identity described in TS 27.007, 0..65535, INT_MAX if unknown  */
-} RIL_CellIdentityGsm;
-
-/** RIL_CellIdentityWcdma */
-typedef struct {
-    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
-    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
-    int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
-    int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
-    int psc;    /* 9-bit UMTS Primary Scrambling Code described in TS 25.331, 0..511, INT_MAX if unknown */
-} RIL_CellIdentityWcdma;
-
-/** RIL_CellIdentityCdma */
-typedef struct {
-    int networkId;      /* Network Id 0..65535, INT_MAX if unknown */
-    int systemId;       /* CDMA System Id 0..32767, INT_MAX if unknown  */
-    int basestationId;  /* Base Station Id 0..65535, INT_MAX if unknown  */
-    int longitude;      /* Longitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
-                         * It is represented in units of 0.25 seconds and ranges from -2592000
-                         * to 2592000, both values inclusive (corresponding to a range of -180
-                         * to +180 degrees). INT_MAX if unknown */
-
-    int latitude;       /* Latitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
-                         * It is represented in units of 0.25 seconds and ranges from -1296000
-                         * to 1296000, both values inclusive (corresponding to a range of -90
-                         * to +90 degrees). INT_MAX if unknown */
-} RIL_CellIdentityCdma;
-
-/** RIL_CellIdentityLte */
-typedef struct {
-    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
-    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
-    int ci;     /* 28-bit Cell Identity described in TS ???, INT_MAX if unknown */
-    int pci;    /* physical cell id 0..503, INT_MAX if unknown  */
-    int tac;    /* 16-bit tracking area code, INT_MAX if unknown  */
-} RIL_CellIdentityLte;
-
-/** RIL_CellInfoGsm */
-typedef struct {
-  RIL_CellIdentityGsm   cellIdentityGsm;
-  RIL_GW_SignalStrength signalStrengthGsm;
-} RIL_CellInfoGsm;
-
-/** RIL_CellInfoWcdma */
-typedef struct {
-  RIL_CellIdentityWcdma cellIdentityWcdma;
-  RIL_SignalStrengthWcdma signalStrengthWcdma;
-} RIL_CellInfoWcdma;
-
-/** RIL_CellInfoCdma */
-typedef struct {
-  RIL_CellIdentityCdma      cellIdentityCdma;
-  RIL_CDMA_SignalStrength   signalStrengthCdma;
-  RIL_EVDO_SignalStrength   signalStrengthEvdo;
-} RIL_CellInfoCdma;
-
-/** RIL_CellInfoLte */
-typedef struct {
-  RIL_CellIdentityLte        cellIdentityLte;
-  RIL_LTE_SignalStrength_v8  signalStrengthLte;
-} RIL_CellInfoLte;
-
-// Must be the same as CellInfo.TYPE_XXX
-typedef enum {
-  RIL_CELL_INFO_TYPE_GSM    = 1,
-  RIL_CELL_INFO_TYPE_CDMA   = 2,
-  RIL_CELL_INFO_TYPE_LTE    = 3,
-  RIL_CELL_INFO_TYPE_WCDMA  = 4,
-} RIL_CellInfoType;
-
-// Must be the same as CellInfo.TIMESTAMP_TYPE_XXX
-typedef enum {
-    RIL_TIMESTAMP_TYPE_UNKNOWN = 0,
-    RIL_TIMESTAMP_TYPE_ANTENNA = 1,
-    RIL_TIMESTAMP_TYPE_MODEM = 2,
-    RIL_TIMESTAMP_TYPE_OEM_RIL = 3,
-    RIL_TIMESTAMP_TYPE_JAVA_RIL = 4,
-} RIL_TimeStampType;
-
-typedef struct {
-  RIL_CellInfoType  cellInfoType;   /* cell type for selecting from union CellInfo */
-  int               registered;     /* !0 if this cell is registered 0 if not registered */
-  RIL_TimeStampType timeStampType;  /* type of time stamp represented by timeStamp */
-  uint64_t          timeStamp;      /* Time in nanos as returned by ril_nano_time */
-  union {
-    RIL_CellInfoGsm     gsm;
-    RIL_CellInfoCdma    cdma;
-    RIL_CellInfoLte     lte;
-    RIL_CellInfoWcdma   wcdma;
-  } CellInfo;
-} RIL_CellInfo;
+    RIL_LTE_SignalStrength      LTE_SignalStrength;
+    RIL_TD_SCDMA_SignalStrength TD_SCDMA_SignalStrength;
+} RIL_SignalStrength_v7;
 
 /* Names of the CDMA info records (C.S0005 section 3.7.5) */
 typedef enum {
@@ -1277,11 +1124,9 @@ typedef struct {
 /**
  * RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE
  *
- * Requests that personlization be deactivated
+ * Requests that network personlization be deactivated
  *
- * "data" is const char **
- * ((const char **)(data))[0]] is personlization type
- * ((const char **)(data))[1]] is depersonlization code
+ * "data" is const RIL_Depersonalization*
  *
  * "response" is int *
  * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
@@ -3657,54 +3502,6 @@ typedef struct {
 #define RIL_REQUEST_VOICE_RADIO_TECH 108
 
 /**
- * RIL_REQUEST_GET_CELL_INFO_LIST
- *
- * Request all of the current cell information known to the radio. The radio
- * must a list of all current cells, including the neighboring cells. If for a particular
- * cell information isn't known then the appropriate unknown value will be returned.
- * This does not cause or change the rate of RIL_UNSOL_CELL_INFO_LIST.
- *
- * "data" is NULL
- *
- * "response" is an array of  RIL_CellInfo.
- */
-#define RIL_REQUEST_GET_CELL_INFO_LIST 109
-
-/**
- * RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE
- *
- * Sets the minimum time between when RIL_UNSOL_CELL_INFO_LIST should be invoked.
- * A value of 0, means invoke RIL_UNSOL_CELL_INFO_LIST when any of the reported
- * information changes. Setting the value to INT_MAX(0x7fffffff) means never issue
- * a RIL_UNSOL_CELL_INFO_LIST.
- *
- * "data" is int *
- * ((int *)data)[0] is minimum time in milliseconds
- *
- * "response" is NULL
- *
- * Valid errors:
- *  SUCCESS
- *  RADIO_NOT_AVAILABLE
- *  GENERIC_FAILURE
- */
-#define RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE 110
-
-/**
- * RIL_REQUEST_SET_INITIAL_ATTACH_APN
- *
- * Set an apn to initial attach network
- * "response" is NULL
- *
- * Valid errors:
- *  SUCCESS
- *  RADIO_NOT_AVAILABLE (radio resetting)
- *  GENERIC_FAILURE
- *  SUBSCRIPTION_NOT_AVAILABLE
- */
-#define RIL_REQUEST_SET_INITIAL_ATTACH_APN 111
-
-/**
  * RIL_REQUEST_IMS_REGISTRATION_STATE
  *
  * Request current IMS registration state
@@ -3719,14 +3516,14 @@ typedef struct {
  * If ((int*)response)[0] is = 1, then ((int *) response)[1]
  * must follow with IMS SMS format:
  *
- * ((int *) response)[1] is of type RIL_RadioTechnologyFamily
+ * ((int *) response)[1] is of type const RIL_IMS_SMS_Format
  *
  * Valid errors:
  *  SUCCESS
  *  RADIO_NOT_AVAILABLE
  *  GENERIC_FAILURE
  */
-#define RIL_REQUEST_IMS_REGISTRATION_STATE 112
+#define RIL_REQUEST_IMS_REGISTRATION_STATE 109
 
 /**
  * RIL_REQUEST_IMS_SEND_SMS
@@ -3749,7 +3546,7 @@ typedef struct {
  *  GENERIC_FAILURE
  *
  */
-#define RIL_REQUEST_IMS_SEND_SMS 113
+#define RIL_REQUEST_IMS_SEND_SMS 110
 
 /**
  * RIL_REQUEST_GET_DATA_CALL_PROFILE
@@ -3772,14 +3569,147 @@ typedef struct {
  *  RIL_E_DATA_CALL_PROFILE_NOT_AVAILABLE
  *
  */
-#define RIL_REQUEST_GET_DATA_CALL_PROFILE 114
+#define RIL_REQUEST_GET_DATA_CALL_PROFILE 111
+
+/**
+ * RIL_REQUEST_SETUP_QOS
+ *
+ * The QoS Parameters contain the following:
+ * - Call ID
+ * - QoS Specs (There can be multiple QoS Specs with a mimimum of ONE)
+ *
+ * A QoS Spec is a pair of QoS Flow spec and QoS Filter Spec.  QoS Flow/Filter
+ * spec is a comma seperated list of key value pairs of the form 'KEY=VALUE'
+ * where the 'KEY' is from the enum RIL_QosSpecKeys and the 'VALUE' is the
+ * numerical value. Each QoS Spec is identified by a unique index.
+ *
+ *
+ * For example, the following set of strings is one QoS Spec, first string has
+ * Flow/Filter spec for TX and second for RX.
+ *
+ * "RIL_QOS_SPEC_INDEX=0,RIL_QOS_FLOW_DIRECTION=0,\
+ *              RIL_QOS_FLOW_DATA_RATE_MIN=64000,\
+ *              RIL_QOS_FILTER_TCP_SOURCE_PORT=4000"
+ * "RIL_QOS_SPEC_INDEX=0,RIL_QOS_FLOW_DIRECTION=1,\
+ *              RIL_QOS_FLOW_DATA_RATE_MIN=64000,\
+ *              RIL_QOS_FILTER_TCP_SOURCE_PORT=4000"
+ *
+ * A QoS spec must have at least ONE pair of flow/filter spec (either RX or
+ * TX). There can be any combination of (the optional) flow and filter
+ * parameters included in the QoS spec.
+ *
+ *
+ * "data" is the Call ID followed by an array of QoS Specs
+ * ((char **)data)[0] - Call ID
+ * ((char **)data)[1] - Flow/Filter Spec (for TX or RX)
+ * ((char **)data)[2] - Flow/Filter Spec (optional: for the other direction)
+ *
+ * "response" is a char ** representing a return code followed by a QoS ID.
+ *
+ * ((char **)response)[0] - return code. 0 - success, non-0 - failure
+ * ((char **)response)[1] - QoS ID
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SETUP_QOS 112
+
+/**
+ * RIL_REQUEST_RELEASE_QOS
+ *
+ * Request to release the QoS for a particular call
+ * "data" is char **
+ * ((char **)data)[0] is QoS ID
+ *
+ * "response" is char ** representing a return code
+ * ((char **)response)[0] - return code. 0 - success, non-0 - failure
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_RELEASE_QOS 113
+
+/**
+ * RIL_REQUEST_GET_QOS_STATUS
+ *
+ * Request to get the QoS status and its parameters for a given QoS ID
+ *
+ * "data" is char *
+ * ((char *)data) - QoS ID
+ *
+ * "response" is an const char ** representing a return code followed by an
+ * array of Flow/Filter Specs
+ * ((char **)response)[0] - return code. 0 - success, non-0 - failure
+ * ((char **)response)[1] - Value from RIL_QosStatus
+ * ((char **)response)[2] - Flow/Filter Spec   (may be followed by more specs)
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_GET_QOS_STATUS 114
+
+/**
+ * RIL_REQUEST_MODIFY_QOS
+ *
+ * Request to modify QoS for a particular call by specifying the QoS
+ * parameters. The QoS parameters are similar to RIL_REQUEST_SETUP_QOS and
+ * specifies QoS Flow/Filter Spec's with updated values
+ *
+ * "data" is char **
+ * ((char **)data)[0] - QoS ID
+ * ((char **)data)[1] - Modified Flow/Filter Spec   (For TX or RX. Mandatory.)
+ * ((char **)data)[2] - Modified Flow/Filter Spec   (For the other direction. Optional)
+ *
+ * "response" is char ** representing a return code
+ * ((char **)response)[0] - return code. 0 - success, non-0 - failure
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_MODIFY_QOS 115
+
+/**
+ * RIL_REQUEST_SUSPEND_QOS
+ *
+ * Request to suspend the QoS for a particular call. All the traffic will be
+ * sent using the default/best effort QoS link.
+ * "data" is char **
+ * ((char **)data[0] is QoS ID
+ *
+ * "response" is char ** representing a return code
+ * ((char **)response)[0] - return code. 0 - success, non-0 - failure
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SUSPEND_QOS 116
+
+/**
+ * RIL_REQUEST_RESUME_QOS
+ *
+ * Request to resume the QoS for a particular call.
+ * "data" is char **
+ * ((char **)data)[0] is QoS ID
+ *
+ * "response" is char ** representing a return code
+ * ((char **)response)[0] - return code. 0 - success, non-0 - failure
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_RESUME_QOS 117
 
 /**
  * RIL_REQUEST_SET_UICC_SUBSCRIPTION
  *
- * Selection/de-selection of a subscription from a SIM card
+ * Selects/deselects a particular application/subscription to use on a particular SIM card
  * "data" is const  RIL_SelectUiccSub*
-
  *
  * "response" is NULL
  *
@@ -3787,10 +3717,11 @@ typedef struct {
  *  SUCCESS
  *  RADIO_NOT_AVAILABLE (radio resetting)
  *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_AVAILABLE
  *  SUBSCRIPTION_NOT_SUPPORTED
  *
  */
-#define RIL_REQUEST_SET_UICC_SUBSCRIPTION  115
+#define RIL_REQUEST_SET_UICC_SUBSCRIPTION  118
 
 /**
  *  RIL_REQUEST_SET_DATA_SUBSCRIPTION
@@ -3805,10 +3736,70 @@ typedef struct {
  *  SUCCESS
  *  RADIO_NOT_AVAILABLE (radio resetting)
  *  GENERIC_FAILURE
- *  SUBSCRIPTION_NOT_SUPPORTED
+ *  SUBSCRIPTION_NOT_AVAILABLE
+ *
+ */
+#define RIL_REQUEST_SET_DATA_SUBSCRIPTION  119
+
+/**
+ * RIL_REQUEST_GET_UICC_SUBSCRIPTION
+ *
+ * Request to query the UICC subscription info
+ * that is currently set.
+ *
+ * "data" is NULL
+ *
+ * "response" is const RIL_SelectUiccSub *
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_AVAILABLE
  *
  */
-#define RIL_REQUEST_SET_DATA_SUBSCRIPTION  116
+#define RIL_REQUEST_GET_UICC_SUBSCRIPTION 120
+
+/**
+ * RIL_REQUEST_GET_DATA_SUBSCRIPTION
+ *
+ * Request to query the Data subscription info
+ * that is currently set.
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((int *)data)[0] is == 0  Indicates data is active on subscription 0
+ * ((int *)data)[0] is == 1  Indicates data is active on subscription 1
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_AVAILABLE
+ *
+ */
+#define RIL_REQUEST_GET_DATA_SUBSCRIPTION 121
+
+/**
+ *  RIL_REQUEST_SET_SUBSCRIPTION_MODE
+ *
+ *  Sets the SUBSCRIPTION_MODE to DualStandBy/SingleStandBy
+ * "data" is const int *
+ * ((const int *)data) [0]    1 indicates SingleStandBy Mode
+                              2 indicates DualStandBy Mode
+ *
+ * "response" is NULL
+ *
+ *  Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_AVAILABLE
+ *
+ */
+#define RIL_REQUEST_SET_SUBSCRIPTION_MODE 122
 
 /**
  * RIL_REQUEST_SIM_TRANSMIT_BASIC
@@ -3824,7 +3815,7 @@ typedef struct {
  * SUCCESS
  * TO DO: add erros
  */
-#define RIL_REQUEST_SIM_TRANSMIT_BASIC 117
+#define RIL_REQUEST_SIM_TRANSMIT_BASIC 123
 
 /**
  * RIL_REQUEST_SIM_OPEN_CHANNEL
@@ -3840,7 +3831,7 @@ typedef struct {
  * SUCCESS
  * TO DO: add erros
  */
-#define RIL_REQUEST_SIM_OPEN_CHANNEL 118
+#define RIL_REQUEST_SIM_OPEN_CHANNEL 124
 
 /**
  * RIL_REQUEST_SIM_CLOSE_CHANNEL
@@ -3856,7 +3847,7 @@ typedef struct {
  * SUCCESS
  * TO DO: add erros
  */
-#define RIL_REQUEST_SIM_CLOSE_CHANNEL 119
+#define RIL_REQUEST_SIM_CLOSE_CHANNEL 125
 
 /**
  * RIL_REQUEST_SIM_TRANSMIT_CHANNEL
@@ -3872,7 +3863,7 @@ typedef struct {
  * SUCCESS
  * TO DO: add erros
  */
-#define RIL_REQUEST_SIM_TRANSMIT_CHANNEL 120
+#define RIL_REQUEST_SIM_TRANSMIT_CHANNEL 126
 
 /**
  * RIL_REQUEST_SIM_GET_ATR
@@ -3892,12 +3883,12 @@ typedef struct {
  * RADIO_NOT_AVAILABLE (radio resetting)
  * GENERIC_FAILURE
  */
-
-#define RIL_REQUEST_SIM_GET_ATR 121
+#define RIL_REQUEST_SIM_GET_ATR 127
 
 /***********************************************************************/
 
 
+
 #define RIL_UNSOL_RESPONSE_BASE 1000
 
 /**
@@ -4373,31 +4364,40 @@ typedef struct {
 #define RIL_UNSOL_VOICE_RADIO_TECH_CHANGED 1035
 
 /**
- * RIL_UNSOL_CELL_INFO_LIST
+ * RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED
+ *
+ * Called when IMS registration state has changed
  *
- * Same information as returned by RIL_REQUEST_GET_CELL_INFO_LIST, but returned
- * at the rate no greater than specified by RIL_REQUEST_SET_UNSOL_CELL_INFO_RATE.
+ * Callee will invoke the following requests on main thread:
  *
+ * RIL_REQUEST_IMS_REGISTRATION_STATE
+  *
  * "data" is NULL
  *
- * "response" is an array of RIL_CellInfo.
  */
-#define RIL_UNSOL_CELL_INFO_LIST 1036
+#define RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED 1036
 
 /**
- * RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED
+ * RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED
  *
- * Called when IMS registration state has changed
+ * Called when tethered mode is enabled or disabled
  *
- * To get IMS registration state and IMS SMS format, callee needs to invoke the
- * following request on main thread:
  *
- * RIL_REQUEST_IMS_REGISTRATION_STATE
+ * "data" is an int 0 - tethered mode off , 1 - tethered mode on
+ */
+#define RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED 1037
+
+/**
+ * RIL_UNSOL_QOS_STATE_CHANGED_IND
  *
- * "data" is NULL
+ * Indication for any change in the QoS state of a particular QoS flow
+ *
+ * "data" is an char **
+ * ((char **)data)[0] - QoS ID
+ * ((char **)data)[1] - Status from RIL_QosIndStates
  *
  */
-#define RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED 1037
+#define RIL_UNSOL_QOS_STATE_CHANGED_IND 1038
 
 /**
  * RIL_UNSOL_ON_SS
@@ -4408,7 +4408,7 @@ typedef struct {
  * "data" is const RIL_StkCcUnsolSsResponse *
  *
  */
-#define RIL_UNSOL_ON_SS 1038
+#define RIL_UNSOL_ON_SS 1039
 
 
 /**
@@ -4419,27 +4419,25 @@ typedef struct {
  * "data" is const char * containing ALPHA string from UICC in UTF-8 format.
  *
  */
-#define RIL_UNSOL_STK_CC_ALPHA_NOTIFY 1039
+#define RIL_UNSOL_STK_CC_ALPHA_NOTIFY 1040
 
 /**
  * RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED
  *
- * Indicated when there is a change in subscription status.
+ * Called when there is a change in subscription status.
  * This event will be sent in the following scenarios
  *  - subscription readiness at modem, which was selected by telephony layer
  *  - when subscription is deactivated by modem due to UICC card removal
- *  - When network invalidates the subscription i.e. attach reject due to authentication reject
  *
  * "data" is const int *
  * ((const int *)data)[0] == 0 for Subscription Deactivated
  * ((const int *)data)[0] == 1 for Subscription Activated
  *
  */
-#define RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED 1040
+#define RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED 1041
+
 /***********************************************************************/
 
-/* COMPATIBILITY WITH MAINLINE */
-#define RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE
 
 /**
  * RIL_Request Function pointer
@@ -4506,14 +4504,6 @@ typedef struct {
     RIL_GetVersion getVersion;
 } RIL_RadioFunctions;
 
-typedef struct {
-    char *apn;
-    char *protocol;
-    int authtype;
-    char *username;
-    char *password;
-} RIL_InitialAttachApn;
-
 #ifdef RIL_SHLIB
 struct RIL_Env {
     /**
diff --git a/include/telephony/ril_log.h b/include/telephony/ril_log.h
new file mode 100644
index 0000000..01975d8
--- /dev/null
+++ b/include/telephony/ril_log.h
@@ -0,0 +1,25 @@
+
+#ifdef ALOGE
+#undef ALOGE
+#endif
+#define ALOGE RLOGE
+
+#ifdef ALOGW
+#undef ALOGW
+#endif
+#define ALOGW RLOGW
+
+#ifdef ALOGI
+#undef ALOGI
+#endif
+#define ALOGI RLOGI
+
+#ifdef ALOGV
+#undef ALOGV
+#endif
+#define ALOGV RLOGV
+
+#ifdef ALOGD
+#undef ALOGD
+#endif
+#define ALOGD RLOGD
diff --git a/include/telephony/ril_msim.h b/include/telephony/ril_msim.h
index 28c0e77..ba9b6aa 100644
--- a/include/telephony/ril_msim.h
+++ b/include/telephony/ril_msim.h
@@ -1,5 +1,4 @@
-/*
- * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -10,7 +9,7 @@
  *       copyright notice, this list of conditions and the following
  *       disclaimer in the documentation and/or other materials provided
  *       with the distribution.
- *     * Neither the name of The Linux Foundation, Inc. nor the names of its
+ *     * Neither the name of The Linux Foundation nor the names of its
  *       contributors may be used to endorse or promote products derived
  *       from this software without specific prior written permission.
  *
@@ -25,6 +24,7 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
 #ifndef ANDROID_RIL_MSIM_H
@@ -41,18 +41,27 @@ typedef enum {
 
 typedef enum {
   RIL_SUBSCRIPTION_1 = 0,
-  RIL_SUBSCRIPTION_2 = 1,
-  RIL_SUBSCRIPTION_3 = 2
+  RIL_SUBSCRIPTION_2 = 1
 } RIL_SubscriptionType;
 
 typedef struct {
   int   slot;                        /* 0, 1, ... etc. */
   int   app_index;                   /* array subscriptor from applications[RIL_CARD_MAX_APPS] in
                                         RIL_REQUEST_GET_SIM_STATUS */
-  RIL_SubscriptionType  sub_type;    /* Indicates subscription 1 or subscription 2 */
+  RIL_SubscriptionType  sub_type;    /* Indicates subscription 0 or subscription 1 */
   RIL_UiccSubActStatus  act_status;
 } RIL_SelectUiccSub;
 
+/**
+ * @param unsolResponse is one of RIL_UNSOL_RESPONSE_*
+ * @param data is pointer to data defined for that RIL_UNSOL_RESPONSE_*
+ *     "data" is owned by caller, and should not be modified or freed by callee
+ * @param datalen the length of data in byte
+ */
+
+void RIL_onUnsolicitedResponse2(int unsolResponse, const void *data,
+                                size_t datalen);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/telephony/ril_qos.h b/include/telephony/ril_qos.h
new file mode 100644
index 0000000..2415a04
--- /dev/null
+++ b/include/telephony/ril_qos.h
@@ -0,0 +1,120 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef ANDROID_RIL_QOS_H
+#define ANDROID_RIL_QOS_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Defines a set of roles which have a pre determined set of flow and filter
+ * specs
+ *
+ */
+typedef enum {
+    RIL_QOS_CONVERSATIONAL,
+    RIL_QOS_STREAMING,
+    RIL_QOS_INTERACTIVE,
+    RIL_QOS_BACKGROUND
+} RIL_QosClass;
+
+typedef enum {
+    RIL_QOS_TX,
+    RIL_QOS_RX
+} RIL_QosDirection;
+
+/* QoS status */
+typedef enum {
+    RIL_QOS_STATUS_NONE,        /* Qos not active */
+    RIL_QOS_STATUS_ACTIVATED,   /* Qos currently active */
+    RIL_QOS_STATUS_SUSPENDED    /* Qos Suspended */
+} RIL_QosStatus;
+
+/* Enum for status of the QoS flows */
+typedef enum {
+    RIL_QOS_ACTIVATED,           /* QoS activation completed or QoS Resumed) */
+    RIL_QOS_ACTIVATED_NETWORK,   /* QoS activation (from network) complete */
+    RIL_QOS_USER_RELEASE,        /* QoS released by the user */
+    RIL_QOS_NETWORK_RELEASE,     /* QoS released by the network */
+    RIL_QOS_SUSPENDED,           /* QoS was suspended */
+    RIL_QOS_MODIFIED,            /* QoS modified */
+    RIL_QOS_ERROR_UNKNOWN        /* Any other error */
+} RIL_QosIndStates;
+
+/* Keys the QoS spec along with the description of their values.
+ *
+ * Each QoS Spec will begin with a unique SPEC_INDEX. Within each spec there can
+ * be multiple filter sets, each of which will start with a unique FILTER_INDEX
+ */
+typedef enum {
+    RIL_QOS_SPEC_INDEX,                         /* Positive numerical value */
+
+    RIL_QOS_FLOW_DIRECTION,                     /* RIL_QosDirection */
+    RIL_QOS_FLOW_TRAFFIC_CLASS,                 /* RIL_QosClass */
+    RIL_QOS_FLOW_DATA_RATE_MIN,                 /* Positive number in bps */
+    RIL_QOS_FLOW_DATA_RATE_MAX,                 /* Positive number in bps */
+    RIL_QOS_FLOW_LATENCY,                       /* Positive number in milliseconds */
+
+    RIL_QOS_FLOW_3GPP2_PROFILE_ID,              /* Positive numerical value */
+    RIL_QOS_FLOW_3GPP2_PRIORITY,                /* Positive numerical value */
+
+    RIL_QOS_FILTER_INDEX,                       /* Mandatory. Positive numerical value */
+    RIL_QOS_FILTER_IPVERSION,                   /* Mandatory. Values must be "IP" or "IPV6" */
+    RIL_QOS_FILTER_DIRECTION,                   /* RIL_QosDirection */
+    RIL_QOS_FILTER_IPV4_SOURCE_ADDR,            /* Format: xxx.xxx.xxx.xxx/yy */
+    RIL_QOS_FILTER_IPV4_DESTINATION_ADDR,       /* Format: xxx.xxx.xxx.xxx/yy */
+    RIL_QOS_FILTER_IPV4_TOS,                    /* Positive numerical Value (max 6-bit number) */
+    RIL_QOS_FILTER_IPV4_TOS_MASK,               /* Mask for the 6 bit TOS value */
+
+    /**
+     * *PORT_START is the starting port number,
+     * *PORT_RANGE is the number of continuous ports from *PORT_START key
+     */
+    RIL_QOS_FILTER_TCP_SOURCE_PORT_START,
+    RIL_QOS_FILTER_TCP_SOURCE_PORT_RANGE,
+    RIL_QOS_FILTER_TCP_DESTINATION_PORT_START,
+    RIL_QOS_FILTER_TCP_DESTINATION_PORT_RANGE,
+    RIL_QOS_FILTER_UDP_SOURCE_PORT_START,
+    RIL_QOS_FILTER_UDP_SOURCE_PORT_RANGE,
+    RIL_QOS_FILTER_UDP_DESTINATION_PORT_START,
+    RIL_QOS_FILTER_UDP_DESTINATION_PORT_RANGE,
+
+    RIL_QOS_FILTER_IPV6_SOURCE_ADDR,        /* Format: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/yyy */
+    RIL_QOS_FILTER_IPV6_DESTINATION_ADDR,   /* Format: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/yyy */
+    RIL_QOS_FILTER_IPV6_TRAFFIC_CLASS,
+    RIL_QOS_FILTER_IPV6_FLOW_LABEL
+} RIL_QosSpecKeys;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*ANDROID_RIL_QOS_H*/
diff --git a/libril/Android.mk b/libril/Android.mk
index 0e8dfb5..cba6c88 100644
--- a/libril/Android.mk
+++ b/libril/Android.mk
@@ -1,7 +1,5 @@
 # Copyright 2006 The Android Open Source Project
 
-ifneq ($(BOARD_PROVIDES_LIBRIL),true)
-
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
@@ -10,35 +8,17 @@ LOCAL_SRC_FILES:= \
     ril_event.cpp
 
 LOCAL_SHARED_LIBRARIES := \
-    liblog \
     libutils \
     libbinder \
     libcutils \
-    libhardware_legacy \
-    librilutils
+    libhardware_legacy
 
 LOCAL_CFLAGS :=
-ifdef BOARD_USE_NEW_LIBRIL_HTC
-    LOCAL_CFLAGS += -DNEW_LIBRIL_HTC
-endif
-
-ifeq ($(BOARD_RIL_NO_CELLINFOLIST),true)
-LOCAL_CFLAGS += -DRIL_NO_CELL_INFO_LIST
-endif
 
 LOCAL_MODULE:= libril
 
 LOCAL_LDLIBS += -lpthread
 
-#USE HCRADIO
-ifeq ($(BOARD_USES_HC_RADIO),true)
-LOCAL_CFLAGS += -DHCRADIO
-endif
-
-ifeq ($(BOARD_USES_LEGACY_RIL),true)
-LOCAL_CFLAGS += -DLEGACY_RIL
-endif
-
 include $(BUILD_SHARED_LIBRARY)
 
 
@@ -52,8 +32,7 @@ LOCAL_SRC_FILES:= \
 
 LOCAL_STATIC_LIBRARIES := \
     libutils_static \
-    libcutils \
-    librilutils_static
+    libcutils
 
 LOCAL_CFLAGS :=
 
@@ -63,4 +42,3 @@ LOCAL_LDLIBS += -lpthread
 
 include $(BUILD_STATIC_LIBRARY)
 endif # ANDROID_BIONIC_TRANSITION
-endif # BOARD_PROVIDES_LIBRIL
diff --git a/libril/ril.cpp b/libril/ril.cpp
old mode 100644
new mode 100755
index ac38da3..850bb1f
--- a/libril/ril.cpp
+++ b/libril/ril.cpp
@@ -1,8 +1,10 @@
 /* //device/libs/telephony/ril.cpp
 **
-** Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
-** Not a Contribution
 ** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2012, The Linux Foundation. All rights reserved.
+**
+** Not a Contribution, Apache license notifications and license are retained
+** for attribution purposes only.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -25,7 +27,7 @@
 #include <telephony/ril_cdma_sms.h>
 #include <cutils/sockets.h>
 #include <cutils/jstring.h>
-#include <telephony/record_stream.h>
+#include <cutils/record_stream.h>
 #include <utils/Log.h>
 #include <utils/SystemClock.h>
 #include <pthread.h>
@@ -33,7 +35,6 @@
 #include <cutils/jstring.h>
 
 #include <sys/types.h>
-#include <sys/limits.h>
 #include <pwd.h>
 
 #include <stdio.h>
@@ -53,14 +54,16 @@
 #include <cutils/properties.h>
 
 #include <ril_event.h>
+#include <telephony/ril_log.h>
+
+#ifdef RIL_VARIANT_LEGACY
+#include "rilj.h"
+#endif
 
 namespace android {
 
 #define PHONE_PROCESS "radio"
 
-#define SOCKET_NAME_RIL "rild"
-#define SOCKET_NAME_RIL_DEBUG "rild-debug"
-
 #define ANDROID_WAKE_LOCK_NAME "radio-interface"
 
 
@@ -95,11 +98,11 @@ namespace android {
     #define startRequest           sprintf(printBuf, "(")
     #define closeRequest           sprintf(printBuf, "%s)", printBuf)
     #define printRequest(token, req)           \
-            RLOGD("[%04d]> %s %s", token, requestToString(req), printBuf)
+            ALOGD("[%04d]> %s %s", token, requestToString(req), printBuf)
 
     #define startResponse           sprintf(printBuf, "%s {", printBuf)
     #define closeResponse           sprintf(printBuf, "%s}", printBuf)
-    #define printResponse           RLOGD("%s", printBuf)
+    #define printResponse           ALOGD("%s", printBuf)
 
     #define clearPrintBuf           printBuf[0] = 0
     #define removeLastChar          printBuf[strlen(printBuf)-1] = 0
@@ -122,12 +125,18 @@ typedef struct {
     int requestNumber;
     void (*dispatchFunction) (Parcel &p, struct RequestInfo *pRI);
     int(*responseFunction) (Parcel &p, void *response, size_t responselen);
+#ifdef RIL_VARIANT_LEGACY
+    int reqNumRILJ;
+#endif
 } CommandInfo;
 
 typedef struct {
     int requestNumber;
     int (*responseFunction) (Parcel &p, void *response, size_t responselen);
     WakeType wakeType;
+#ifdef RIL_VARIANT_LEGACY
+    int reqNumRILJ;
+#endif
 } UnsolResponseInfo;
 
 typedef struct RequestInfo {
@@ -136,6 +145,9 @@ typedef struct RequestInfo {
     struct RequestInfo *p_next;
     char cancelled;
     char local;         // responses to local commands do not go back to command process
+    int client_id;      // 0 or 1 corresponding to each of RIL.java clients
+                        // client will send the corresponding client id after
+                        // connected to rild socket.
 } RequestInfo;
 
 typedef struct UserCallbackInfo {
@@ -145,11 +157,20 @@ typedef struct UserCallbackInfo {
     struct UserCallbackInfo *p_next;
 } UserCallbackInfo;
 
-extern "C"
-char rild[MAX_SOCKET_NAME_LENGTH] = SOCKET_NAME_RIL;
+typedef struct {
+    int client_id;
+    RecordStream *p_rs;
+}RecordStreamInfo;
+
 /*******************************************************************/
+#define MAX_NUM_CLIENTS 2
+#define MAX_SOCKET_NAME_LENGTH 6
+#define SUB1 "SUB1"
+#define SUB2 "SUB2"
+#define SUB_DATA_LENGTH 4
+
+RIL_RadioFunctions s_callbacks[MAX_NUM_CLIENTS] = {0, NULL, NULL, NULL, NULL, NULL};
 
-RIL_RadioFunctions s_callbacks = {0, NULL, NULL, NULL, NULL, NULL};
 static int s_registerCalled = 0;
 
 static pthread_t s_tid_dispatch;
@@ -157,13 +178,17 @@ static pthread_t s_tid_reader;
 static int s_started = 0;
 
 static int s_fdListen = -1;
-static int s_fdCommand = -1;
+
+static char rild[MAX_SOCKET_NAME_LENGTH] = {0};
+static int s_maxNumClients = MAX_NUM_CLIENTS;
+
+static int s_fdCommand[MAX_NUM_CLIENTS] ={-1,-1};
 static int s_fdDebug = -1;
 
 static int s_fdWakeupRead;
 static int s_fdWakeupWrite;
 
-static struct ril_event s_commands_event;
+static struct ril_event s_commands_event[MAX_NUM_CLIENTS];
 static struct ril_event s_wakeupfd_event;
 static struct ril_event s_listen_event;
 static struct ril_event s_wake_timeout_event;
@@ -207,8 +232,8 @@ static void dispatchRaw(Parcel& p, RequestInfo *pRI);
 static void dispatchSmsWrite (Parcel &p, RequestInfo *pRI);
 static void dispatchDataCall (Parcel& p, RequestInfo *pRI);
 static void dispatchVoiceRadioTech (Parcel& p, RequestInfo *pRI);
-static void dispatchSetInitialAttachApn (Parcel& p, RequestInfo *pRI);
 static void dispatchCdmaSubscriptionSource (Parcel& p, RequestInfo *pRI);
+static void dispatchDepersonalization(Parcel &p, RequestInfo *pRI);
 
 static void dispatchCdmaSms(Parcel &p, RequestInfo *pRI);
 static void dispatchImsSms(Parcel &p, RequestInfo *pRI);
@@ -218,11 +243,11 @@ static void dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI);
 static void dispatchGsmBrSmsCnf(Parcel &p, RequestInfo *pRI);
 static void dispatchCdmaBrSmsCnf(Parcel &p, RequestInfo *pRI);
 static void dispatchRilCdmaSmsWriteArgs(Parcel &p, RequestInfo *pRI);
+
 static void dispatchUiccSubscripton(Parcel &p, RequestInfo *pRI);
+
 static int responseInts(Parcel &p, void *response, size_t responselen);
 static int responseStrings(Parcel &p, void *response, size_t responselen);
-static int responseStringsNetworks(Parcel &p, void *response, size_t responselen);
-static int responseStrings(Parcel &p, void *response, size_t responselen, bool network_search);
 static int responseString(Parcel &p, void *response, size_t responselen);
 static int responseVoid(Parcel &p, void *response, size_t responselen);
 static int responseCallList(Parcel &p, void *response, size_t responselen);
@@ -244,25 +269,30 @@ static int responseCallRing(Parcel &p, void *response, size_t responselen);
 static int responseCdmaSignalInfoRecord(Parcel &p,void *response, size_t responselen);
 static int responseCdmaCallWaiting(Parcel &p,void *response, size_t responselen);
 static int responseSimRefresh(Parcel &p, void *response, size_t responselen);
-static int responseCellInfoList(Parcel &p, void *response, size_t responselen);
 static int responseGetDataCallProfile(Parcel &p, void *response, size_t responselen);
 static int responseSSData(Parcel &p, void *response, size_t responselen);
+static int responseUiccSubscription(Parcel &p, void *response,size_t responselen);
 
 static int decodeVoiceRadioTechnology (RIL_RadioState radioState);
 static int decodeCdmaSubscriptionSource (RIL_RadioState radioState);
 static RIL_RadioState processRadioState(RIL_RadioState newRadioState);
 
-static bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType);
+static bool isServiceTypeCFQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType);
 extern "C" const char * requestToString(int request);
 extern "C" const char * failCauseToString(RIL_Errno);
 extern "C" const char * callStateToString(RIL_CallState);
 extern "C" const char * radioStateToString(RIL_RadioState);
 
+static int sendResponse (Parcel &p, int client_id);
+
 #ifdef RIL_SHLIB
 extern "C" void RIL_onUnsolicitedResponse(int unsolResponse, void *data,
                                 size_t datalen);
 #endif
 
+static void RIL_onUnsolicitedSendResponse(int unsolResponse, void *data,
+                               size_t datalen, int client_id);
+
 static UserCallbackInfo * internalRequestTimedCallback
     (RIL_TimedCallback callback, void *param,
         const struct timeval *relativeTime);
@@ -276,6 +306,24 @@ static UnsolResponseInfo s_unsolResponses[] = {
 #include "ril_unsol_commands.h"
 };
 
+static char * RIL_getRilSocketName() {
+    return rild;
+}
+
+extern "C"
+void RIL_setRilSocketName(char * s) {
+    strncpy(rild, s, MAX_SOCKET_NAME_LENGTH);
+}
+
+int RIL_getMaxNumClients() {
+    return s_maxNumClients;
+}
+
+extern "C"
+void RIL_setMaxNumClients(int num_clients) {
+    s_maxNumClients = num_clients;
+}
+
 /* For older RILs that do not support new commands RIL_REQUEST_VOICE_RADIO_TECH and
    RIL_UNSOL_VOICE_RADIO_TECH_CHANGED messages, decode the voice radio tech from
    radio state message and store it. Every time there is a change in Radio State
@@ -296,15 +344,6 @@ int cdmaSubscriptionSource = -1;
  */
 int simRuimStatus = -1;
 
-static char * RIL_getRilSocketName() {
-    return rild;
-}
-
-extern "C"
-void RIL_setRilSocketName(char * s) {
-    strncpy(rild, s, MAX_SOCKET_NAME_LENGTH);
-}
-
 static char *
 strdupReadString(Parcel &p) {
     size_t stringlen;
@@ -337,13 +376,24 @@ void   nullParcelReleaseFunction (const uint8_t* data, size_t dataSize,
     // do nothing -- the data reference lives longer than the Parcel object
 }
 
+#ifdef RIL_VARIANT_LEGACY
+CommandInfo * getCmdInfoByReqId(int request) {
+    for (int32_t rq = 1; rq < (int32_t)NUM_ELEMS(s_commands); rq++) {
+        if (s_commands[rq].requestNumber == request) {
+            return &(s_commands[rq]);
+        }
+    }
+    return NULL;
+}
+#endif
+
 /**
  * To be called from dispatch thread
  * Issue a single local request, ensuring that the response
  * is not sent back up to the command process
  */
 static void
-issueLocalRequest(int request, void *data, int len) {
+issueLocalRequest(int request, void *data, int len, int client_id) {
     RequestInfo *pRI;
     int ret;
 
@@ -351,7 +401,12 @@ issueLocalRequest(int request, void *data, int len) {
 
     pRI->local = 1;
     pRI->token = 0xffffffff;        // token is not used in this context
+#ifdef RIL_VARIANT_LEGACY
+    pRI->pCI = getCmdInfoByReqId(request);
+#else
     pRI->pCI = &(s_commands[request]);
+#endif
+    pRI->client_id = client_id;
 
     ret = pthread_mutex_lock(&s_pendingRequestsMutex);
     assert (ret == 0);
@@ -362,15 +417,15 @@ issueLocalRequest(int request, void *data, int len) {
     ret = pthread_mutex_unlock(&s_pendingRequestsMutex);
     assert (ret == 0);
 
-    RLOGD("C[locl]> %s", requestToString(request));
+    ALOGD("C[locl]> %s", requestToString(request));
 
-    s_callbacks.onRequest(request, data, len, pRI);
+    s_callbacks[pRI->client_id].onRequest(request, data, len, pRI);
 }
 
 
 
 static int
-processCommandBuffer(void *buffer, size_t buflen) {
+processCommandBuffer(void *buffer, size_t buflen, int client_id) {
     Parcel p;
     status_t status;
     int32_t request;
@@ -385,13 +440,48 @@ processCommandBuffer(void *buffer, size_t buflen) {
     status = p.readInt32 (&token);
 
     if (status != NO_ERROR) {
-        RLOGE("invalid request block");
+        ALOGE("invalid request block");
         return 0;
     }
 
+#ifdef RIL_VARIANT_LEGACY
+    CommandInfo * ci = NULL;
+    if (request > 0) {
+        // Translate RILJ req_id to RILC req_id
+        for (int32_t rq = 1; rq < (int32_t)NUM_ELEMS(s_commands); rq++) {
+            if (s_commands[rq].reqNumRILJ == request) {
+                ci = &(s_commands[rq]);
+                break;
+            }
+        }
+        if (!ci) {
+            ci = getCmdInfoByReqId(request);
+        }
+        if (ci) {
+            if (ci->requestNumber <= 0) {
+                ci = NULL;
+            } else {
+                request = ci->requestNumber;
+            }
+        }
+    }
+
+    if (!ci) {
+#else
     if (request < 1 || request >= (int32_t)NUM_ELEMS(s_commands)) {
-        RLOGE("unsupported request code %d token %d", request, token);
+#endif
+        Parcel pErr;
+        ALOGE("unsupported request code %d token %d", request, token);
         // FIXME this should perhaps return a response
+        pErr.writeInt32 (RESPONSE_SOLICITED);
+        pErr.writeInt32 (token);
+#ifdef RIL_VARIANT_LEGACY
+        pErr.writeInt32 (RIL_E_REQUEST_NOT_SUPPORTED);
+#else
+        pErr.writeInt32 (RIL_E_GENERIC_FAILURE);
+#endif
+
+        sendResponse(pErr, client_id);
         return 0;
     }
 
@@ -399,7 +489,12 @@ processCommandBuffer(void *buffer, size_t buflen) {
     pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));
 
     pRI->token = token;
+#ifdef RIL_VARIANT_LEGACY
+    pRI->pCI = ci;
+#else
     pRI->pCI = &(s_commands[request]);
+#endif
+    pRI->client_id = client_id;
 
     ret = pthread_mutex_lock(&s_pendingRequestsMutex);
     assert (ret == 0);
@@ -419,8 +514,8 @@ processCommandBuffer(void *buffer, size_t buflen) {
 
 static void
 invalidCommandBlock (RequestInfo *pRI) {
-    RLOGE("invalid command block for token %d request %s",
-                pRI->token, requestToString(pRI->pCI->requestNumber));
+    ALOGE("invalid command block for token %d request %s and client_id %d ",
+                pRI->token, requestToString(pRI->pCI->requestNumber), pRI->client_id);
 }
 
 /** Callee expects NULL */
@@ -428,7 +523,7 @@ static void
 dispatchVoid (Parcel& p, RequestInfo *pRI) {
     clearPrintBuf;
     printRequest(pRI->token, pRI->pCI->requestNumber);
-    s_callbacks.onRequest(pRI->pCI->requestNumber, NULL, 0, pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, NULL, 0, pRI);
 }
 
 /** Callee expects const char * */
@@ -446,7 +541,7 @@ dispatchString (Parcel& p, RequestInfo *pRI) {
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, string8,
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, string8,
                        sizeof(char *), pRI);
 
 #ifdef MEMSET_FREED
@@ -496,7 +591,7 @@ dispatchStrings (Parcel &p, RequestInfo *pRI) {
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, pStrings, datalen, pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, pStrings, datalen, pRI);
 
     if (pStrings != NULL) {
         for (int i = 0 ; i < countStrings ; i++) {
@@ -550,7 +645,7 @@ dispatchInts (Parcel &p, RequestInfo *pRI) {
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
 
-   s_callbacks.onRequest(pRI->pCI->requestNumber, const_cast<int *>(pInts),
+   s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, const_cast<int *>(pInts),
                        datalen, pRI);
 
 #ifdef MEMSET_FREED
@@ -595,7 +690,7 @@ dispatchSmsWrite (Parcel &p, RequestInfo *pRI) {
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &args, sizeof(args), pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &args, sizeof(args), pRI);
 
 #ifdef MEMSET_FREED
     memsetString (args.pdu);
@@ -639,7 +734,7 @@ dispatchDial (Parcel &p, RequestInfo *pRI) {
         goto invalid;
     }
 
-    if (s_callbacks.version < 3) { // Remove when partners upgrade to version 3
+    if (s_callbacks[pRI->client_id].version < 3) { // Remove when partners upgrade to version 3
         uusPresent = 0;
         sizeOfDial = sizeof(dial) - sizeof(RIL_UUS_Info *);
     } else {
@@ -691,7 +786,7 @@ dispatchDial (Parcel &p, RequestInfo *pRI) {
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &dial, sizeOfDial, pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &dial, sizeOfDial, pRI);
 
 #ifdef MEMSET_FREED
     memsetString (dial.address);
@@ -713,7 +808,6 @@ invalid:
 /**
  * Callee expects const RIL_SIM_IO *
  * Payload is:
- *   int32_t cla
  *   int32_t command
  *   int32_t fileid
  *   String path
@@ -772,7 +866,6 @@ dispatchSIM_IO (Parcel &p, RequestInfo *pRI) {
         simIO.v6.command, simIO.v6.fileid, (char*)simIO.v6.path,
         simIO.v6.p1, simIO.v6.p2, simIO.v6.p3,
         (char*)simIO.v6.data,  (char*)simIO.v6.pin2, simIO.v6.aidPtr);
-
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
@@ -780,8 +873,8 @@ dispatchSIM_IO (Parcel &p, RequestInfo *pRI) {
         goto invalid;
     }
 
-    size = (s_callbacks.version < 6) ? sizeof(simIO.v5) : sizeof(simIO.v6);
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &simIO, size, pRI);
+    size = (s_callbacks[pRI->client_id].version < 6) ? sizeof(simIO.v5) : sizeof(simIO.v6);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &simIO, size, pRI);
 
 #ifdef MEMSET_FREED
     memsetString (simIO.v6.path);
@@ -859,7 +952,7 @@ dispatchCallForward(Parcel &p, RequestInfo *pRI) {
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &cff, sizeof(cff), pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &cff, sizeof(cff), pRI);
 
 #ifdef MEMSET_FREED
     memsetString(cff.number);
@@ -903,7 +996,8 @@ dispatchRaw(Parcel &p, RequestInfo *pRI) {
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, const_cast<void *>(data), len, pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber,
+            const_cast<void *>(data), len, pRI);
 
     return;
 invalid:
@@ -1000,7 +1094,7 @@ dispatchCdmaSms(Parcel &p, RequestInfo *pRI) {
         goto invalid;
     }
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm),pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm),pRI);
 
 #ifdef MEMSET_FREED
     memset(&rcsm, 0, sizeof(rcsm));
@@ -1029,7 +1123,7 @@ dispatchImsCdmaSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRe
     rism.messageRef = messageRef;
     rism.message.cdmaMessage = &rcsm;
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &rism,
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &rism,
             sizeof(RIL_RadioTechnologyFamily)+sizeof(uint8_t)+sizeof(int32_t)
             +sizeof(rcsm),pRI);
 
@@ -1066,7 +1160,8 @@ dispatchImsGsmSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef
     rism.messageRef = messageRef;
 
     startRequest;
-    appendPrintBuf("%sformat=%d,", printBuf, rism.format);
+    appendPrintBuf("%sformat=%d,", printBuf, rism.tech);
+
     if (countStrings == 0) {
         // just some non-null pointer
         pStrings = (char **)alloca(sizeof(char *));
@@ -1089,7 +1184,7 @@ dispatchImsGsmSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
     rism.message.gsmMessage = pStrings;
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &rism,
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &rism,
             sizeof(RIL_RadioTechnologyFamily)+sizeof(uint8_t)+sizeof(int32_t)
             +datalen, pRI);
 
@@ -1182,7 +1277,7 @@ dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
 
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI);
 
 #ifdef MEMSET_FREED
     memset(&rcsa, 0, sizeof(rcsa));
@@ -1241,7 +1336,7 @@ dispatchGsmBrSmsCnf(Parcel &p, RequestInfo *pRI) {
             goto invalid;
         }
 
-        s_callbacks.onRequest(pRI->pCI->requestNumber,
+        s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber,
                               gsmBciPtrs,
                               num * sizeof(RIL_GSM_BroadcastSmsConfigInfo *),
                               pRI);
@@ -1297,7 +1392,7 @@ dispatchCdmaBrSmsCnf(Parcel &p, RequestInfo *pRI) {
             goto invalid;
         }
 
-        s_callbacks.onRequest(pRI->pCI->requestNumber,
+        s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber,
                               cdmaBciPtrs,
                               num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo *),
                               pRI);
@@ -1396,7 +1491,7 @@ static void dispatchRilCdmaSmsWriteArgs(Parcel &p, RequestInfo *pRI) {
 
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &rcsw, sizeof(rcsw),pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &rcsw, sizeof(rcsw),pRI);
 
 #ifdef MEMSET_FREED
     memset(&rcsw, 0, sizeof(rcsw));
@@ -1423,7 +1518,7 @@ static void dispatchDataCall(Parcel& p, RequestInfo *pRI) {
     int pos = p.dataPosition();
 
     int numParams = p.readInt32();
-    if (s_callbacks.version < 4 && numParams > numParamsRilV3) {
+    if (s_callbacks[pRI->client_id].version < 4 && numParams > numParamsRilV3) {
       Parcel p2;
       p2.appendFrom(&p, 0, pos);
       p2.writeInt32(numParamsRilV3);
@@ -1442,7 +1537,7 @@ static void dispatchDataCall(Parcel& p, RequestInfo *pRI) {
 // When all RILs handle this request, this function can be removed and
 // the request can be sent directly to the RIL using dispatchVoid.
 static void dispatchVoiceRadioTech(Parcel& p, RequestInfo *pRI) {
-    RIL_RadioState state = s_callbacks.onStateRequest();
+    RIL_RadioState state = s_callbacks[pRI->client_id].onStateRequest();
 
     if ((RADIO_STATE_UNAVAILABLE == state) || (RADIO_STATE_OFF == state)) {
         RIL_onRequestComplete(pRI, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
@@ -1469,7 +1564,7 @@ static void dispatchVoiceRadioTech(Parcel& p, RequestInfo *pRI) {
 // When all RILs handle this request, this function can be removed and
 // the request can be sent directly to the RIL using dispatchVoid.
 static void dispatchCdmaSubscriptionSource(Parcel& p, RequestInfo *pRI) {
-    RIL_RadioState state = s_callbacks.onStateRequest();
+    RIL_RadioState state = s_callbacks[pRI->client_id].onStateRequest();
 
     if ((RADIO_STATE_UNAVAILABLE == state) || (RADIO_STATE_OFF == state)) {
         RIL_onRequestComplete(pRI, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
@@ -1492,52 +1587,52 @@ static void dispatchCdmaSubscriptionSource(Parcel& p, RequestInfo *pRI) {
         RIL_onRequestComplete(pRI, RIL_E_SUCCESS, &cdmaSubscriptionSource, sizeof(int));
 }
 
-static void dispatchSetInitialAttachApn(Parcel &p, RequestInfo *pRI)
-{
-    RIL_InitialAttachApn pf;
-    int32_t  t;
+/**
+* Callee expects const RIL_Depersonalization *
+* Payload is:
+*   int32_t type
+*   String pin
+*/
+static void
+dispatchDepersonalization(Parcel &p, RequestInfo *pRI) {
+    RIL_Depersonalization d;
+    int32_t t;
     status_t status;
 
-    memset(&pf, 0, sizeof(pf));
+    memset (&d, 0, sizeof(d));
 
-    pf.apn = strdupReadString(p);
-    pf.protocol = strdupReadString(p);
+    // note we only check status at the end
 
     status = p.readInt32(&t);
-    pf.authtype = (int) t;
+    d.depersonalizationType = (RIL_PersoSubstate)t;
 
-    pf.username = strdupReadString(p);
-    pf.password = strdupReadString(p);
+    d.depersonalizationCode = strdupReadString(p);
 
     startRequest;
-    appendPrintBuf("%sapn=%s, protocol=%s, auth_type=%d, username=%s, password=%s",
-            printBuf, pf.apn, pf.protocol, pf.auth_type, pf.username, pf.password);
+    appendPrintBuf("%stype=%d,pin=****",
+        printBuf, d.depersonalizationType);
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
     if (status != NO_ERROR) {
         goto invalid;
     }
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI);
+
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &d, sizeof(d), pRI);
 
 #ifdef MEMSET_FREED
-    memsetString(pf.apn);
-    memsetString(pf.protocol);
-    memsetString(pf.username);
-    memsetString(pf.password);
+    memsetString(d.depersonalizationCode);
 #endif
 
-    free(pf.apn);
-    free(pf.protocol);
-    free(pf.username);
-    free(pf.password);
+    free(d.depersonalizationCode);
 
 #ifdef MEMSET_FREED
-    memset(&pf, 0, sizeof(pf));
+    memset(&d, 0, sizeof(d));
 #endif
 
     return;
 invalid:
+    free(d.depersonalizationCode);
     invalidCommandBlock(pRI);
     return;
 }
@@ -1571,16 +1666,17 @@ static void dispatchUiccSubscripton(Parcel &p, RequestInfo *pRI) {
         goto invalid;
     }
     uicc_sub.act_status = (RIL_UiccSubActStatus) t;
-
     startRequest;
+
     appendPrintBuf("slot=%d, app_index=%d, act_status = %d", uicc_sub.slot, uicc_sub.app_index,
             uicc_sub.act_status);
-    RLOGD("dispatchUiccSubscription, slot=%d, app_index=%d, act_status = %d", uicc_sub.slot,
+    ALOGD("dispatchUiccSubscription, slot=%d, app_index=%d, act_status = %d", uicc_sub.slot,
             uicc_sub.app_index, uicc_sub.act_status);
     closeRequest;
     printRequest(pRI->token, pRI->pCI->requestNumber);
 
-    s_callbacks.onRequest(pRI->pCI->requestNumber, &uicc_sub, sizeof(uicc_sub), pRI);
+    s_callbacks[pRI->client_id].onRequest(pRI->pCI->requestNumber, &uicc_sub,
+            sizeof(uicc_sub), pRI);
 
 #ifdef MEMSET_FREED
     memset(&uicc_sub, 0, sizeof(uicc_sub));
@@ -1609,7 +1705,7 @@ blockingWrite(int fd, const void *buffer, size_t len) {
         if (written >= 0) {
             writeOffset += written;
         } else {   // written < 0
-            RLOGE ("RIL Response: unexpected error on write errno:%d", errno);
+            ALOGE ("RIL Response: unexpected error on write errno:%d", errno);
             close(fd);
             return -1;
         }
@@ -1619,17 +1715,17 @@ blockingWrite(int fd, const void *buffer, size_t len) {
 }
 
 static int
-sendResponseRaw (const void *data, size_t dataSize) {
-    int fd = s_fdCommand;
+sendResponseRaw (const void *data, size_t dataSize, int client_id) {
+    int fd = s_fdCommand[client_id]; //fd is chosen from global s_fdCommand vaiable
     int ret;
     uint32_t header;
 
-    if (s_fdCommand < 0) {
+    if (s_fdCommand[client_id] < 0) {
         return -1;
     }
 
     if (dataSize > MAX_COMMAND_BYTES) {
-        RLOGE("RIL: packet larger than %u (%u)",
+        ALOGE("RIL: packet larger than %u (%u)",
                 MAX_COMMAND_BYTES, (unsigned int )dataSize);
 
         return -1;
@@ -1659,9 +1755,9 @@ sendResponseRaw (const void *data, size_t dataSize) {
 }
 
 static int
-sendResponse (Parcel &p) {
+sendResponse (Parcel &p, int client_id) {
     printResponse;
-    return sendResponseRaw(p.data(), p.dataSize());
+    return sendResponseRaw(p.data(), p.dataSize(), client_id);
 }
 
 /** response is an int* pointing to an array of ints*/
@@ -1671,11 +1767,11 @@ responseInts(Parcel &p, void *response, size_t responselen) {
     int numInts;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
     if (responselen % sizeof(int) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d\n",
+        ALOGE("invalid response length %d expected multiple of %d\n",
             (int)responselen, (int)sizeof(int));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -1697,7 +1793,6 @@ responseInts(Parcel &p, void *response, size_t responselen) {
     return 0;
 }
 
-
 /** response is a char **, pointing to an array of char *'s
     The parcel will begin with the version */
 static int responseStringsWithVersion(int version, Parcel &p, void *response, size_t responselen) {
@@ -1707,23 +1802,14 @@ static int responseStringsWithVersion(int version, Parcel &p, void *response, si
 
 /** response is a char **, pointing to an array of char *'s */
 static int responseStrings(Parcel &p, void *response, size_t responselen) {
-    return responseStrings(p, response, responselen, false);
-}
-
-static int responseStringsNetworks(Parcel &p, void *response, size_t responselen) {
-    return responseStrings(p, response, responselen, true);
-}
-
-/** response is a char **, pointing to an array of char *'s */
-static int responseStrings(Parcel &p, void *response, size_t responselen, bool network_search) {
     int numStrings;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
     if (responselen % sizeof(char *) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d\n",
+        ALOGE("invalid response length %d expected multiple of %d\n",
             (int)responselen, (int)sizeof(char *));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -1734,29 +1820,11 @@ static int responseStrings(Parcel &p, void *response, size_t responselen, bool n
         char **p_cur = (char **) response;
 
         numStrings = responselen / sizeof(char *);
-#ifdef NEW_LIBRIL_HTC
-        if (network_search == true) {
-            // we only want four entries for each network
-            p.writeInt32 (numStrings - (numStrings / 5));
-        } else {
-            p.writeInt32 (numStrings);
-        }
-        int sCount = 0;
-#else
         p.writeInt32 (numStrings);
-#endif
 
         /* each string*/
         startResponse;
         for (int i = 0 ; i < numStrings ; i++) {
-#ifdef NEW_LIBRIL_HTC
-            sCount++;
-            // ignore the fifth string that is returned by newer HTC libhtc_ril.so.
-            if (network_search == true && sCount % 5 == 0) {
-                sCount = 0;
-                continue;
-            }
-#endif
             appendPrintBuf("%s%s,", printBuf, (char*)p_cur[i]);
             writeStringToParcel (p, p_cur[i]);
         }
@@ -1792,12 +1860,12 @@ static int responseCallList(Parcel &p, void *response, size_t responselen) {
     int num;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen % sizeof (RIL_Call *) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d\n",
+        ALOGE("invalid response length %d expected multiple of %d\n",
             (int)responselen, (int)sizeof (RIL_Call *));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -1823,7 +1891,10 @@ static int responseCallList(Parcel &p, void *response, size_t responselen) {
         writeStringToParcel(p, p_cur->name);
         p.writeInt32(p_cur->namePresentation);
         // Remove when partners upgrade to version 3
-        if ((s_callbacks.version < 3) || (p_cur->uusInfo == NULL || p_cur->uusInfo->uusData == NULL)) {
+        // We assume both RIL instances to comply with same RIL version.
+        // Hence checking just for s_callbacks[0].version
+        if ((s_callbacks[0].version < 3) || (p_cur->uusInfo == NULL ||
+                p_cur->uusInfo->uusData == NULL)) {
             p.writeInt32(0); /* UUS Information is absent */
         } else {
             RIL_UUS_Info *uusInfo = p_cur->uusInfo;
@@ -1860,12 +1931,12 @@ static int responseCallList(Parcel &p, void *response, size_t responselen) {
 
 static int responseSMS(Parcel &p, void *response, size_t responselen) {
     if (response == NULL) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen != sizeof (RIL_SMS_Response) ) {
-        RLOGE("invalid response length %d expected %d",
+        ALOGE("invalid response length %d expected %d",
                 (int)responselen, (int)sizeof (RIL_SMS_Response));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -1887,12 +1958,12 @@ static int responseSMS(Parcel &p, void *response, size_t responselen) {
 static int responseDataCallListV4(Parcel &p, void *response, size_t responselen)
 {
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen % sizeof(RIL_Data_Call_Response_v4) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d",
+        ALOGE("invalid response length %d expected multiple of %d",
                 (int)responselen, (int)sizeof(RIL_Data_Call_Response_v4));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -1924,18 +1995,18 @@ static int responseDataCallListV4(Parcel &p, void *response, size_t responselen)
 static int responseDataCallList(Parcel &p, void *response, size_t responselen)
 {
     // Write version
-    p.writeInt32(s_callbacks.version);
+    p.writeInt32(s_callbacks[0].version);
 
-    if (s_callbacks.version < 5) {
+    if (s_callbacks[0].version < 5) {
         return responseDataCallListV4(p, response, responselen);
     } else {
         if (response == NULL && responselen != 0) {
-            RLOGE("invalid response: NULL");
+            ALOGE("invalid response: NULL");
             return RIL_ERRNO_INVALID_RESPONSE;
         }
 
         if (responselen % sizeof(RIL_Data_Call_Response_v6) != 0) {
-            RLOGE("invalid response length %d expected multiple of %d",
+            ALOGE("invalid response length %d expected multiple of %d",
                     (int)responselen, (int)sizeof(RIL_Data_Call_Response_v6));
             return RIL_ERRNO_INVALID_RESPONSE;
         }
@@ -1948,9 +2019,7 @@ static int responseDataCallList(Parcel &p, void *response, size_t responselen)
         int i;
         for (i = 0; i < num; i++) {
             p.writeInt32((int)p_cur[i].status);
-#ifndef HCRADIO
             p.writeInt32(p_cur[i].suggestedRetryTime);
-#endif
             p.writeInt32(p_cur[i].cid);
             p.writeInt32(p_cur[i].active);
             writeStringToParcel(p, p_cur[i].type);
@@ -1978,8 +2047,8 @@ static int responseDataCallList(Parcel &p, void *response, size_t responselen)
 
 static int responseSetupDataCall(Parcel &p, void *response, size_t responselen)
 {
-    if (s_callbacks.version < 5) {
-        return responseStringsWithVersion(s_callbacks.version, p, response, responselen);
+    if (s_callbacks[0].version < 5) {
+        return responseStringsWithVersion(s_callbacks[0].version, p, response, responselen);
     } else {
         return responseDataCallList(p, response, responselen);
     }
@@ -1987,7 +2056,7 @@ static int responseSetupDataCall(Parcel &p, void *response, size_t responselen)
 
 static int responseRaw(Parcel &p, void *response, size_t responselen) {
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL with responselen != 0");
+        ALOGE("invalid response: NULL with responselen != 0");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
@@ -2005,12 +2074,12 @@ static int responseRaw(Parcel &p, void *response, size_t responselen) {
 
 static int responseSIM_IO(Parcel &p, void *response, size_t responselen) {
     if (response == NULL) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen != sizeof (RIL_SIM_IO_Response) ) {
-        RLOGE("invalid response length was %d expected %d",
+        ALOGE("invalid response length was %d expected %d",
                 (int)responselen, (int)sizeof (RIL_SIM_IO_Response));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2033,12 +2102,12 @@ static int responseCallForwards(Parcel &p, void *response, size_t responselen) {
     int num;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen % sizeof(RIL_CallForwardInfo *) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d",
+        ALOGE("invalid response length %d expected multiple of %d",
                 (int)responselen, (int)sizeof(RIL_CallForwardInfo *));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2071,12 +2140,12 @@ static int responseCallForwards(Parcel &p, void *response, size_t responselen) {
 
 static int responseSsn(Parcel &p, void *response, size_t responselen) {
     if (response == NULL) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen != sizeof(RIL_SuppSvcNotification)) {
-        RLOGE("invalid response length was %d expected %d",
+        ALOGE("invalid response length was %d expected %d",
                 (int)responselen, (int)sizeof (RIL_SuppSvcNotification));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2102,12 +2171,12 @@ static int responseCellList(Parcel &p, void *response, size_t responselen) {
     int num;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen % sizeof (RIL_NeighboringCell *) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d\n",
+        ALOGE("invalid response length %d expected multiple of %d\n",
             (int)responselen, (int)sizeof (RIL_NeighboringCell *));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2151,12 +2220,12 @@ static int responseCdmaInformationRecords(Parcel &p,
     RIL_CDMA_InformationRecord *infoRec;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen != sizeof (RIL_CDMA_InformationRecords)) {
-        RLOGE("invalid response length %d expected multiple of %d\n",
+        ALOGE("invalid response length %d expected multiple of %d\n",
             (int)responselen, (int)sizeof (RIL_CDMA_InformationRecords *));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2175,7 +2244,7 @@ static int responseCdmaInformationRecords(Parcel &p,
             case RIL_CDMA_EXTENDED_DISPLAY_INFO_REC:
                 if (infoRec->rec.display.alpha_len >
                                          CDMA_ALPHA_INFO_BUFFER_LENGTH) {
-                    RLOGE("invalid display info response length %d \
+                    ALOGE("invalid display info response length %d \
                           expected not more than %d\n",
                          (int)infoRec->rec.display.alpha_len,
                          CDMA_ALPHA_INFO_BUFFER_LENGTH);
@@ -2189,7 +2258,7 @@ static int responseCdmaInformationRecords(Parcel &p,
             case RIL_CDMA_DISPLAY_INFO_REC:
                 if (infoRec->rec.display.alpha_len >
                                          CDMA_ALPHA_INFO_BUFFER_LENGTH) {
-                    RLOGE("invalid display info response length %d \
+                    ALOGE("invalid display info response length %d \
                           expected not more than %d\n",
                          (int)infoRec->rec.display.alpha_len,
                          CDMA_ALPHA_INFO_BUFFER_LENGTH);
@@ -2209,7 +2278,7 @@ static int responseCdmaInformationRecords(Parcel &p,
             case RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC:
             case RIL_CDMA_CONNECTED_NUMBER_INFO_REC:
                 if (infoRec->rec.number.len > CDMA_NUMBER_INFO_BUFFER_LENGTH) {
-                    RLOGE("invalid display info response length %d \
+                    ALOGE("invalid display info response length %d \
                           expected not more than %d\n",
                          (int)infoRec->rec.number.len,
                          CDMA_NUMBER_INFO_BUFFER_LENGTH);
@@ -2246,7 +2315,7 @@ static int responseCdmaInformationRecords(Parcel &p,
             case RIL_CDMA_REDIRECTING_NUMBER_INFO_REC:
                 if (infoRec->rec.redir.redirectingNumber.len >
                                               CDMA_NUMBER_INFO_BUFFER_LENGTH) {
-                    RLOGE("invalid display info response length %d \
+                    ALOGE("invalid display info response length %d \
                           expected not more than %d\n",
                          (int)infoRec->rec.redir.redirectingNumber.len,
                          CDMA_NUMBER_INFO_BUFFER_LENGTH);
@@ -2301,10 +2370,10 @@ static int responseCdmaInformationRecords(Parcel &p,
                 break;
             case RIL_CDMA_T53_RELEASE_INFO_REC:
                 // TODO(Moto): See David Krause, he has the answer:)
-                RLOGE("RIL_CDMA_T53_RELEASE_INFO_REC: return INVALID_RESPONSE");
+                ALOGE("RIL_CDMA_T53_RELEASE_INFO_REC: return INVALID_RESPONSE");
                 return RIL_ERRNO_INVALID_RESPONSE;
             default:
-                RLOGE("Incorrect name value");
+                ALOGE("Incorrect name value");
                 return RIL_ERRNO_INVALID_RESPONSE;
         }
     }
@@ -2316,12 +2385,12 @@ static int responseCdmaInformationRecords(Parcel &p,
 static int responseRilSignalStrength(Parcel &p,
                     void *response, size_t responselen) {
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen >= sizeof (RIL_SignalStrength_v5)) {
-        RIL_SignalStrength_v9_CAF *p_cur = ((RIL_SignalStrength_v9_CAF *) response);
+        RIL_SignalStrength_v7 *p_cur = ((RIL_SignalStrength_v7 *) response);
 
         p.writeInt32(p_cur->GW_SignalStrength.signalStrength);
         p.writeInt32(p_cur->GW_SignalStrength.bitErrorRate);
@@ -2331,57 +2400,28 @@ static int responseRilSignalStrength(Parcel &p,
         p.writeInt32(p_cur->EVDO_SignalStrength.ecio);
         p.writeInt32(p_cur->EVDO_SignalStrength.signalNoiseRatio);
         if (responselen >= sizeof (RIL_SignalStrength_v6)) {
+            p.writeInt32(p_cur->LTE_SignalStrength.signalStrength);
+
             /*
-             * Fixup LTE for backwards compatibility
+             * ril version <=6 receives negative values for rsrp
+             * workaround for backward compatibility
              */
-            if (s_callbacks.version <= 6) {
-                // signalStrength: -1 -> 99
-                if (p_cur->LTE_SignalStrength.signalStrength == -1) {
-                    p_cur->LTE_SignalStrength.signalStrength = 99;
-                }
-                // rsrp: -1 -> INT_MAX all other negative value to positive.
-                // So remap here
-                if (p_cur->LTE_SignalStrength.rsrp == -1) {
-                    p_cur->LTE_SignalStrength.rsrp = INT_MAX;
-                } else if (p_cur->LTE_SignalStrength.rsrp < -1) {
-                    p_cur->LTE_SignalStrength.rsrp = -p_cur->LTE_SignalStrength.rsrp;
-                }
-                // rsrq: -1 -> INT_MAX
-                if (p_cur->LTE_SignalStrength.rsrq == -1) {
-                    p_cur->LTE_SignalStrength.rsrq = INT_MAX;
-                }
-                // Not remapping rssnr is already using INT_MAX
+            p_cur->LTE_SignalStrength.rsrp =
+                    ((s_callbacks[0].version <= 6) && (p_cur->LTE_SignalStrength.rsrp < 0 )) ?
+                        -(p_cur->LTE_SignalStrength.rsrp) : p_cur->LTE_SignalStrength.rsrp;
 
-                // cqi: -1 -> INT_MAX
-                if (p_cur->LTE_SignalStrength.cqi == -1) {
-                    p_cur->LTE_SignalStrength.cqi = INT_MAX;
-                }
-            }
-            p.writeInt32(p_cur->LTE_SignalStrength.signalStrength);
             p.writeInt32(p_cur->LTE_SignalStrength.rsrp);
             p.writeInt32(p_cur->LTE_SignalStrength.rsrq);
             p.writeInt32(p_cur->LTE_SignalStrength.rssnr);
             p.writeInt32(p_cur->LTE_SignalStrength.cqi);
-            if (responselen >= sizeof (RIL_SignalStrength_v8)) {
-                p.writeInt32(p_cur->LTE_SignalStrength.timingAdvance);
-                if (responselen >= sizeof (RIL_SignalStrength_v9_CAF)) {
-                    p.writeInt32(p_cur->TD_SCDMA_SignalStrength.rscp);
-                } else {
-                    p.writeInt32(INT_MAX);
-                }
+            if (responselen >= sizeof (RIL_SignalStrength_v7)) {
+                p.writeInt32(p_cur->TD_SCDMA_SignalStrength.rscp);
             } else {
-                p.writeInt32(INT_MAX);
-                p.writeInt32(INT_MAX);
+                memset(&p_cur->TD_SCDMA_SignalStrength, 0, sizeof (RIL_TD_SCDMA_SignalStrength));
             }
-
         } else {
-            p.writeInt32(99);
-            p.writeInt32(INT_MAX);
-            p.writeInt32(INT_MAX);
-            p.writeInt32(INT_MAX);
-            p.writeInt32(INT_MAX);
-            p.writeInt32(INT_MAX);
-            p.writeInt32(INT_MAX);
+            memset(&p_cur->LTE_SignalStrength, 0, sizeof (RIL_LTE_SignalStrength));
+            memset(&p_cur->TD_SCDMA_SignalStrength, 0, sizeof (RIL_TD_SCDMA_SignalStrength));
         }
 
         startResponse;
@@ -2407,7 +2447,7 @@ static int responseRilSignalStrength(Parcel &p,
         closeResponse;
 
     } else {
-        RLOGE("invalid response length");
+        ALOGE("invalid response length");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
@@ -2424,12 +2464,12 @@ static int responseCallRing(Parcel &p, void *response, size_t responselen) {
 
 static int responseCdmaSignalInfoRecord(Parcel &p, void *response, size_t responselen) {
     if (response == NULL || responselen == 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen != sizeof (RIL_CDMA_SignalInfoRecord)) {
-        RLOGE("invalid response length %d expected sizeof (RIL_CDMA_SignalInfoRecord) of %d\n",
+        ALOGE("invalid response length %d expected sizeof (RIL_CDMA_SignalInfoRecord) of %d\n",
             (int)responselen, (int)sizeof (RIL_CDMA_SignalInfoRecord));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2454,12 +2494,12 @@ static int responseCdmaSignalInfoRecord(Parcel &p, void *response, size_t respon
 static int responseCdmaCallWaiting(Parcel &p, void *response,
             size_t responselen) {
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen < sizeof(RIL_CDMA_CallWaiting_v6)) {
-        RLOGW("Upgrade to ril version %d\n", RIL_VERSION);
+        ALOGW("Upgrade to ril version %d\n", RIL_VERSION);
     }
 
     RIL_CDMA_CallWaiting_v6 *p_cur = ((RIL_CDMA_CallWaiting_v6 *) response);
@@ -2498,12 +2538,12 @@ static int responseCdmaCallWaiting(Parcel &p, void *response,
 
 static int responseSimRefresh(Parcel &p, void *response, size_t responselen) {
     if (response == NULL && responselen != 0) {
-        RLOGE("responseSimRefresh: invalid response: NULL");
+        ALOGE("responseSimRefresh: invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     startResponse;
-    if (s_callbacks.version >= 7) {
+    if (s_callbacks[0].version == 7) {
         RIL_SimRefreshResponse_v7 *p_cur = ((RIL_SimRefreshResponse_v7 *) response);
         p.writeInt32(p_cur->result);
         p.writeInt32(p_cur->ef_id);
@@ -2530,148 +2570,17 @@ static int responseSimRefresh(Parcel &p, void *response, size_t responselen) {
     return 0;
 }
 
-static int responseCellInfoList(Parcel &p, void *response, size_t responselen)
-{
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_CellInfo) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_CellInfo));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    int num = responselen / sizeof(RIL_CellInfo);
-    p.writeInt32(num);
-
-    RIL_CellInfo *p_cur = (RIL_CellInfo *) response;
-    startResponse;
-    int i;
-    for (i = 0; i < num; i++) {
-        appendPrintBuf("%s[%d: type=%d,registered=%d,timeStampType=%d,timeStamp=%lld", printBuf, i,
-            p_cur->cellInfoType, p_cur->registered, p_cur->timeStampType, p_cur->timeStamp);
-        p.writeInt32((int)p_cur->cellInfoType);
-        p.writeInt32(p_cur->registered);
-        p.writeInt32(p_cur->timeStampType);
-        p.writeInt64(p_cur->timeStamp);
-        switch(p_cur->cellInfoType) {
-            case RIL_CELL_INFO_TYPE_GSM: {
-                appendPrintBuf("%s GSM id: mcc=%d,mnc=%d,lac=%d,cid=%d,", printBuf,
-                    p_cur->CellInfo.gsm.cellIdentityGsm.mcc,
-                    p_cur->CellInfo.gsm.cellIdentityGsm.mnc,
-                    p_cur->CellInfo.gsm.cellIdentityGsm.lac,
-                    p_cur->CellInfo.gsm.cellIdentityGsm.cid);
-                appendPrintBuf("%s gsmSS: ss=%d,ber=%d],", printBuf,
-                    p_cur->CellInfo.gsm.signalStrengthGsm.signalStrength,
-                    p_cur->CellInfo.gsm.signalStrengthGsm.bitErrorRate);
-
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mcc);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mnc);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.lac);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.cid);
-                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.signalStrength);
-                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.bitErrorRate);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_WCDMA: {
-                appendPrintBuf("%s WCDMA id: mcc=%d,mnc=%d,lac=%d,cid=%d,psc=%d,", printBuf,
-                    p_cur->CellInfo.wcdma.cellIdentityWcdma.mcc,
-                    p_cur->CellInfo.wcdma.cellIdentityWcdma.mnc,
-                    p_cur->CellInfo.wcdma.cellIdentityWcdma.lac,
-                    p_cur->CellInfo.wcdma.cellIdentityWcdma.cid,
-                    p_cur->CellInfo.wcdma.cellIdentityWcdma.psc);
-                appendPrintBuf("%s wcdmaSS: ss=%d,ber=%d],", printBuf,
-                    p_cur->CellInfo.wcdma.signalStrengthWcdma.signalStrength,
-                    p_cur->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate);
-
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mcc);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mnc);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.lac);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.cid);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.psc);
-                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.signalStrength);
-                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_CDMA: {
-                appendPrintBuf("%s CDMA id: nId=%d,sId=%d,bsId=%d,long=%d,lat=%d", printBuf,
-                    p_cur->CellInfo.cdma.cellIdentityCdma.networkId,
-                    p_cur->CellInfo.cdma.cellIdentityCdma.systemId,
-                    p_cur->CellInfo.cdma.cellIdentityCdma.basestationId,
-                    p_cur->CellInfo.cdma.cellIdentityCdma.longitude,
-                    p_cur->CellInfo.cdma.cellIdentityCdma.latitude);
-
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.networkId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.systemId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.basestationId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.longitude);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.latitude);
-
-                appendPrintBuf("%s cdmaSS: dbm=%d ecio=%d evdoSS: dbm=%d,ecio=%d,snr=%d", printBuf,
-                    p_cur->CellInfo.cdma.signalStrengthCdma.dbm,
-                    p_cur->CellInfo.cdma.signalStrengthCdma.ecio,
-                    p_cur->CellInfo.cdma.signalStrengthEvdo.dbm,
-                    p_cur->CellInfo.cdma.signalStrengthEvdo.ecio,
-                    p_cur->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio);
-
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.dbm);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.ecio);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.dbm);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.ecio);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_LTE: {
-                appendPrintBuf("%s LTE id: mcc=%d,mnc=%d,ci=%d,pci=%d,tac=%d", printBuf,
-                    p_cur->CellInfo.lte.cellIdentityLte.mcc,
-                    p_cur->CellInfo.lte.cellIdentityLte.mnc,
-                    p_cur->CellInfo.lte.cellIdentityLte.ci,
-                    p_cur->CellInfo.lte.cellIdentityLte.pci,
-                    p_cur->CellInfo.lte.cellIdentityLte.tac);
-
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mcc);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mnc);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.ci);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.pci);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.tac);
-
-                appendPrintBuf("%s lteSS: ss=%d,rsrp=%d,rsrq=%d,rssnr=%d,cqi=%d,ta=%d", printBuf,
-                    p_cur->CellInfo.lte.signalStrengthLte.signalStrength,
-                    p_cur->CellInfo.lte.signalStrengthLte.rsrp,
-                    p_cur->CellInfo.lte.signalStrengthLte.rsrq,
-                    p_cur->CellInfo.lte.signalStrengthLte.rssnr,
-                    p_cur->CellInfo.lte.signalStrengthLte.cqi,
-                    p_cur->CellInfo.lte.signalStrengthLte.timingAdvance);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.signalStrength);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrp);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrq);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rssnr);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.cqi);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.timingAdvance);
-                break;
-            }
-        }
-        p_cur += 1;
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
 static int responseSSData(Parcel &p, void *response, size_t responselen) {
-    RLOGD("In responseSSData");
+    ALOGD("In responseSSData");
     int num;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen != sizeof(RIL_StkCcUnsolSsResponse)) {
-        RLOGE("invalid response length %d, expected %d",
+        ALOGE("invalid response length %d, expected %d",
                (int)responselen, (int)sizeof(RIL_StkCcUnsolSsResponse));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2684,10 +2593,10 @@ static int responseSSData(Parcel &p, void *response, size_t responselen) {
     p.writeInt32(p_cur->serviceClass);
     p.writeInt32(p_cur->result);
 
-    if (isServiceTypeCfQuery(p_cur->serviceType, p_cur->requestType)) {
-        RLOGD("responseSSData CF type, num of Cf elements %d", p_cur->cfData.numValidIndexes);
+    if (isServiceTypeCFQuery(p_cur->serviceType, p_cur->requestType)) {
+        ALOGD("responseSSData CF type, num of Cf elements %d", p_cur->cfData.numValidIndexes);
         if (p_cur->cfData.numValidIndexes > NUM_SERVICE_CLASSES) {
-            RLOGE("numValidIndexes is greater than max value %d, "
+            ALOGE("numValidIndexes is greater than max value %d, "
                   "truncating it to max value", NUM_SERVICE_CLASSES);
             p_cur->cfData.numValidIndexes = NUM_SERVICE_CLASSES;
         }
@@ -2706,7 +2615,7 @@ static int responseSSData(Parcel &p, void *response, size_t responselen) {
              appendPrintBuf("%s[%s,reason=%d,cls=%d,toa=%d,%s,tout=%d],", printBuf,
                  (cf.status==1)?"enable":"disable", cf.reason, cf.serviceClass, cf.toa,
                   (char*)cf.number, cf.timeSeconds);
-             RLOGD("Data: %d,reason=%d,cls=%d,toa=%d,num=%s,tout=%d],", cf.status,
+             ALOGD("Data: %d,reason=%d,cls=%d,toa=%d,num=%s,tout=%d],", cf.status,
                   cf.reason, cf.serviceClass, cf.toa, (char*)cf.number, cf.timeSeconds);
         }
     } else {
@@ -2715,7 +2624,7 @@ static int responseSSData(Parcel &p, void *response, size_t responselen) {
         /* each int*/
         for (int i = 0; i < SS_INFO_MAX; i++) {
              appendPrintBuf("%s%d,", printBuf, p_cur->ssInfo[i]);
-             RLOGD("Data: %d",p_cur->ssInfo[i]);
+             ALOGD("Data: %d",p_cur->ssInfo[i]);
              p.writeInt32(p_cur->ssInfo[i]);
         }
     }
@@ -2725,7 +2634,7 @@ static int responseSSData(Parcel &p, void *response, size_t responselen) {
     return 0;
 }
 
-static bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType) {
+static bool isServiceTypeCFQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType) {
     if ((reqType == SS_INTERROGATION) &&
         (serType == SS_CFU ||
          serType == SS_CF_BUSY ||
@@ -2738,6 +2647,22 @@ static bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType re
     return false;
 }
 
+static int responseUiccSubscription(Parcel &p,
+        void *response,size_t responselen) {
+
+    ALOGD("In responseUiccSubscription");
+    startResponse;
+
+    RIL_SelectUiccSub *p_cur = (RIL_SelectUiccSub *)response;
+    p.writeInt32(p_cur->slot);
+    p.writeInt32(p_cur->app_index);
+    p.writeInt32(p_cur->sub_type);
+    p.writeInt32(p_cur->act_status);
+
+    closeResponse;
+    return 0;
+}
+
 static void triggerEvLoop() {
     int ret;
     if (!pthread_equal(pthread_self(), s_tid_dispatch)) {
@@ -2786,7 +2711,7 @@ static int responseSimStatus(Parcel &p, void *response, size_t responselen) {
     int i;
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
@@ -2811,7 +2736,7 @@ static int responseSimStatus(Parcel &p, void *response, size_t responselen) {
 
         sendSimStatusAppInfo(p, p_cur->num_applications, p_cur->applications);
     } else {
-        RLOGE("responseSimStatus: A RilCardStatus_v6 or _v5 expected\n");
+        ALOGE("responseSimStatus: A RilCardStatus_v6 or _v5 expected\n");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
@@ -2873,15 +2798,15 @@ static int responseCdmaSms(Parcel &p, void *response, size_t responselen) {
     uint8_t uct;
     void* dest;
 
-    RLOGD("Inside responseCdmaSms");
+    ALOGD("Inside responseCdmaSms");
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
     if (responselen != sizeof(RIL_CDMA_SMS_Message)) {
-        RLOGE("invalid response length was %d expected %d",
+        ALOGE("invalid response length was %d expected %d",
                 (int)responselen, (int)sizeof(RIL_CDMA_SMS_Message));
         return RIL_ERRNO_INVALID_RESPONSE;
     }
@@ -2928,14 +2853,14 @@ static int responseCdmaSms(Parcel &p, void *response, size_t responselen) {
 static int responseGetDataCallProfile(Parcel &p, void *response, size_t responselen) {
     int num = 0;
 
-    RLOGD("[OMH>]> %d", responselen);
+    ALOGD("[OMH>]> %d", responselen);
 
     if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
+        ALOGE("invalid response: NULL");
         return RIL_ERRNO_INVALID_RESPONSE;
     }
 
-    RLOGD("[OMH>]> processing response");
+    ALOGD("[OMH>]> processing response");
 
     /* number of profile info's */
     num = *((int *) response);
@@ -2969,7 +2894,7 @@ static void processWakeupCallback(int fd, short flags, void *param) {
     char buff[16];
     int ret;
 
-    RLOGV("processWakeupCallback");
+    ALOGV("processWakeupCallback");
 
     /* empty our wakeup socket out */
     do {
@@ -3000,18 +2925,17 @@ static void onCommandsSocketClosed() {
 }
 
 static void processCommandsCallback(int fd, short flags, void *param) {
-    RecordStream *p_rs;
     void *p_record;
+    RecordStreamInfo *p_rsInfo;
     size_t recordlen;
     int ret;
 
-    assert(fd == s_fdCommand);
-
-    p_rs = (RecordStream *)param;
+    p_rsInfo = (RecordStreamInfo *)param;
+    assert(fd == s_fdCommand[p_rsInfo->client_id]);
 
     for (;;) {
         /* loop until EAGAIN/EINTR, end of stream, or other error */
-        ret = record_stream_get_next(p_rs, &p_record, &recordlen);
+        ret = record_stream_get_next(p_rsInfo->p_rs, &p_record, &recordlen);
 
         if (ret == 0 && p_record == NULL) {
             /* end-of-stream */
@@ -3019,25 +2943,29 @@ static void processCommandsCallback(int fd, short flags, void *param) {
         } else if (ret < 0) {
             break;
         } else if (ret == 0) { /* && p_record != NULL */
-            processCommandBuffer(p_record, recordlen);
+            processCommandBuffer(p_record, recordlen, p_rsInfo->client_id);
         }
     }
 
     if (ret == 0 || !(errno == EAGAIN || errno == EINTR)) {
         /* fatal error or end-of-stream */
         if (ret != 0) {
-            RLOGE("error on reading command socket errno:%d\n", errno);
+            ALOGE("error on reading command socket errno:%d\n", errno);
         } else {
-            RLOGW("EOS.  Closing command socket.");
+            ALOGW("EOS.  Closing command socket.");
         }
 
-        close(s_fdCommand);
-        s_fdCommand = -1;
+        close(s_fdCommand[p_rsInfo->client_id]);
+        s_fdCommand[p_rsInfo->client_id] = -1;
 
-        ril_event_del(&s_commands_event);
+        ril_event_del(&s_commands_event[p_rsInfo->client_id]);
 
-        record_stream_free(p_rs);
+        record_stream_free(p_rsInfo->p_rs);
+        free(p_rsInfo);
 
+        // s_listen_event is persistent. So, delete the listen event from
+        // the watch list so that it doesn't get piled up.
+        ril_event_del(&s_listen_event);
         /* start listening for new connections again */
         rilEventAddWakeup(&s_listen_event);
 
@@ -3046,33 +2974,33 @@ static void processCommandsCallback(int fd, short flags, void *param) {
 }
 
 
-static void onNewCommandConnect() {
+static void onNewCommandConnect(int client_id) {
     // Inform we are connected and the ril version
-    int rilVer = s_callbacks.version;
-    RIL_onUnsolicitedResponse(RIL_UNSOL_RIL_CONNECTED,
-                                    &rilVer, sizeof(rilVer));
+    int rilVer = s_callbacks[client_id].version;
+    RIL_onUnsolicitedSendResponse(RIL_UNSOL_RIL_CONNECTED,
+                                    &rilVer, sizeof(rilVer), client_id);
 
     // implicit radio state changed
-    RIL_onUnsolicitedResponse(RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
-                                    NULL, 0);
+    RIL_onUnsolicitedSendResponse(RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
+                                    NULL, 0, client_id);
 
     // Send last NITZ time data, in case it was missed
     if (s_lastNITZTimeData != NULL) {
-        sendResponseRaw(s_lastNITZTimeData, s_lastNITZTimeDataSize);
+        sendResponseRaw(s_lastNITZTimeData, s_lastNITZTimeDataSize, client_id);
 
         free(s_lastNITZTimeData);
         s_lastNITZTimeData = NULL;
     }
 
     // Get version string
-    if (s_callbacks.getVersion != NULL) {
+    if (s_callbacks[client_id].getVersion != NULL) {
         const char *version;
-        version = s_callbacks.getVersion();
-        RLOGI("RIL Daemon version: %s\n", version);
+        version = s_callbacks[client_id].getVersion();
+        ALOGI("RIL Daemon version: %s\n", version);
 
         property_set(PROPERTY_RIL_IMPL, version);
     } else {
-        RLOGI("RIL Daemon version: unavailable\n");
+        ALOGI("RIL Daemon version: unavailable\n");
         property_set(PROPERTY_RIL_IMPL, "unavailable");
     }
 
@@ -3082,8 +3010,8 @@ static void listenCallback (int fd, short flags, void *param) {
     int ret;
     int err;
     int is_phone_socket;
-    RecordStream *p_rs;
-
+    char *p_record;
+    RecordStreamInfo *p_rsInfo;
     struct sockaddr_un peeraddr;
     socklen_t socklen = sizeof (peeraddr);
 
@@ -3092,16 +3020,19 @@ static void listenCallback (int fd, short flags, void *param) {
 
     struct passwd *pwd = NULL;
 
-    assert (s_fdCommand < 0);
+    ALOGD("**RILD ListenCallback**");
     assert (fd == s_fdListen);
 
-    s_fdCommand = accept(s_fdListen, (sockaddr *) &peeraddr, &socklen);
+    fd = accept(s_fdListen, (sockaddr *) &peeraddr, &socklen);
 
-    if (s_fdCommand < 0 ) {
-        RLOGE("Error on accept() errno:%d", errno);
+    if (fd < 0 ) {
+        ALOGE("Error on accept() errno:%d", errno);
+        // s_listen_event is persistent. So, delete the listen event from
+        // the watch list so that it doesn't get piled up.
+        ril_event_del(&s_listen_event);
         /* start listening for new connections again */
         rilEventAddWakeup(&s_listen_event);
-        return;
+	      return;
     }
 
     /* check the credential of the other side and only accept socket from
@@ -3110,7 +3041,7 @@ static void listenCallback (int fd, short flags, void *param) {
     errno = 0;
     is_phone_socket = 0;
 
-    err = getsockopt(s_fdCommand, SOL_SOCKET, SO_PEERCRED, &creds, &szCreds);
+    err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &creds, &szCreds);
 
     if (err == 0 && szCreds > 0) {
         errno = 0;
@@ -3119,45 +3050,93 @@ static void listenCallback (int fd, short flags, void *param) {
             if (strcmp(pwd->pw_name, PHONE_PROCESS) == 0) {
                 is_phone_socket = 1;
             } else {
-                RLOGE("RILD can't accept socket from process %s", pwd->pw_name);
+                ALOGE("RILD can't accept socket from process %s", pwd->pw_name);
             }
         } else {
-            RLOGE("Error on getpwuid() errno: %d", errno);
+            ALOGE("Error on getpwuid() errno: %d", errno);
         }
     } else {
-        RLOGD("Error on getsockopt() errno: %d", errno);
+        ALOGD("Error on getsockopt() errno: %d", errno);
     }
 
     if ( !is_phone_socket ) {
-      RLOGE("RILD must accept socket from %s", PHONE_PROCESS);
-
-      close(s_fdCommand);
-      s_fdCommand = -1;
+      ALOGE("RILD must accept socket from %s", PHONE_PROCESS);
 
+      close(fd);
+      fd = -1;
       onCommandsSocketClosed();
 
+      // s_listen_event is persistent. So, delete the listen event from
+      // the watch list so that it doesn't get piled up.
+      ril_event_del(&s_listen_event);
       /* start listening for new connections again */
       rilEventAddWakeup(&s_listen_event);
 
       return;
     }
 
-    ret = fcntl(s_fdCommand, F_SETFL, O_NONBLOCK);
+    p_rsInfo = new RecordStreamInfo();
+    p_rsInfo->p_rs = record_stream_new(fd, MAX_COMMAND_BYTES);
+    p_record = (char *)malloc(sizeof(char) * SUB_DATA_LENGTH);
 
-    if (ret < 0) {
-        RLOGE ("Error setting O_NONBLOCK errno:%d", errno);
+    ret = read(fd, p_record, SUB_DATA_LENGTH);
+    if (ret <= 0) {
+        ALOGE("Client is not passing proper subscription values");
+
+        close(fd);
+        fd = -1;
+        onCommandsSocketClosed();
+
+        // s_listen_event is persistent. So, delete the listen event from
+        // the watch list so that it doesn't get piled up.
+        ril_event_del(&s_listen_event);
+        /* start listening for new connections again */
+        rilEventAddWakeup(&s_listen_event);
     }
 
-    RLOGI("libril: new connection");
+    p_rsInfo->client_id = 0;
+    if (strncmp(p_record, SUB1, SUB_DATA_LENGTH) == 0) {
+        p_rsInfo->client_id = 0;
+        ALOGI("Client ID :: %d", p_rsInfo->client_id);
+    } else if (strncmp(p_record, SUB2, SUB_DATA_LENGTH) == 0) {
+        p_rsInfo->client_id = 1;
+        ALOGI("Client ID :: %d", p_rsInfo->client_id);
+    } else {
+        ALOGE("Should not come here !!! buffer red :: %s", p_record);
+    }
 
-    p_rs = record_stream_new(s_fdCommand, MAX_COMMAND_BYTES);
+    s_fdCommand[p_rsInfo->client_id] = fd;
 
-    ril_event_set (&s_commands_event, s_fdCommand, 1,
-        processCommandsCallback, p_rs);
+    ALOGI("libril: new connection");
 
-    rilEventAddWakeup (&s_commands_event);
+    bool isAllClientsConnected = true;
+    for (int i = 0; i < s_maxNumClients; i++) {
+        if (s_fdCommand[i] == -1) {
+            isAllClientsConnected = false;
+            break;
+        }
+    }
+
+    if (isAllClientsConnected) {
+        // s_listen_event is persistent. So, delete the listen event from
+        // the watch list so that it doesn't get piled up.
+        ALOGI("All clients are connected remove listen socket from watch table");
+        ril_event_del(&s_listen_event); //All clients are connected so no need of listen socket
+    }
+
+
+    ret = fcntl(fd, F_SETFL, O_NONBLOCK);
 
-    onNewCommandConnect();
+    if (ret < 0) {
+        ALOGE ("Error setting O_NONBLOCK errno:%d", errno);
+    }
+
+    ril_event_set (&s_commands_event[p_rsInfo->client_id], s_fdCommand[p_rsInfo->client_id], 1,
+        processCommandsCallback, p_rsInfo);
+
+    rilEventAddWakeup (&s_commands_event[p_rsInfo->client_id]);
+
+    onNewCommandConnect(p_rsInfo->client_id);
 }
 
 static void freeDebugCallbackArgs(int number, char **args) {
@@ -3181,16 +3160,40 @@ static void debugCallback (int fd, short flags, void *param) {
     int hangupData[1] = {1};
     int number;
     char **args;
+    char *p_record;
+    int ret;
 
     acceptFD = accept (fd,  (sockaddr *) &peeraddr, &socklen);
 
     if (acceptFD < 0) {
-        RLOGE ("error accepting on debug port: %d\n", errno);
+        ALOGE ("error accepting on debug port: %d\n", errno);
         return;
     }
 
+    p_record = (char *)malloc(sizeof(char) * SUB_DATA_LENGTH);
+    ret = read(acceptFD, p_record, SUB_DATA_LENGTH);
+
+    if (ret <= 0) {
+        close(acceptFD);
+        ALOGE ("error Client is not sending proper subscription information");
+        return;
+    }
+
+    int client_id = 0;
+    if (strncmp(p_record, SUB1, SUB_DATA_LENGTH) == 0) {
+        client_id = 0;
+        ALOGI("Debug Client ID :: %d", client_id);
+    } else if (strncmp(p_record, SUB2, SUB_DATA_LENGTH) == 0) {
+        client_id = 1;
+        ALOGI("Debug Client ID :: %d", client_id);
+    } else {
+        ALOGE("Should not come here !!! debug socket buffer red :: %s", p_record);
+    }
+
+    s_fdCommand[client_id] = acceptFD;
+
     if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
-        RLOGE ("error reading on socket: number of Args: \n");
+        ALOGE ("error reading on socket: number of Args: \n");
         return;
     }
     args = (char **) malloc(sizeof(char*) * number);
@@ -3198,7 +3201,7 @@ static void debugCallback (int fd, short flags, void *param) {
     for (int i = 0; i < number; i++) {
         int len;
         if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
-            RLOGE ("error reading on socket: Len of Args: \n");
+            ALOGE ("error reading on socket: Len of Args: \n");
             freeDebugCallbackArgs(i, args);
             return;
         }
@@ -3206,7 +3209,7 @@ static void debugCallback (int fd, short flags, void *param) {
         args[i] = (char *) malloc((sizeof(char) * len) + 1);
         if (recv(acceptFD, args[i], sizeof(char) * len, 0)
             != (int)sizeof(char) * len) {
-            RLOGE ("error reading on socket: Args[%d] \n", i);
+            ALOGE ("error reading on socket: Args[%d] \n", i);
             freeDebugCallbackArgs(i, args);
             return;
         }
@@ -3216,24 +3219,24 @@ static void debugCallback (int fd, short flags, void *param) {
 
     switch (atoi(args[0])) {
         case 0:
-            RLOGI ("Connection on debug port: issuing reset.");
-            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0);
+            ALOGI ("Connection on debug port: issuing reset.");
+            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, client_id);
             break;
         case 1:
-            RLOGI ("Connection on debug port: issuing radio power off.");
+            ALOGI ("Connection on debug port: issuing radio power off.");
             data = 0;
-            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int));
+            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), client_id);
             // Close the socket
-            close(s_fdCommand);
-            s_fdCommand = -1;
+            close(s_fdCommand[client_id]);
+            s_fdCommand[client_id] = -1;
             break;
         case 2:
-            RLOGI ("Debug port: issuing unsolicited voice network change.");
-            RIL_onUnsolicitedResponse(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED,
-                                      NULL, 0);
+            ALOGI ("Debug port: issuing unsolicited voice network change.");
+            RIL_onUnsolicitedSendResponse(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED,
+                                      NULL, 0, client_id);
             break;
         case 3:
-            RLOGI ("Debug port: QXDM log enable.");
+            ALOGI ("Debug port: QXDM log enable.");
             qxdm_data[0] = 65536;     // head.func_tag
             qxdm_data[1] = 16;        // head.len
             qxdm_data[2] = 1;         // mode: 1 for 'start logging'
@@ -3241,10 +3244,10 @@ static void debugCallback (int fd, short flags, void *param) {
             qxdm_data[4] = 0;         // log_mask
             qxdm_data[5] = 8;         // log_max_fileindex
             issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
-                              6 * sizeof(int));
+                              6 * sizeof(int), client_id);
             break;
         case 4:
-            RLOGI ("Debug port: QXDM log disable.");
+            ALOGI ("Debug port: QXDM log disable.");
             qxdm_data[0] = 65536;
             qxdm_data[1] = 16;
             qxdm_data[2] = 0;          // mode: 0 for 'stop logging'
@@ -3252,48 +3255,48 @@ static void debugCallback (int fd, short flags, void *param) {
             qxdm_data[4] = 0;
             qxdm_data[5] = 8;
             issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
-                              6 * sizeof(int));
+                              6 * sizeof(int), client_id);
             break;
         case 5:
-            RLOGI("Debug port: Radio On");
+            ALOGI("Debug port: Radio On");
             data = 1;
-            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int));
+            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), client_id);
             sleep(2);
             // Set network selection automatic.
-            issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0);
+            issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, client_id);
             break;
         case 6:
-            RLOGI("Debug port: Setup Data Call, Apn :%s\n", args[1]);
+            ALOGI("Debug port: Setup Data Call, Apn :%s\n", args[1]);
             actData[0] = args[1];
             issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
-                              sizeof(actData));
+                              sizeof(actData), client_id);
             break;
         case 7:
-            RLOGI("Debug port: Deactivate Data Call");
+            ALOGI("Debug port: Deactivate Data Call");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
-                              sizeof(deactData));
+                              sizeof(deactData), client_id);
             break;
         case 8:
-            RLOGI("Debug port: Dial Call");
+            ALOGI("Debug port: Dial Call");
             dialData.clir = 0;
             dialData.address = args[1];
-            issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData));
+            issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), client_id);
             break;
         case 9:
-            RLOGI("Debug port: Answer Call");
-            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0);
+            ALOGI("Debug port: Answer Call");
+            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, client_id);
             break;
         case 10:
-            RLOGI("Debug port: End Call");
+            ALOGI("Debug port: End Call");
             issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
-                              sizeof(hangupData));
+                              sizeof(hangupData), client_id);
             break;
         default:
-            RLOGE ("Invalid request");
+            ALOGE ("Invalid request");
             break;
     }
     freeDebugCallbackArgs(number, args);
-    close(acceptFD);
+    close(s_fdCommand[client_id]);
 }
 
 
@@ -3319,10 +3322,12 @@ eventLoop(void *param) {
     int ret;
     int filedes[2];
 
+    ALOGE("entering eventLoop");
     ril_event_init();
 
     pthread_mutex_lock(&s_startupMutex);
 
+    ALOGE("setting s_started as 1");
     s_started = 1;
     pthread_cond_broadcast(&s_startupCond);
 
@@ -3331,7 +3336,7 @@ eventLoop(void *param) {
     ret = pipe(filedes);
 
     if (ret < 0) {
-        RLOGE("Error in pipe() errno:%d", errno);
+        ALOGE("Error in pipe() errno:%d", errno);
         return NULL;
     }
 
@@ -3347,7 +3352,7 @@ eventLoop(void *param) {
 
     // Only returns on error
     ril_event_loop();
-    RLOGE ("error in event_loop_base errno:%d", errno);
+    ALOGE ("error in event_loop_base errno:%d", errno);
     // kill self to restart on error
     kill(0, SIGKILL);
 
@@ -3356,66 +3361,68 @@ eventLoop(void *param) {
 
 extern "C" void
 RIL_startEventLoop(void) {
+    int ret;
+    pthread_attr_t attr;
+
     /* spin up eventLoop thread and wait for it to get started */
     s_started = 0;
     pthread_mutex_lock(&s_startupMutex);
 
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
+    pthread_attr_init (&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-    int result = pthread_create(&s_tid_dispatch, &attr, eventLoop, NULL);
-    if (result != 0) {
-        RLOGE("Failed to create dispatch thread: %s", strerror(result));
-        goto done;
-    }
+    ret = pthread_create(&s_tid_dispatch, &attr, eventLoop, NULL);
 
     while (s_started == 0) {
         pthread_cond_wait(&s_startupCond, &s_startupMutex);
     }
 
-done:
     pthread_mutex_unlock(&s_startupMutex);
+
+    if (ret < 0) {
+        ALOGE("Failed to create dispatch thread errno:%d", errno);
+        return;
+    }
 }
 
 // Used for testing purpose only.
-extern "C" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
-    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
+extern "C" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks, int client_id) {
+    memcpy(&s_callbacks[client_id], callbacks, sizeof (RIL_RadioFunctions));
 }
 
 extern "C" void
-RIL_register (const RIL_RadioFunctions *callbacks) {
+RIL_register (const RIL_RadioFunctions *callbacks, int client_id) {
     int ret;
     int flags;
 
     if (callbacks == NULL) {
-        RLOGE("RIL_register: RIL_RadioFunctions * null");
+        ALOGE("RIL_register: RIL_RadioFunctions * null");
         return;
     }
     if (callbacks->version < RIL_VERSION_MIN) {
-        RLOGE("RIL_register: version %d is to old, min version is %d",
+        ALOGE("RIL_register: version %d is to old, min version is %d",
              callbacks->version, RIL_VERSION_MIN);
         return;
     }
     if (callbacks->version > RIL_VERSION) {
-        RLOGE("RIL_register: version %d is too new, max version is %d",
+        ALOGE("RIL_register: version %d is too new, max version is %d",
              callbacks->version, RIL_VERSION);
         return;
     }
-    RLOGE("RIL_register: RIL version %d", callbacks->version);
+    ALOGE("RIL_register: RIL version %d", callbacks->version);
 
-    if (s_registerCalled > 0) {
-        RLOGE("RIL_register has been called more than once. "
+    if (s_registerCalled >= MAX_NUM_CLIENTS) {
+        ALOGE("RIL_register has been called more than once. "
                 "Subsequent call ignored");
         return;
     }
 
-    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
+    memcpy(&s_callbacks[client_id], callbacks, sizeof (RIL_RadioFunctions));
 
-    s_registerCalled = 1;
+    s_registerCalled++;
 
     // Little self-check
 
+#ifndef RIL_VARIANT_LEGACY
     for (int i = 0; i < (int)NUM_ELEMS(s_commands); i++) {
         assert(i == s_commands[i].requestNumber);
     }
@@ -3424,6 +3431,7 @@ RIL_register (const RIL_RadioFunctions *callbacks) {
         assert(i + RIL_UNSOL_RESPONSE_BASE
                 == s_unsolResponses[i].requestNumber);
     }
+#endif
 
     // New rild impl calls RIL_startEventLoop() first
     // old standalone impl wants it here.
@@ -3439,30 +3447,40 @@ RIL_register (const RIL_RadioFunctions *callbacks) {
             ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM);
 
     if (ret < 0) {
-        RLOGE("Unable to bind socket errno:%d", errno);
+        ALOGE("Unable to bind socket errno:%d", errno);
         exit (-1);
     }
     s_fdListen = ret;
 
 #else
+
+    ALOGE("s_registerCalled = %d, s_started = %d, RIL_getMaxNumClients = %d", s_registerCalled,
+            s_started, RIL_getMaxNumClients());
+
+    // Create the rild socket only after initializing all RIL instances.
+    if (s_registerCalled != RIL_getMaxNumClients()) {
+        return ;
+    }
+
     s_fdListen = android_get_control_socket(RIL_getRilSocketName());
     if (s_fdListen < 0) {
-        RLOGE("Failed to get socket %s",RIL_getRilSocketName());
+        ALOGE("Failed to get socket %s", RIL_getRilSocketName());
         exit(-1);
     }
 
     ret = listen(s_fdListen, 4);
+    ALOGD(" Ril register s_fdListen=%d",s_fdListen);
 
     if (ret < 0) {
-        RLOGE("Failed to listen on control socket '%d': %s",
+        ALOGE("Failed to listen on control socket '%d': %s",
              s_fdListen, strerror(errno));
         exit(-1);
     }
 #endif
 
 
-    /* note: non-persistent so we can accept only one connection at a time */
-    ril_event_set (&s_listen_event, s_fdListen, false,
+    /*Make it persistent FD so that rild can listen for second client also */
+    ril_event_set (&s_listen_event, s_fdListen, true,
                 listenCallback, NULL);
 
     rilEventAddWakeup (&s_listen_event);
@@ -3470,26 +3488,23 @@ RIL_register (const RIL_RadioFunctions *callbacks) {
 #if 1
     // start debug interface socket
 
-    char *inst = NULL;
-    if (strlen(RIL_getRilSocketName()) >= strlen(SOCKET_NAME_RIL)) {
-        inst = RIL_getRilSocketName() + strlen(SOCKET_NAME_RIL);
-    }
-
-    char rildebug[MAX_DEBUG_SOCKET_NAME_LENGTH] = SOCKET_NAME_RIL_DEBUG;
-    if (inst != NULL) {
-        strncat(rildebug, inst, MAX_DEBUG_SOCKET_NAME_LENGTH);
+    char rildebug[12] = {0};
+    if (strcmp(RIL_getRilSocketName(), "rild") == 0) {
+        strcpy(rildebug, "rild-debug");
+    } else {
+        strcpy(rildebug, "rild-debug1");
     }
 
     s_fdDebug = android_get_control_socket(rildebug);
     if (s_fdDebug < 0) {
-        RLOGE("Failed to get socket : %s errno:%d", rildebug, errno);
+        ALOGE("Failed to get socket %s errno:%d", rildebug, errno);
         exit(-1);
     }
 
     ret = listen(s_fdDebug, 4);
 
     if (ret < 0) {
-        RLOGE("Failed to listen on ril debug socket '%d': %s",
+        ALOGE("Failed to listen on ril debug socket '%d': %s",
              s_fdDebug, strerror(errno));
         exit(-1);
     }
@@ -3539,14 +3554,14 @@ RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responsel
     pRI = (RequestInfo *)t;
 
     if (!checkAndDequeueRequestInfo(pRI)) {
-        RLOGE ("RIL_onRequestComplete: invalid RIL_Token");
+        ALOGE ("RIL_onRequestComplete: invalid RIL_Token");
         return;
     }
 
     if (pRI->local > 0) {
         // Locally issued command...void only!
         // response does not go back up the command socket
-        RLOGD("C[locl]< %s", requestToString(pRI->pCI->requestNumber));
+        ALOGD("C[locl]< %s", requestToString(pRI->pCI->requestNumber));
 
         goto done;
     }
@@ -3578,10 +3593,10 @@ RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responsel
             appendPrintBuf("%s fails by %s", printBuf, failCauseToString(e));
         }
 
-        if (s_fdCommand < 0) {
-            RLOGD ("RIL onRequestComplete: Command channel closed");
+        if (s_fdCommand[0] < 0 || s_fdCommand[1] < 0) {
+            ALOGD ("RIL onRequestComplete: Command channel closed");
         }
-        sendResponse(p);
+        sendResponse(p,pRI->client_id);
     }
 
 done:
@@ -3606,11 +3621,11 @@ static void
 wakeTimeoutCallback (void *param) {
     // We're using "param != NULL" as a cancellation mechanism
     if (param == NULL) {
-        //RLOGD("wakeTimeout: releasing wake lock");
+        //ALOGD("wakeTimeout: releasing wake lock");
 
         releaseWakeLock();
     } else {
-        //RLOGD("wakeTimeout: releasing wake lock CANCELLED");
+        //ALOGD("wakeTimeout: releasing wake lock CANCELLED");
     }
 }
 
@@ -3630,7 +3645,7 @@ decodeVoiceRadioTechnology (RIL_RadioState radioState) {
             return RADIO_TECH_1xRTT;
 
         default:
-            RLOGD("decodeVoiceRadioTechnology: Invoked with incorrect RadioState");
+            ALOGD("decodeVoiceRadioTechnology: Invoked with incorrect RadioState");
             return -1;
     }
 }
@@ -3651,7 +3666,7 @@ decodeCdmaSubscriptionSource (RIL_RadioState radioState) {
             return CDMA_SUBSCRIPTION_SOURCE_NV;
 
         default:
-            RLOGD("decodeCdmaSubscriptionSource: Invoked with incorrect RadioState");
+            ALOGD("decodeCdmaSubscriptionSource: Invoked with incorrect RadioState");
             return -1;
     }
 }
@@ -3670,7 +3685,7 @@ decodeSimStatus (RIL_RadioState radioState) {
        case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:
            return radioState;
        default:
-           RLOGD("decodeSimStatus: Invoked with incorrect RadioState");
+           ALOGD("decodeSimStatus: Invoked with incorrect RadioState");
            return -1;
    }
 }
@@ -3695,7 +3710,7 @@ static bool is3gpp2(int radioTech) {
  * returned when telephony framework requests them
  */
 static RIL_RadioState
-processRadioState(RIL_RadioState newRadioState) {
+processRadioState(RIL_RadioState newRadioState, int client_id) {
 
     if((newRadioState > RADIO_STATE_UNAVAILABLE) && (newRadioState < RADIO_STATE_ON)) {
         int newVoiceRadioTech;
@@ -3707,15 +3722,15 @@ processRadioState(RIL_RadioState newRadioState) {
         newVoiceRadioTech = decodeVoiceRadioTechnology(newRadioState);
         if(newVoiceRadioTech != voiceRadioTech) {
             voiceRadioTech = newVoiceRadioTech;
-            RIL_onUnsolicitedResponse (RIL_UNSOL_VOICE_RADIO_TECH_CHANGED,
-                        &voiceRadioTech, sizeof(voiceRadioTech));
+            RIL_onUnsolicitedSendResponse (RIL_UNSOL_VOICE_RADIO_TECH_CHANGED,
+                        &voiceRadioTech, sizeof(voiceRadioTech), client_id);
         }
         if(is3gpp2(newVoiceRadioTech)) {
             newCdmaSubscriptionSource = decodeCdmaSubscriptionSource(newRadioState);
             if(newCdmaSubscriptionSource != cdmaSubscriptionSource) {
                 cdmaSubscriptionSource = newCdmaSubscriptionSource;
-                RIL_onUnsolicitedResponse (RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED,
-                        &cdmaSubscriptionSource, sizeof(cdmaSubscriptionSource));
+                RIL_onUnsolicitedSendResponse (RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED,
+                        &cdmaSubscriptionSource, sizeof(cdmaSubscriptionSource), client_id);
             }
         }
         newSimStatus = decodeSimStatus(newRadioState);
@@ -3732,33 +3747,80 @@ processRadioState(RIL_RadioState newRadioState) {
 }
 
 extern "C"
-void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
+void RIL_onUnsolicitedResponse(int unsolResponse, void *data,
                                 size_t datalen)
 {
+    RIL_onUnsolicitedSendResponse(unsolResponse, data, datalen, 0);
+}
+
+extern "C" void
+RIL_onUnsolicitedResponse2(int unsolResponse, void *data,
+                                size_t datalen)
+{
+    RIL_onUnsolicitedSendResponse(unsolResponse, data, datalen, 1);
+}
+
+void
+RIL_onUnsolicitedSendResponse(int unsolResponse, void *data,
+                                size_t datalen, int client_id)
+{
+#ifndef RIL_VARIANT_LEGACY
     int unsolResponseIndex;
+#endif
     int ret;
     int64_t timeReceived = 0;
     bool shouldScheduleTimeout = false;
     RIL_RadioState newState;
 
     if (s_registerCalled == 0) {
-        // Ignore RIL_onUnsolicitedResponse before RIL_register
-        RLOGW("RIL_onUnsolicitedResponse called before RIL_register");
+        // Ignore RIL_onUnsolicitedSendResponse before RIL_register
+        ALOGW("RIL_onUnsolicitedSendResponse called before RIL_register");
         return;
     }
 
+#ifdef RIL_VARIANT_LEGACY
+    UnsolResponseInfo * uri = NULL;
+    int rilj_id = 0;
+    if (unsolResponse >= RIL_UNSOL_RESPONSE_BASE) {
+        // Translate RILJ res_id to RILC res_id
+        for (int32_t rq = 0; rq < (int32_t)NUM_ELEMS(s_unsolResponses); rq++) {
+            if (s_unsolResponses[rq].requestNumber == unsolResponse) {
+                uri = &(s_unsolResponses[rq]);
+                break;
+            }
+        }
+        if (uri) {
+            if (uri->reqNumRILJ > 0) {
+                rilj_id = uri->reqNumRILJ;
+            } else
+            if (uri->reqNumRILJ == 0) {
+                rilj_id = uri->requestNumber;
+            }
+        }
+    }
+
+    if (!uri || !rilj_id) {
+        ALOGE("unsupported unsolicited response code %d", unsolResponse);
+        return;
+    }
+#else
     unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;
 
     if ((unsolResponseIndex < 0)
         || (unsolResponseIndex >= (int32_t)NUM_ELEMS(s_unsolResponses))) {
-        RLOGE("unsupported unsolicited response code %d", unsolResponse);
+        ALOGE("unsupported unsolicited response code %d", unsolResponse);
         return;
     }
+#endif
 
     // Grab a wake lock if needed for this reponse,
     // as we exit we'll either release it immediately
     // or set a timer to release it later.
+#ifdef RIL_VARIANT_LEGACY
+    switch (uri->wakeType) {
+#else
     switch (s_unsolResponses[unsolResponseIndex].wakeType) {
+#endif
         case WAKE_PARTIAL:
             grabPartialWakeLock();
             shouldScheduleTimeout = true;
@@ -3784,10 +3846,15 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     Parcel p;
 
     p.writeInt32 (RESPONSE_UNSOLICITED);
+#ifdef RIL_VARIANT_LEGACY
+    p.writeInt32 (rilj_id);
+    ret = uri->responseFunction(p, data, datalen);
+#else
     p.writeInt32 (unsolResponse);
 
     ret = s_unsolResponses[unsolResponseIndex]
-                .responseFunction(p, const_cast<void*>(data), datalen);
+                .responseFunction(p, data, datalen);
+#endif
     if (ret != 0) {
         // Problem with the response. Don't continue;
         goto error_exit;
@@ -3796,10 +3863,10 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     // some things get more payload
     switch(unsolResponse) {
         case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
-            newState = processRadioState(s_callbacks.onStateRequest());
+            newState = processRadioState(s_callbacks[client_id].onStateRequest(), client_id);
             p.writeInt32(newState);
             appendPrintBuf("%s {%s}", printBuf,
-                radioStateToString(s_callbacks.onStateRequest()));
+                radioStateToString(s_callbacks[client_id].onStateRequest()));
         break;
 
 
@@ -3813,7 +3880,7 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
         break;
     }
 
-    ret = sendResponse(p);
+    ret = sendResponse(p, client_id);
     if (ret != 0 && unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
 
         // Unfortunately, NITZ time is not poll/update like everything
@@ -4071,16 +4138,20 @@ requestToString(int request) {
         case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
         case RIL_REQUEST_VOICE_RADIO_TECH: return "VOICE_RADIO_TECH";
         case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
-#ifndef RIL_NO_CELL_INFO_LIST
-        case RIL_REQUEST_GET_CELL_INFO_LIST: return"GET_CELL_INFO_LIST";
-        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: return"SET_UNSOL_CELL_INFO_LIST_RATE";
-#endif
-        case RIL_REQUEST_SET_INITIAL_ATTACH_APN: return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
         case RIL_REQUEST_IMS_REGISTRATION_STATE: return "IMS_REGISTRATION_STATE";
         case RIL_REQUEST_IMS_SEND_SMS: return "IMS_SEND_SMS";
         case RIL_REQUEST_GET_DATA_CALL_PROFILE: return "GET_DATA_CALL_PROFILE";
-        case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "SET_UICC_SUBSCRIPTION";
-        case RIL_REQUEST_SET_DATA_SUBSCRIPTION: return "SET_DATA_SUBSCRIPTION";
+        case RIL_REQUEST_SETUP_QOS: return "REQUEST_SETUP_QOS";
+        case RIL_REQUEST_RELEASE_QOS: return "REQUEST_RELEASE_QOS";
+        case RIL_REQUEST_GET_QOS_STATUS: return "REQUEST_GET_QOS_STATUS";
+        case RIL_REQUEST_MODIFY_QOS: return "REQUEST_MODIFY_QOS";
+        case RIL_REQUEST_SUSPEND_QOS: return "REQUEST_SUSPEND_QOS";
+        case RIL_REQUEST_RESUME_QOS: return "REQUEST_RESUME_QOS";
+        case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "REQUEST_SET_UICC_SUBSCRIPTION";
+        case RIL_REQUEST_SET_DATA_SUBSCRIPTION: return "REQUEST_SET_DATA_SUBSCRIPTION";
+        case RIL_REQUEST_GET_UICC_SUBSCRIPTION: return "REQUEST_GET_UICC_SUBSCRIPTION";
+        case RIL_REQUEST_GET_DATA_SUBSCRIPTION: return "REQUEST_GET_DATA_SUBSCRIPTION";
+        case RIL_REQUEST_SET_SUBSCRIPTION_MODE: return "REQUEST_SET_SUBSCRIPTION_MODE";
         case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
         case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
         case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
@@ -4117,10 +4188,9 @@ requestToString(int request) {
         case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
         case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
         case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED: return "UNSOL_VOICE_RADIO_TECH_CHANGED";
-#ifndef RIL_NO_CELL_INFO_LIST
-        case RIL_UNSOL_CELL_INFO_LIST: return "UNSOL_CELL_INFO_LIST";
-#endif
         case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED: return "RESPONSE_IMS_NETWORK_STATE_CHANGED";
+        case RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED: return "RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED";
+        case RIL_UNSOL_QOS_STATE_CHANGED_IND: return "UNSOL_QOS_STATE_CHANGED_IND";
         case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED: return "UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
         default: return "<unknown request>";
     }
diff --git a/libril/ril_commands.h b/libril/ril_commands.h
old mode 100644
new mode 100755
index ca5a144..4236bcc
--- a/libril/ril_commands.h
+++ b/libril/ril_commands.h
@@ -1,8 +1,10 @@
 /* //device/libs/telephony/ril_commands.h
 **
-** Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
-** Not a Contribution
 ** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2012, The Linux Foundation. All rights reserved.
+**
+** Not a Contribution, Apache license notifications and license are retained
+** for attribution purposes only.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -24,7 +26,7 @@
     {RIL_REQUEST_ENTER_SIM_PUK2, dispatchStrings, responseInts},
     {RIL_REQUEST_CHANGE_SIM_PIN, dispatchStrings, responseInts},
     {RIL_REQUEST_CHANGE_SIM_PIN2, dispatchStrings, responseInts},
-    {RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE, dispatchStrings, responseInts},
+    {RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE, dispatchDepersonalization, responseInts},
     {RIL_REQUEST_GET_CURRENT_CALLS, dispatchVoid, responseCallList},
     {RIL_REQUEST_DIAL, dispatchDial, responseVoid},
     {RIL_REQUEST_GET_IMSI, dispatchStrings, responseString},
@@ -63,8 +65,8 @@
     {RIL_REQUEST_CHANGE_BARRING_PASSWORD, dispatchStrings, responseVoid},
     {RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, dispatchVoid, responseInts},
     {RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, dispatchVoid, responseVoid},
-    {RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, dispatchString, responseVoid},
-    {RIL_REQUEST_QUERY_AVAILABLE_NETWORKS , dispatchVoid, responseStringsNetworks},
+    {RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, dispatchStrings, responseVoid},
+    {RIL_REQUEST_QUERY_AVAILABLE_NETWORKS , dispatchVoid, responseStrings},
     {RIL_REQUEST_DTMF_START, dispatchString, responseVoid},
     {RIL_REQUEST_DTMF_STOP, dispatchVoid, responseVoid},
     {RIL_REQUEST_BASEBAND_VERSION, dispatchVoid, responseString},
@@ -125,18 +127,38 @@
     {RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, dispatchStrings, responseVoid},
     {RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, dispatchString, responseSIM_IO},
     {RIL_REQUEST_VOICE_RADIO_TECH, dispatchVoiceRadioTech, responseInts},
-#ifndef RIL_NO_CELL_INFO_LIST
-    {RIL_REQUEST_GET_CELL_INFO_LIST, dispatchVoid, responseCellInfoList},
-    {RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, dispatchInts, responseVoid},
-#endif
-    {RIL_REQUEST_SET_INITIAL_ATTACH_APN, dispatchSetInitialAttachApn, responseVoid},
+#ifndef RIL_VARIANT_LEGACY
     {RIL_REQUEST_IMS_REGISTRATION_STATE, dispatchVoid, responseInts},
     {RIL_REQUEST_IMS_SEND_SMS, dispatchImsSms, responseSMS},
     {RIL_REQUEST_GET_DATA_CALL_PROFILE, dispatchInts, responseGetDataCallProfile},
+    {RIL_REQUEST_SETUP_QOS,         dispatchStrings, responseStrings},
+    {RIL_REQUEST_RELEASE_QOS,       dispatchStrings,  responseStrings},
+    {RIL_REQUEST_GET_QOS_STATUS,   dispatchStrings, responseStrings},
+    {RIL_REQUEST_MODIFY_QOS,        dispatchStrings, responseStrings},
+    {RIL_REQUEST_SUSPEND_QOS,       dispatchStrings, responseVoid},
+    {RIL_REQUEST_RESUME_QOS,        dispatchStrings, responseVoid},
     {RIL_REQUEST_SET_UICC_SUBSCRIPTION, dispatchUiccSubscripton, responseVoid},
     {RIL_REQUEST_SET_DATA_SUBSCRIPTION, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_UICC_SUBSCRIPTION, dispatchVoid, responseUiccSubscription},
+    {RIL_REQUEST_GET_DATA_SUBSCRIPTION, dispatchVoid, responseInts},
+    {RIL_REQUEST_SET_SUBSCRIPTION_MODE, dispatchInts, responseVoid},
     {RIL_REQUEST_SIM_TRANSMIT_BASIC, dispatchSIM_IO, responseSIM_IO},
     {RIL_REQUEST_SIM_OPEN_CHANNEL, dispatchString, responseInts},
     {RIL_REQUEST_SIM_CLOSE_CHANNEL, dispatchInts, responseVoid},
     {RIL_REQUEST_SIM_TRANSMIT_CHANNEL, dispatchSIM_IO, responseSIM_IO},
     {RIL_REQUEST_SIM_GET_ATR, dispatchInts, responseString},
+#else
+    {RIL_REQUEST_IMS_REGISTRATION_STATE, dispatchVoid, responseInts, J_RIL_REQUEST_IMS_REGISTRATION_STATE},
+    {RIL_REQUEST_IMS_SEND_SMS, dispatchImsSms, responseSMS, J_RIL_REQUEST_IMS_SEND_SMS},
+    {RIL_REQUEST_GET_DATA_CALL_PROFILE, dispatchInts, responseGetDataCallProfile, J_RIL_REQUEST_GET_DATA_CALL_PROFILE},
+    {RIL_REQUEST_SET_UICC_SUBSCRIPTION, dispatchUiccSubscripton, responseVoid, J_RIL_REQUEST_SET_UICC_SUBSCRIPTION},
+    {RIL_REQUEST_SET_DATA_SUBSCRIPTION, dispatchVoid, responseVoid, J_RIL_REQUEST_SET_DATA_SUBSCRIPTION},
+    {RIL_REQUEST_GET_UICC_SUBSCRIPTION, dispatchVoid, responseUiccSubscription, J_RIL_REQUEST_GET_UICC_SUBSCRIPTION},
+    {RIL_REQUEST_GET_DATA_SUBSCRIPTION, dispatchVoid, responseInts, J_RIL_REQUEST_GET_DATA_SUBSCRIPTION},
+    {RIL_REQUEST_SET_SUBSCRIPTION_MODE, dispatchInts, responseVoid, J_RIL_REQUEST_SET_SUBSCRIPTION_MODE},
+    {RIL_REQUEST_SIM_TRANSMIT_BASIC, dispatchSIM_IO, responseSIM_IO, J_RIL_REQUEST_SIM_TRANSMIT_BASIC},
+    {RIL_REQUEST_SIM_OPEN_CHANNEL, dispatchString, responseInts, J_RIL_REQUEST_SIM_OPEN_CHANNEL},
+    {RIL_REQUEST_SIM_CLOSE_CHANNEL, dispatchInts, responseVoid, J_RIL_REQUEST_SIM_CLOSE_CHANNEL},
+    {RIL_REQUEST_SIM_TRANSMIT_CHANNEL, dispatchSIM_IO, responseSIM_IO, J_RIL_REQUEST_SIM_TRANSMIT_CHANNEL},
+    {RIL_REQUEST_SIM_GET_ATR, dispatchInts, responseString, J_RIL_REQUEST_SIM_GET_ATR},
+#endif
diff --git a/libril/ril_event.cpp b/libril/ril_event.cpp
index 9d2954e..39aeea2 100644
--- a/libril/ril_event.cpp
+++ b/libril/ril_event.cpp
@@ -34,6 +34,8 @@ static pthread_mutex_t listMutex;
 #define MUTEX_INIT() pthread_mutex_init(&listMutex, NULL)
 #define MUTEX_DESTROY() pthread_mutex_destroy(&listMutex)
 
+#include <telephony/ril_log.h>
+
 #ifndef timeradd
 #define timeradd(tvp, uvp, vvp)						\
 	do {								\
@@ -75,7 +77,7 @@ static struct ril_event pending_list;
 #define DEBUG 0
 
 #if DEBUG
-#define dlog(x...) RLOGD( x )
+#define dlog(x...) ALOGD( x )
 static void dump_event(struct ril_event * ev)
 {
     dlog("~~~~ Event %x ~~~~", (unsigned int)ev);
@@ -351,6 +353,7 @@ void ril_event_loop()
     struct timeval * ptv;
 
 
+    ALOGE("in ril_event_loop");
     for (;;) {
 
         // make local copy of read fd_set
@@ -370,7 +373,7 @@ void ril_event_loop()
         if (n < 0) {
             if (errno == EINTR) continue;
 
-            RLOGE("ril_event: select error (%d)", errno);
+            ALOGE("ril_event: select error (%d)", errno);
             // bail?
             return;
         }
diff --git a/libril/ril_unsol_commands.h b/libril/ril_unsol_commands.h
index 99fa4f1..c7d6b7e 100755
--- a/libril/ril_unsol_commands.h
+++ b/libril/ril_unsol_commands.h
@@ -1,8 +1,10 @@
 /* //device/libs/telephony/ril_unsol_commands.h
 **
-** Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
-** Not a Contribution
 ** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2012, The Linux Foundation. All rights reserved.
+**
+** Not a Contribution, Apache license notifications and license are retained
+** for attribution purposes only.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -51,11 +53,18 @@
     {RIL_UNSOL_CDMA_PRL_CHANGED, responseInts, WAKE_PARTIAL},
     {RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE, responseVoid, WAKE_PARTIAL},
     {RIL_UNSOL_RIL_CONNECTED, responseInts, WAKE_PARTIAL},
+#ifndef RIL_VARIANT_LEGACY
     {RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, responseInts, WAKE_PARTIAL},
-#ifndef RIL_NO_CELL_INFO_LIST
-    {RIL_UNSOL_CELL_INFO_LIST, responseCellInfoList, WAKE_PARTIAL},
-#endif
     {RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_QOS_STATE_CHANGED_IND,   responseStrings, WAKE_PARTIAL},
     {RIL_UNSOL_ON_SS, responseSSData, WAKE_PARTIAL},
     {RIL_UNSOL_STK_CC_ALPHA_NOTIFY, responseString, WAKE_PARTIAL},
-    {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, responseInts, WAKE_PARTIAL}
+    {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, responseInts, WAKE_PARTIAL},
+#else
+    {RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, responseInts, WAKE_PARTIAL, J_RIL_UNSOL_VOICE_RADIO_TECH_CHANGED},
+    {RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED, responseVoid, WAKE_PARTIAL, J_RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED},
+    {RIL_UNSOL_ON_SS, responseSSData, WAKE_PARTIAL, J_RIL_UNSOL_ON_SS},
+    {RIL_UNSOL_STK_CC_ALPHA_NOTIFY, responseString, WAKE_PARTIAL, J_RIL_UNSOL_STK_CC_ALPHA_NOTIFY},
+    {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, responseInts, WAKE_PARTIAL, J_RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED},
+#endif
diff --git a/libril/rilj.h b/libril/rilj.h
new file mode 100644
index 0000000..4ab83c8
--- /dev/null
+++ b/libril/rilj.h
@@ -0,0 +1,32 @@
+
+#define J_RIL_REQUEST_GET_CELL_INFO_LIST                  109
+#define J_RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE       110
+#define J_RIL_REQUEST_SET_INITIAL_ATTACH_APN              111
+
+#define J_RIL_REQUEST_IMS_REGISTRATION_STATE              112
+#define J_RIL_REQUEST_IMS_SEND_SMS                        113
+#define J_RIL_REQUEST_GET_DATA_CALL_PROFILE               114
+
+#define J_RIL_REQUEST_SET_UICC_SUBSCRIPTION               115
+#define J_RIL_REQUEST_SET_DATA_SUBSCRIPTION               116
+#define J_RIL_REQUEST_GET_UICC_SUBSCRIPTION             10120
+#define J_RIL_REQUEST_GET_DATA_SUBSCRIPTION             10121
+#define J_RIL_REQUEST_SET_SUBSCRIPTION_MODE             10122
+
+#define J_RIL_REQUEST_SIM_TRANSMIT_BASIC                  117
+#define J_RIL_REQUEST_SIM_OPEN_CHANNEL                    118
+#define J_RIL_REQUEST_SIM_CLOSE_CHANNEL                   119
+#define J_RIL_REQUEST_SIM_TRANSMIT_CHANNEL                120
+#define J_RIL_REQUEST_SIM_GET_ATR                         121
+
+#define J_RIL_REQUEST_MAX                                 121
+
+
+#define J_RIL_UNSOL_VOICE_RADIO_TECH_CHANGED              1035
+#define J_RIL_UNSOL_CELL_INFO_LIST                        1036
+#define J_RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED    1037
+#define J_RIL_UNSOL_ON_SS                                 1038
+#define J_RIL_UNSOL_STK_CC_ALPHA_NOTIFY                   1039
+#define J_RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED      1040
+
+#define J_RIL_UNSOL_MAX                                   1040
diff --git a/librilutils/Android.mk b/librilutils/Android.mk
deleted file mode 100644
index a50e374..0000000
--- a/librilutils/Android.mk
+++ /dev/null
@@ -1,35 +0,0 @@
-# Copyright 2013 The Android Open Source Project
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-    librilutils.c \
-    record_stream.c
-
-LOCAL_CFLAGS :=
-
-LOCAL_MODULE:= librilutils
-
-LOCAL_LDLIBS += -lpthread
-
-include $(BUILD_SHARED_LIBRARY)
-
-
-# Create static library for those that want it
-# =========================================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-    librilutils.c \
-    record_stream.c
-
-LOCAL_STATIC_LIBRARIES :=
-
-LOCAL_CFLAGS :=
-
-LOCAL_MODULE:= librilutils_static
-
-LOCAL_LDLIBS += -lpthread
-
-include $(BUILD_STATIC_LIBRARY)
diff --git a/librilutils/librilutils.c b/librilutils/librilutils.c
deleted file mode 100644
index b1b930e..0000000
--- a/librilutils/librilutils.c
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <telephony/librilutils.h>
-#include <time.h>
-
-uint64_t ril_nano_time() {
-    struct timespec now;
-    clock_gettime(CLOCK_MONOTONIC, &now);
-    return now.tv_sec * 1000000000LL + now.tv_nsec;
-}
diff --git a/librilutils/record_stream.c b/librilutils/record_stream.c
deleted file mode 100644
index 558d179..0000000
--- a/librilutils/record_stream.c
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <assert.h>
-#include <errno.h>
-#include <telephony/record_stream.h>
-#include <string.h>
-#include <stdint.h>
-#ifdef HAVE_WINSOCK
-#include <winsock2.h>   /* for ntohl */
-#else
-#include <netinet/in.h>
-#endif
-
-#define HEADER_SIZE 4
-
-struct RecordStream {
-    int fd;
-    size_t maxRecordLen;
-
-    unsigned char *buffer;
-
-    unsigned char *unconsumed;
-    unsigned char *read_end;
-    unsigned char *buffer_end;
-};
-
-
-extern RecordStream *record_stream_new(int fd, size_t maxRecordLen)
-{
-    RecordStream *ret;
-
-    assert (maxRecordLen <= 0xffff);
-
-    ret = (RecordStream *)calloc(1, sizeof(RecordStream));
-
-    ret->fd = fd;
-    ret->maxRecordLen = maxRecordLen;
-    ret->buffer = (unsigned char *)malloc (maxRecordLen + HEADER_SIZE);
-
-    ret->unconsumed = ret->buffer;
-    ret->read_end = ret->buffer;
-    ret->buffer_end = ret->buffer + maxRecordLen + HEADER_SIZE;
-
-    return ret;
-}
-
-
-extern void record_stream_free(RecordStream *rs)
-{
-    free(rs->buffer);
-    free(rs);
-}
-
-
-/* returns NULL; if there isn't a full record in the buffer */
-static unsigned char * getEndOfRecord (unsigned char *p_begin,
-                                            unsigned char *p_end)
-{
-    size_t len;
-    unsigned char * p_ret;
-
-    if (p_end < p_begin + HEADER_SIZE) {
-        return NULL;
-    }
-
-    //First four bytes are length
-    len = ntohl(*((uint32_t *)p_begin));
-
-    p_ret = p_begin + HEADER_SIZE + len;
-
-    if (p_end < p_ret) {
-        return NULL;
-    }
-
-    return p_ret;
-}
-
-static void *getNextRecord (RecordStream *p_rs, size_t *p_outRecordLen)
-{
-    unsigned char *record_start, *record_end;
-
-    record_end = getEndOfRecord (p_rs->unconsumed, p_rs->read_end);
-
-    if (record_end != NULL) {
-        /* one full line in the buffer */
-        record_start = p_rs->unconsumed + HEADER_SIZE;
-        p_rs->unconsumed = record_end;
-
-        *p_outRecordLen = record_end - record_start;
-
-        return record_start;
-    }
-
-    return NULL;
-}
-
-/**
- * Reads the next record from stream fd
- * Records are prefixed by a 16-bit big endian length value
- * Records may not be larger than maxRecordLen
- *
- * Doesn't guard against EINTR
- *
- * p_outRecord and p_outRecordLen may not be NULL
- *
- * Return 0 on success, -1 on fail
- * Returns 0 with *p_outRecord set to NULL on end of stream
- * Returns -1 / errno = EAGAIN if it needs to read again
- */
-int record_stream_get_next (RecordStream *p_rs, void ** p_outRecord,
-                                    size_t *p_outRecordLen)
-{
-    void *ret;
-
-    ssize_t countRead;
-
-    /* is there one record already in the buffer? */
-    ret = getNextRecord (p_rs, p_outRecordLen);
-
-    if (ret != NULL) {
-        *p_outRecord = ret;
-        return 0;
-    }
-
-    // if the buffer is full and we don't have a full record
-    if (p_rs->unconsumed == p_rs->buffer
-        && p_rs->read_end == p_rs->buffer_end
-    ) {
-        // this should never happen
-        //ALOGE("max record length exceeded\n");
-        assert (0);
-        errno = EFBIG;
-        return -1;
-    }
-
-    if (p_rs->unconsumed != p_rs->buffer) {
-        // move remainder to the beginning of the buffer
-        size_t toMove;
-
-        toMove = p_rs->read_end - p_rs->unconsumed;
-        if (toMove) {
-            memmove(p_rs->buffer, p_rs->unconsumed, toMove);
-        }
-
-        p_rs->read_end = p_rs->buffer + toMove;
-        p_rs->unconsumed = p_rs->buffer;
-    }
-
-    countRead = read (p_rs->fd, p_rs->read_end, p_rs->buffer_end - p_rs->read_end);
-
-    if (countRead <= 0) {
-        /* note: end-of-stream drops through here too */
-        *p_outRecord = NULL;
-        return countRead;
-    }
-
-    p_rs->read_end += countRead;
-
-    ret = getNextRecord (p_rs, p_outRecordLen);
-
-    if (ret == NULL) {
-        /* not enough of a buffer to for a whole command */
-        errno = EAGAIN;
-        return -1;
-    }
-
-    *p_outRecord = ret;
-    return 0;
-}
diff --git a/reference-ril/Android.mk b/reference-ril/Android.mk
index 167078a..a011460 100644
--- a/reference-ril/Android.mk
+++ b/reference-ril/Android.mk
@@ -12,20 +12,15 @@ LOCAL_SRC_FILES:= \
     at_tok.c
 
 LOCAL_SHARED_LIBRARIES := \
-    liblog libcutils libutils libril librilutils
+    libcutils libutils libril
 
 # for asprinf
 LOCAL_CFLAGS := -D_GNU_SOURCE
 
 LOCAL_C_INCLUDES := $(KERNEL_HEADERS)
 
-#USE HCRADIO
-ifeq ($(BOARD_USES_HC_RADIO),true) 
-LOCAL_CFLAGS += -DHCRADIO
-endif
-
 ifeq ($(TARGET_DEVICE),sooner)
-  LOCAL_CFLAGS += -DOMAP_CSMI_POWER_CONTROL -DUSE_TI_COMMANDS
+  LOCAL_CFLAGS += -DUSE_TI_COMMANDS
 endif
 
 ifeq ($(TARGET_DEVICE),surf)
diff --git a/reference-ril/atchannel.c b/reference-ril/atchannel.c
index ee13f19..22b3990 100644
--- a/reference-ril/atchannel.c
+++ b/reference-ril/atchannel.c
@@ -33,13 +33,10 @@
 #define LOG_TAG "AT"
 #include <utils/Log.h>
 
-#ifdef HAVE_ANDROID_OS
-/* for IOCTL's */
-#include <linux/omap_csmi.h>
-#endif /*HAVE_ANDROID_OS*/
-
 #include "misc.h"
 
+#include <telephony/ril_log.h>
+
 #ifdef HAVE_ANDROID_OS
 #define USE_NP 1
 #endif /* HAVE_ANDROID_OS */
@@ -60,16 +57,12 @@ static ATUnsolHandler s_unsolHandler;
 static char s_ATBuffer[MAX_AT_RESPONSE+1];
 static char *s_ATBufferCur = s_ATBuffer;
 
-static int s_ackPowerIoctl; /* true if TTY has android byte-count
-                                handshake for low power*/
-static int s_readCount = 0;
-
 #if AT_DEBUG
 void  AT_DUMP(const char*  prefix, const char*  buff, int  len)
 {
     if (len < 0)
         len = strlen(buff);
-    RLOGD("%.*s", len, buff);
+    ALOGD("%.*s", len, buff);
 }
 #endif
 
@@ -290,7 +283,7 @@ static void processLine(const char *line)
         break;
 
         default: /* this should never be reached */
-            RLOGE("Unsupported AT command type %d\n", s_type);
+            ALOGE("Unsupported AT command type %d\n", s_type);
             handleUnsolicited(line);
         break;
     }
@@ -371,7 +364,7 @@ static const char *readline()
 
     while (p_eol == NULL) {
         if (0 == MAX_AT_RESPONSE - (p_read - s_ATBuffer)) {
-            RLOGE("ERROR: Input line exceeded buffer\n");
+            ALOGE("ERROR: Input line exceeded buffer\n");
             /* ditch buffer and start over again */
             s_ATBufferCur = s_ATBuffer;
             *s_ATBufferCur = '\0';
@@ -385,7 +378,6 @@ static const char *readline()
 
         if (count > 0) {
             AT_DUMP( "<< ", p_read, count );
-            s_readCount += count;
 
             p_read[count] = '\0';
 
@@ -398,9 +390,9 @@ static const char *readline()
         } else if (count <= 0) {
             /* read error encountered or EOF reached */
             if(count == 0) {
-                RLOGD("atchannel: EOF reached");
+                ALOGD("atchannel: EOF reached");
             } else {
-                RLOGD("atchannel: read error %s", strerror(errno));
+                ALOGD("atchannel: read error %s", strerror(errno));
             }
             return NULL;
         }
@@ -413,7 +405,7 @@ static const char *readline()
     s_ATBufferCur = p_eol + 1; /* this will always be <= p_read,    */
                               /* and there will be a \0 at *p_read */
 
-    RLOGD("AT< %s\n", ret);
+    ALOGD("AT< %s\n", ret);
     return ret;
 }
 
@@ -467,14 +459,6 @@ static void *readerLoop(void *arg)
         } else {
             processLine(line);
         }
-
-#ifdef HAVE_ANDROID_OS
-        if (s_ackPowerIoctl > 0) {
-            /* acknowledge that bytes have been read and processed */
-            ioctl(s_fd, OMAP_CSMI_TTY_ACK, &s_readCount);
-            s_readCount = 0;
-        }
-#endif /*HAVE_ANDROID_OS*/
     }
 
     onReaderClosed();
@@ -499,7 +483,7 @@ static int writeline (const char *s)
         return AT_ERROR_CHANNEL_CLOSED;
     }
 
-    RLOGD("AT> %s\n", s);
+    ALOGD("AT> %s\n", s);
 
     AT_DUMP( ">> ", s, strlen(s) );
 
@@ -538,7 +522,7 @@ static int writeCtrlZ (const char *s)
         return AT_ERROR_CHANNEL_CLOSED;
     }
 
-    RLOGD("AT> %s^Z\n", s);
+    ALOGD("AT> %s^Z\n", s);
 
     AT_DUMP( ">* ", s, strlen(s) );
 
@@ -598,40 +582,6 @@ int at_open(int fd, ATUnsolHandler h)
     s_smsPDU = NULL;
     sp_response = NULL;
 
-    /* Android power control ioctl */
-#ifdef HAVE_ANDROID_OS
-#ifdef OMAP_CSMI_POWER_CONTROL
-    ret = ioctl(fd, OMAP_CSMI_TTY_ENABLE_ACK);
-    if(ret == 0) {
-        int ack_count;
-		int read_count;
-        int old_flags;
-        char sync_buf[256];
-        old_flags = fcntl(fd, F_GETFL, 0);
-        fcntl(fd, F_SETFL, old_flags | O_NONBLOCK);
-        do {
-            ioctl(fd, OMAP_CSMI_TTY_READ_UNACKED, &ack_count);
-			read_count = 0;
-            do {
-                ret = read(fd, sync_buf, sizeof(sync_buf));
-				if(ret > 0)
-					read_count += ret;
-            } while(ret > 0 || (ret < 0 && errno == EINTR));
-            ioctl(fd, OMAP_CSMI_TTY_ACK, &ack_count);
-         } while(ack_count > 0 || read_count > 0);
-        fcntl(fd, F_SETFL, old_flags);
-        s_readCount = 0;
-        s_ackPowerIoctl = 1;
-    }
-    else
-        s_ackPowerIoctl = 0;
-
-#else // OMAP_CSMI_POWER_CONTROL
-    s_ackPowerIoctl = 0;
-
-#endif // OMAP_CSMI_POWER_CONTROL
-#endif /*HAVE_ANDROID_OS*/
-
     pthread_attr_init (&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
diff --git a/reference-ril/msimreference-ril.c b/reference-ril/msimreference-ril.c
new file mode 100644
index 0000000..c9c04c4
--- /dev/null
+++ b/reference-ril/msimreference-ril.c
@@ -0,0 +1,2774 @@
+/* //device/system/reference-ril/reference-ril.c
+**
+** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+** Not a Contribution, Apache license notifications and license are retained
+** for attribution purposes only.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <telephony/ril.h>
+#include <telephony/ril_cdma_sms.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+#include "atchannel.h"
+#include "at_tok.h"
+#include "misc.h"
+#include <getopt.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <cutils/properties.h>
+#include <termios.h>
+#include <sys/system_properties.h>
+
+#include "ril.h"
+#include "hardware/qemu_pipe.h"
+
+#define LOG_TAG "RIL"
+#define LOG_NDEBUG 0
+#define LOG_NDDEBUG 0
+#define LOG_NIDEBUG 0
+#include <utils/Log.h>
+
+#include <telephony/ril_log.h>
+
+#define MAX_AT_RESPONSE 0x1000
+#define DSDS_PROPERTY        "dsds"
+#define DSDS_PROPERTY_LENGTH 4
+#define DSDA_PROPERTY        "dsda"
+#define DSDA_PROPERTY_LENGTH 4
+
+/* pathname returned from RIL_REQUEST_SETUP_DATA_CALL / RIL_REQUEST_SETUP_DEFAULT_PDP */
+#define PPP_TTY_PATH "eth0"
+
+#ifdef USE_TI_COMMANDS
+
+// Enable a workaround
+// 1) Make incoming call, do not answer
+// 2) Hangup remote end
+// Expected: call should disappear from CLCC line
+// Actual: Call shows as "ACTIVE" before disappearing
+#define WORKAROUND_ERRONEOUS_ANSWER 1
+
+// Some varients of the TI stack do not support the +CGEV unsolicited
+// response. However, they seem to send an unsolicited +CME ERROR: 150
+#define WORKAROUND_FAKE_CGEV 1
+#endif
+
+typedef enum {
+    SIM_ABSENT = 0,
+    SIM_NOT_READY = 1,
+    SIM_READY = 2, /* SIM_READY means the radio state is RADIO_STATE_SIM_READY */
+    SIM_PIN = 3,
+    SIM_PUK = 4,
+    SIM_NETWORK_PERSONALIZATION = 5,
+    RUIM_ABSENT = 6,
+    RUIM_NOT_READY = 7,
+    RUIM_READY = 8,
+    RUIM_PIN = 9,
+    RUIM_PUK = 10,
+    RUIM_NETWORK_PERSONALIZATION = 11
+} SIM_Status;
+
+/* Reference RIL Instance IDs */
+enum {
+    REF_RIL_FIRST_INSTANCE_ID = 0,
+    REF_RIL_SECOND_INSTANCE_ID = 1,
+    REF_RIL_MAX_INSTANCE_ID
+};
+
+/* Callback functions for instance 0 */
+static void onRequest_func0 (int request, void *data, size_t datalen, RIL_Token t);
+static RIL_RadioState currentState_func0();
+static int onSupports_func0 (int requestCode);
+static void onCancel_func0 (RIL_Token t);
+static const char *getVersion_func0();
+
+/* Callback functions for instance 1 */
+static void onRequest_func1 (int request, void *data, size_t datalen, RIL_Token t);
+static RIL_RadioState currentState_func1();
+static int onSupports_func1 (int requestCode);
+static void onCancel_func1 (RIL_Token t);
+static const char *getVersion_func1();
+
+static int isRadioOn();
+static SIM_Status getSIMStatus(int inst_id);
+static int getCardStatus(int inst_id, RIL_CardStatus_v6 **pp_card_status);
+static void freeCardStatus(RIL_CardStatus_v6 *p_card_status);
+static void onDataCallListChanged(void *param);
+
+extern const char * requestToString(int request);
+
+static int isMultiSimEnabled();
+
+/*** Static Variables ***/
+static const RIL_RadioFunctions s_callbacks [REF_RIL_MAX_INSTANCE_ID] = {
+{
+    RIL_VERSION,
+    onRequest_func0,
+    currentState_func0,
+    onSupports_func0,
+    onCancel_func0,
+    getVersion_func0
+},
+{
+    RIL_VERSION,
+    onRequest_func1,
+    currentState_func1,
+    onSupports_func1,
+    onCancel_func1,
+    getVersion_func1
+}
+};
+
+int line_sms = 0;
+int mo_call = 0;
+int mt_ring_counter = 0;
+
+#ifdef RIL_SHLIB
+static const struct RIL_Env *s_rilenv[REF_RIL_MAX_INSTANCE_ID];
+
+#define RIL_onRequestComplete(inst, t, e, response, responselen) do { \
+    if(!isMultiSimEnabled() && inst != REF_RIL_FIRST_INSTANCE_ID) {\
+        ALOGD(" RIL_onRequestComplete: Error: dsds not enabled and inst != REF_RIL_FIRST_INSTANCE_ID"); \
+        break; \
+    } \
+    ALOGD(" RIL_onRequestComplete: inst = %d", inst); \
+    s_rilenv[inst]->OnRequestComplete(t,e, response, responselen); \
+} while (0)
+
+#define RIL_onUnsolicitedResponse(inst, a,b,c) do { \
+    if(!isMultiSimEnabled() && inst != REF_RIL_FIRST_INSTANCE_ID) {\
+        ALOGD(" RIL_onUnsolicitedResponse: Error: dsds not enabled and inst != REF_RIL_FIRST_INSTANCE_ID"); \
+        break; \
+    } \
+    ALOGD(" RIL_onUnsolicitedResponse: inst = %d", inst); \
+    s_rilenv[inst]->OnUnsolicitedResponse(a,b,c); \
+} while (0)
+
+#define RIL_requestTimedCallback(inst, a,b,c) do { \
+    if(!isMultiSimEnabled() && inst != REF_RIL_FIRST_INSTANCE_ID) {\
+        ALOGD(" RIL_requestTimedCallback: Error: dsds not enabled and inst != REF_RIL_FIRST_INSTANCE_ID"); \
+        break; \
+    } \
+    ALOGD(" RIL_requestTimedCallback: inst = %d", inst); \
+    s_rilenv[inst]->RequestTimedCallback(a,b,c); \
+} while (0)
+
+#endif
+
+static RIL_RadioState sState[REF_RIL_MAX_INSTANCE_ID] = {RADIO_STATE_UNAVAILABLE, RADIO_STATE_UNAVAILABLE};
+
+static pthread_mutex_t s_state_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t s_state_cond = PTHREAD_COND_INITIALIZER;
+
+static int s_port = -1;
+static const char * s_device_path = NULL;
+static int          s_device_socket = 0;
+
+/* trigger change to this with s_state_cond */
+static int s_closed = 0;
+
+static int sFD;     /* file desc of AT channel */
+static char sATBuffer[MAX_AT_RESPONSE+1];
+static char *sATBufferCur = NULL;
+
+static const struct timeval TIMEVAL_SIMPOLL = {1,0};
+static const struct timeval TIMEVAL_CALLSTATEPOLL = {0,500000};
+static const struct timeval TIMEVAL_0 = {0,0};
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+// Max number of times we'll try to repoll when we think
+// we have a AT+CLCC race condition
+#define REPOLL_CALLS_COUNT_MAX 4
+
+// Line index that was incoming or waiting at last poll, or -1 for none
+static int s_incomingOrWaitingLine = -1;
+// Number of times we've asked for a repoll of AT+CLCC
+static int s_repollCallsCount = 0;
+// Should we expect a call to be answered in the next CLCC?
+static int s_expectAnswer = 0;
+#endif /* WORKAROUND_ERRONEOUS_ANSWER */
+
+static void pollSIMState (void *param);
+//Need to check all below 5 functions
+static void setRadioState (int inst_id, RIL_RadioState newState);
+//static void setRadioTechnology(int inst_id, ModemInfo *mdm, int newtech);
+//static int techFamilyFromModemType(int mdmtype);
+
+/*jiju*/
+static int mySimState[2] = {SIM_READY, SIM_READY};
+static int myDds = -1;
+
+static int clccStateToRILState(int state, RIL_CallState *p_state)
+
+{
+    switch(state) {
+        case 0: *p_state = RIL_CALL_ACTIVE;   return 0;
+        case 1: *p_state = RIL_CALL_HOLDING;  return 0;
+        case 2: *p_state = RIL_CALL_DIALING;  return 0;
+        case 3: *p_state = RIL_CALL_ALERTING; return 0;
+        case 4: *p_state = RIL_CALL_INCOMING; return 0;
+        case 5: *p_state = RIL_CALL_WAITING;  return 0;
+        default: return -1;
+    }
+}
+
+/**
+ * Note: directly modified line and has *p_call point directly into
+ * modified line
+ */
+static int callFromCLCCLine(char *line, RIL_Call *p_call)
+{
+        //+CLCC: 1,0,2,0,0,\"+18005551212\",145
+        //     index,isMT,state,mode,isMpty(,number,TOA)?
+
+    int err;
+    int state;
+    int mode;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(p_call->index));
+    if (err < 0) goto error;
+
+    err = at_tok_nextbool(&line, &(p_call->isMT));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &state);
+    if (err < 0) goto error;
+
+    err = clccStateToRILState(state, &(p_call->state));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &mode);
+    if (err < 0) goto error;
+
+    p_call->isVoice = (mode == 0);
+
+    err = at_tok_nextbool(&line, &(p_call->isMpty));
+    if (err < 0) goto error;
+
+    if (at_tok_hasmore(&line)) {
+        err = at_tok_nextstr(&line, &(p_call->number));
+
+        /* tolerate null here */
+        if (err < 0) return 0;
+
+        // Some lame implementations return strings
+        // like "NOT AVAILABLE" in the CLCC line
+        if (p_call->number != NULL
+            && 0 == strspn(p_call->number, "+0123456789")
+        ) {
+            p_call->number = NULL;
+        }
+
+        err = at_tok_nextint(&line, &p_call->toa);
+        if (err < 0) goto error;
+    }
+
+    p_call->uusInfo = NULL;
+
+    return 0;
+
+error:
+    ALOGE("invalid CLCC line\n");
+    return -1;
+}
+
+
+/** do post-AT+CFUN=1 initialization */
+static void onRadioPowerOn(int inst_id)
+{
+    ALOGD("onRadioPowerOn(%d)", inst_id);
+#ifdef USE_TI_COMMANDS
+    /*  Must be after CFUN=1 */
+    /*  TI specific -- notifications for CPHS things such */
+    /*  as CPHS message waiting indicator */
+
+    at_send_command("AT%CPHS=1", NULL);
+
+    /*  TI specific -- enable NITZ unsol notifs */
+    at_send_command("AT%CTZV=1", NULL);
+#endif
+
+    pollSIMState((void *)inst_id);
+}
+
+/** do post- SIM ready initialization */
+static void onSIMReady()
+{
+    at_send_command_singleline("AT+CSMS=1", "+CSMS:", NULL);
+    /*
+     * Always send SMS messages directly to the TE
+     *
+     * mode = 1 // discard when link is reserved (link should never be
+     *             reserved)
+     * mt = 2   // most messages routed to TE
+     * bm = 2   // new cell BM's routed to TE
+     * ds = 1   // Status reports routed to TE
+     * bfr = 1  // flush buffer
+     */
+    at_send_command("AT+CNMI=1,2,2,1,1", NULL);
+}
+
+static void requestRadioPower(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    int onOff;
+
+    int err;
+    ATResponse *p_response = NULL;
+
+    assert (datalen >= sizeof(int *));
+    onOff = ((int *)data)[0];
+
+    ALOGD("onOff: %d, sState: %d\n", onOff, sState[inst_id]);
+    if (onOff == 0 && sState[inst_id] != RADIO_STATE_OFF) {
+        err = at_send_command("AT+CFUN=0", &p_response);
+       if (err < 0 || p_response->success == 0) goto error;
+        setRadioState (inst_id, RADIO_STATE_OFF);
+    } else if (onOff > 0 && sState[inst_id] == RADIO_STATE_OFF) {
+        err = at_send_command("AT+CFUN=1", &p_response);
+        if (err < 0|| p_response->success == 0) {
+            // Some stacks return an error when there is no SIM,
+            // but they really turn the RF portion on
+            // So, if we get an error, let's check to see if it
+            // turned on anyway
+
+            if (isRadioOn() != 1) {
+                goto error;
+            }
+        }
+        setRadioState (inst_id, RADIO_STATE_ON);
+    }
+
+    at_response_free(p_response);
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+static void requestOrSendDataCallList(int inst_id, RIL_Token *t);
+
+static void onDataCallListChanged(void *param)
+{
+    int inst_id = (int)param;
+    requestOrSendDataCallList(inst_id, NULL);
+}
+
+static void requestDataCallList(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    requestOrSendDataCallList(inst_id, &t);
+}
+
+static void requestOrSendDataCallList(int inst_id, RIL_Token *t)
+{
+    ATResponse *p_response;
+    ATLine *p_cur;
+    int err;
+    int n = 0;
+    char *out;
+
+    err = at_send_command_multiline ("AT+CGACT?", "+CGACT:", &p_response);
+    if (err != 0 || p_response->success == 0) {
+        if (t != NULL)
+            RIL_onRequestComplete(inst_id, *t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        else
+            RIL_onUnsolicitedResponse(inst_id, RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                                      NULL, 0);
+        return;
+    }
+
+    for (p_cur = p_response->p_intermediates; p_cur != NULL;
+         p_cur = p_cur->p_next)
+        n++;
+
+    RIL_Data_Call_Response_v6 *responses =
+        alloca(n * sizeof(RIL_Data_Call_Response_v6));
+
+    int i;
+    for (i = 0; i < n; i++) {
+        responses[i].status = -1;
+        responses[i].suggestedRetryTime = -1;
+        responses[i].cid = -1;
+        responses[i].active = -1;
+        responses[i].type = "";
+        responses[i].ifname = "";
+        responses[i].addresses = "";
+        responses[i].dnses = "";
+        responses[i].gateways = "";
+    }
+
+    RIL_Data_Call_Response_v6 *response = responses;
+    for (p_cur = p_response->p_intermediates; p_cur != NULL;
+         p_cur = p_cur->p_next) {
+        char *line = p_cur->line;
+
+        err = at_tok_start(&line);
+        if (err < 0)
+            goto error;
+
+        err = at_tok_nextint(&line, &response->cid);
+        if (err < 0)
+            goto error;
+
+        err = at_tok_nextint(&line, &response->active);
+        if (err < 0)
+            goto error;
+
+        response++;
+    }
+
+    at_response_free(p_response);
+
+    err = at_send_command_multiline ("AT+CGDCONT?", "+CGDCONT:", &p_response);
+    if (err != 0 || p_response->success == 0) {
+        if (t != NULL)
+            RIL_onRequestComplete(inst_id, *t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        else
+            RIL_onUnsolicitedResponse(inst_id, RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                                      NULL, 0);
+        return;
+    }
+
+    for (p_cur = p_response->p_intermediates; p_cur != NULL;
+         p_cur = p_cur->p_next) {
+        char *line = p_cur->line;
+        int cid;
+
+        err = at_tok_start(&line);
+        if (err < 0)
+            goto error;
+
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0)
+            goto error;
+
+        for (i = 0; i < n; i++) {
+            if (responses[i].cid == cid)
+                break;
+        }
+
+        if (i >= n) {
+            /* details for a context we didn't hear about in the last request */
+            continue;
+        }
+
+        // Assume no error
+        responses[i].status = 0;
+
+        // type
+        err = at_tok_nextstr(&line, &out);
+        if (err < 0)
+            goto error;
+        responses[i].type = alloca(strlen(out) + 1);
+        strcpy(responses[i].type, out);
+
+        // APN ignored for v5
+        err = at_tok_nextstr(&line, &out);
+        if (err < 0)
+            goto error;
+
+        responses[i].ifname = alloca(strlen(PPP_TTY_PATH) + 1);
+        strcpy(responses[i].ifname, PPP_TTY_PATH);
+
+        err = at_tok_nextstr(&line, &out);
+        if (err < 0)
+            goto error;
+
+        responses[i].addresses = alloca(strlen(out) + 1);
+        strcpy(responses[i].addresses, out);
+
+        {
+            char  propValue[PROP_VALUE_MAX];
+
+            if (__system_property_get("ro.kernel.qemu", propValue) != 0) {
+                /* We are in the emulator - the dns servers are listed
+                 * by the following system properties, setup in
+                 * /system/etc/init.goldfish.sh:
+                 *  - net.eth0.dns1
+                 *  - net.eth0.dns2
+                 *  - net.eth0.dns3
+                 *  - net.eth0.dns4
+                 */
+                const int   dnslist_sz = 128;
+                char*       dnslist = alloca(dnslist_sz);
+                const char* separator = "";
+                int         nn;
+
+                dnslist[0] = 0;
+                for (nn = 1; nn <= 4; nn++) {
+                    /* Probe net.eth0.dns<n> */
+                    char  propName[PROP_NAME_MAX];
+                    snprintf(propName, sizeof propName, "net.eth0.dns%d", nn);
+
+                    /* Ignore if undefined */
+                    if (__system_property_get(propName, propValue) == 0) {
+                        continue;
+                    }
+
+                    /* Append the DNS IP address */
+                    strlcat(dnslist, separator, dnslist_sz);
+                    strlcat(dnslist, propValue, dnslist_sz);
+                    separator = " ";
+                }
+                responses[i].dnses = dnslist;
+
+                /* There is only on gateway in the emulator */
+                responses[i].gateways = "10.0.2.2";
+            }
+            else {
+                /* I don't know where we are, so use the public Google DNS
+                 * servers by default and no gateway.
+                 */
+                responses[i].dnses = "8.8.8.8 8.8.4.4";
+                responses[i].gateways = "";
+            }
+        }
+    }
+
+    at_response_free(p_response);
+
+    if (t != NULL)
+        RIL_onRequestComplete(inst_id, *t, RIL_E_SUCCESS, responses,
+                              n * sizeof(RIL_Data_Call_Response_v6));
+    else
+        RIL_onUnsolicitedResponse(inst_id, RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                                  responses,
+                                  n * sizeof(RIL_Data_Call_Response_v6));
+
+    return;
+
+error:
+    if (t != NULL)
+        RIL_onRequestComplete(inst_id, *t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    else
+        RIL_onUnsolicitedResponse(inst_id, RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                                  NULL, 0);
+
+    at_response_free(p_response);
+}
+
+static void requestQueryNetworkSelectionMode(
+                int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    int err;
+    ATResponse *p_response = NULL;
+    int response = 0;
+    char *line;
+
+    err = at_send_command_singleline("AT+COPS?", "+COPS:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+
+    if (err < 0) {
+        goto error;
+    }
+
+    err = at_tok_nextint(&line, &response);
+
+    if (err < 0) {
+        goto error;
+    }
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, &response, sizeof(int));
+    at_response_free(p_response);
+    return;
+error:
+    at_response_free(p_response);
+    ALOGE("requestQueryNetworkSelectionMode must never return error when radio is on");
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+static void sendCallStateChanged(void *param)
+{
+    int inst_id = (int)param;
+
+    ALOGD("sendCallStateChanged () : inst_id = %d", inst_id);
+
+    RIL_onUnsolicitedResponse (
+        inst_id,
+        RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED,
+        NULL, 0);
+}
+
+static void requestGetCurrentCalls(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    int err;
+    ATResponse *p_response;
+    ATLine *p_cur;
+    int countCalls;
+    int countValidCalls;
+    RIL_Call *p_calls;
+    RIL_Call **pp_calls;
+    int i;
+    int needRepoll = 0;
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+    int prevIncomingOrWaitingLine;
+
+    prevIncomingOrWaitingLine = s_incomingOrWaitingLine;
+    s_incomingOrWaitingLine = -1;
+#endif /*WORKAROUND_ERRONEOUS_ANSWER*/
+
+    err = at_send_command_multiline ("AT+CLCC", "+CLCC:", &p_response);
+
+    if (err != 0 || p_response->success == 0) {
+        RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        return;
+    }
+
+    /* count the calls */
+    for (countCalls = 0, p_cur = p_response->p_intermediates
+            ; p_cur != NULL
+            ; p_cur = p_cur->p_next
+    ) {
+        countCalls++;
+    }
+
+    /* yes, there's an array of pointers and then an array of structures */
+
+    pp_calls = (RIL_Call **)alloca(countCalls * sizeof(RIL_Call *));
+    p_calls = (RIL_Call *)alloca(countCalls * sizeof(RIL_Call));
+    memset (p_calls, 0, countCalls * sizeof(RIL_Call));
+
+    /* init the pointer array */
+    for(i = 0; i < countCalls ; i++) {
+        pp_calls[i] = &(p_calls[i]);
+    }
+
+    for (countValidCalls = 0, p_cur = p_response->p_intermediates
+            ; p_cur != NULL
+            ; p_cur = p_cur->p_next
+    ) {
+        err = callFromCLCCLine(p_cur->line, p_calls + countValidCalls);
+
+        if (err != 0) {
+            continue;
+        }
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+        if (p_calls[countValidCalls].state == RIL_CALL_INCOMING
+            || p_calls[countValidCalls].state == RIL_CALL_WAITING
+        ) {
+            s_incomingOrWaitingLine = p_calls[countValidCalls].index;
+        }
+#endif /*WORKAROUND_ERRONEOUS_ANSWER*/
+
+        if (p_calls[countValidCalls].state != RIL_CALL_ACTIVE
+            && p_calls[countValidCalls].state != RIL_CALL_HOLDING
+        ) {
+            needRepoll = 1;
+        }
+
+        countValidCalls++;
+    }
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+    // Basically:
+    // A call was incoming or waiting
+    // Now it's marked as active
+    // But we never answered it
+    //
+    // This is probably a bug, and the call will probably
+    // disappear from the call list in the next poll
+    if (prevIncomingOrWaitingLine >= 0
+            && s_incomingOrWaitingLine < 0
+            && s_expectAnswer == 0
+    ) {
+        for (i = 0; i < countValidCalls ; i++) {
+
+            if (p_calls[i].index == prevIncomingOrWaitingLine
+                    && p_calls[i].state == RIL_CALL_ACTIVE
+                    && s_repollCallsCount < REPOLL_CALLS_COUNT_MAX
+            ) {
+                ALOGI(
+                    "Hit WORKAROUND_ERRONOUS_ANSWER case."
+                    " Repoll count: %d\n", s_repollCallsCount);
+                s_repollCallsCount++;
+                goto error;
+            }
+        }
+    }
+
+    s_expectAnswer = 0;
+    s_repollCallsCount = 0;
+#endif /*WORKAROUND_ERRONEOUS_ANSWER*/
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, pp_calls,
+            countValidCalls * sizeof (RIL_Call *));
+
+    at_response_free(p_response);
+
+#ifdef POLL_CALL_STATE
+    if (countValidCalls) {  // We don't seem to get a "NO CARRIER" message from
+                            // smd, so we're forced to poll until the call ends.
+#else
+    if (needRepoll) {
+#endif
+        RIL_requestTimedCallback (inst_id, sendCallStateChanged, (void *)inst_id, &TIMEVAL_CALLSTATEPOLL);
+    }
+
+    return;
+error:
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+static RIL_SelectUiccSub currentSelectedSub[2] = {
+    {-1, -1, RIL_SUBSCRIPTION_1, RIL_UICC_SUBSCRIPTION_DEACTIVATE },
+    {-1, -1, RIL_SUBSCRIPTION_1, RIL_UICC_SUBSCRIPTION_DEACTIVATE }
+};
+
+static int isAppReady(int slot, int app_index) {
+    int i = 0;
+
+    for (i=0; i<2; i++) {
+        if (currentSelectedSub[i].act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE
+                && currentSelectedSub[i].slot == slot
+                && currentSelectedSub[i].app_index == app_index) {
+            ALOGD("isAppReady : slot = %d app_index = %d is READY", slot, app_index);
+            return 1;
+        }
+    }
+    ALOGD("isAppReady : slot = %d app_index = %d is NOT READY", slot, app_index);
+    return 0;
+}
+
+static void setUiccSubscriptionSource(int inst_id, int request, void *data, size_t datalen, RIL_Token t)
+{
+    RIL_SelectUiccSub *uiccSubscrInfo;
+    uiccSubscrInfo = (RIL_SelectUiccSub *)data;
+    int response = 0;
+    int slot = 0;
+
+    ALOGD("setUiccSubscriptionSource() : inst_id = %d", inst_id);
+    slot = uiccSubscrInfo->slot;
+    currentSelectedSub[slot].slot = uiccSubscrInfo->slot;
+    currentSelectedSub[slot].app_index = uiccSubscrInfo->app_index;
+    currentSelectedSub[slot].sub_type = uiccSubscrInfo->sub_type;
+    currentSelectedSub[slot].act_status = uiccSubscrInfo->act_status;
+
+    // TODO: DSDS: Need to implement this.
+    // workarround: send success for now.
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+
+    if (uiccSubscrInfo->act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE) {
+        if (currentSelectedSub[slot].slot == 0
+                && mySimState[0] == SIM_NOT_READY) {
+            mySimState[0] = SIM_READY;
+        }
+        ALOGD("setUiccSubscriptionSource() : Activate Request: sending SUBSCRIPTION_STATUS_CHANGED");
+        response = 1; // ACTIVATED
+        RIL_onUnsolicitedResponse (
+            inst_id,
+            RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED,
+            &response, sizeof(response));
+    } else {
+        ALOGD("setUiccSubscriptionSource() : Deactivate Request");
+    }
+    RIL_onUnsolicitedResponse(uiccSubscrInfo->slot, RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
+}
+
+static void setSubscriptionMode(int instance_id, int request, void *data, size_t datalen, RIL_Token t)
+{
+    ALOGD("getUiccSubscriptionSource() : instance_id = %d", instance_id);
+    // TODO: DSDS: Need to implement this.
+    // workarround: send success for now.
+    RIL_onRequestComplete(instance_id, t, RIL_E_SUCCESS, NULL, 0);
+}
+
+
+static void getUiccSubscriptionSource(int inst_id, int request, void *data, size_t datalen, RIL_Token t)
+{
+    ALOGD("getUiccSubscriptionSource() : inst_id = %d", inst_id);
+    // TODO: DSDS: Need to implement this.
+    // workarround: send success for now.
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+}
+
+static void setDataSubscriptionSource(int inst_id, int request, void *data, size_t datalen, RIL_Token t)
+{
+    ALOGD("setDataSubscriptionSource() : inst_id = %d", inst_id) ;
+    myDds = inst_id;
+    // TODO: DSDS: Need to implement this.
+    // workarround: send success for now.
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+
+    inst_id = (inst_id == 0) ? 1 : 0;
+    ALOGD("setDataSubscriptionSource() : sending all data disconnected on SUB: = %d", inst_id);
+    RIL_onUnsolicitedResponse(inst_id, RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                              NULL, 0);
+}
+
+static void getDataSubscriptionSource(int inst_id, int request, void *data, size_t datalen, RIL_Token t)
+{
+    ALOGD("getDataSubscriptionSource() : inst_id = %d", inst_id);
+    // TODO: DSDS: Need to implement this.
+    // workarround: send success for now.
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+}
+
+
+static void requestDial(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    RIL_Dial *p_dial;
+    char *cmd;
+    const char *clir;
+    int ret;
+
+    ALOGD("requestDial() : inst_id = %d", inst_id);
+    mo_call = 1;
+
+    p_dial = (RIL_Dial *)data;
+
+    switch (p_dial->clir) {
+        case 1: clir = "I"; break;  /*invocation*/
+        case 2: clir = "i"; break;  /*suppression*/
+        default:
+        case 0: clir = ""; break;   /*subscription default*/
+    }
+
+    asprintf(&cmd, "ATD%s%s;", p_dial->address, clir);
+
+    ret = at_send_command(cmd, NULL);
+
+    free(cmd);
+
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+}
+
+static void requestWriteSmsToSim(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    RIL_SMS_WriteArgs *p_args;
+    char *cmd;
+    int length;
+    int err;
+    ATResponse *p_response = NULL;
+
+    p_args = (RIL_SMS_WriteArgs *)data;
+
+    length = strlen(p_args->pdu)/2;
+    asprintf(&cmd, "AT+CMGW=%d,%d", length, p_args->status);
+
+    err = at_send_command_sms(cmd, p_args->pdu, "+CMGW:", &p_response);
+
+    if (err != 0 || p_response->success == 0) goto error;
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+    at_response_free(p_response);
+
+    return;
+error:
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+static void requestHangup(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    int *p_line;
+
+    int ret;
+    char *cmd;
+
+    ALOGD("requestHangup() : inst_id = %d", inst_id);
+    mo_call = 0;
+
+    p_line = (int *)data;
+
+    // 3GPP 22.030 6.5.5
+    // "Releases a specific active call X"
+    asprintf(&cmd, "AT+CHLD=1%d", p_line[0]);
+
+    ret = at_send_command(cmd, NULL);
+
+    free(cmd);
+
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+}
+
+static void requestSignalStrength(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    int err;
+    char *line;
+    int count =0;
+    int numofElements=sizeof(RIL_SignalStrength_v6)/sizeof(int);
+    int response[numofElements];
+
+    err = at_send_command_singleline("AT+CSQ", "+CSQ:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    for (count =0; count < numofElements; count ++) {
+        err = at_tok_nextint(&line, &(response[count]));
+        if (err < 0) goto error;
+    }
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, response, sizeof(response));
+
+    at_response_free(p_response);
+    return;
+
+error:
+    ALOGE("requestSignalStrength must never return an error when radio is on");
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+static void requestRegistrationState(int inst_id, int request, void *data,
+                                        size_t datalen, RIL_Token t)
+{
+    int err;
+    int response[4];
+    char * responseStr[4];
+    ATResponse *p_response = NULL;
+    const char *cmd;
+    const char *prefix;
+    char *line, *p;
+    int commas;
+    int skip;
+    int count = 3;
+
+
+    if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE) {
+        cmd = "AT+CREG?";
+        prefix = "+CREG:";
+    } else if (request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+        cmd = "AT+CGREG?";
+        prefix = "+CGREG:";
+    } else {
+        assert(0);
+        goto error;
+    }
+
+    err = at_send_command_singleline(cmd, prefix, &p_response);
+
+    if (err != 0) goto error;
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    /* Ok you have to be careful here
+     * The solicited version of the CREG response is
+     * +CREG: n, stat, [lac, cid]
+     * and the unsolicited version is
+     * +CREG: stat, [lac, cid]
+     * The <n> parameter is basically "is unsolicited creg on?"
+     * which it should always be
+     *
+     * Now we should normally get the solicited version here,
+     * but the unsolicited version could have snuck in
+     * so we have to handle both
+     *
+     * Also since the LAC and CID are only reported when registered,
+     * we can have 1, 2, 3, or 4 arguments here
+     *
+     * finally, a +CGREG: answer may have a fifth value that corresponds
+     * to the network type, as in;
+     *
+     *   +CGREG: n, stat [,lac, cid [,networkType]]
+     */
+
+    /* count number of commas */
+    commas = 0;
+    for (p = line ; *p != '\0' ;p++) {
+        if (*p == ',') commas++;
+    }
+
+    switch (commas) {
+        case 0: /* +CREG: <stat> */
+            err = at_tok_nextint(&line, &response[0]);
+            if (err < 0) goto error;
+            response[1] = -1;
+            response[2] = -1;
+        break;
+
+        case 1: /* +CREG: <n>, <stat> */
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &response[0]);
+            if (err < 0) goto error;
+            response[1] = -1;
+            response[2] = -1;
+            if (err < 0) goto error;
+        break;
+
+        case 2: /* +CREG: <stat>, <lac>, <cid> */
+            err = at_tok_nextint(&line, &response[0]);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &response[1]);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &response[2]);
+            if (err < 0) goto error;
+        break;
+        case 3: /* +CREG: <n>, <stat>, <lac>, <cid> */
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &response[0]);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &response[1]);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &response[2]);
+            if (err < 0) goto error;
+        break;
+        /* special case for CGREG, there is a fourth parameter
+         * that is the network type (unknown/gprs/edge/umts)
+         */
+        case 4: /* +CGREG: <n>, <stat>, <lac>, <cid>, <networkType> */
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &response[0]);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &response[1]);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &response[2]);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &response[3]);
+            if (err < 0) goto error;
+            count = 4;
+        break;
+        default:
+            goto error;
+    }
+
+    asprintf(&responseStr[0], "%d", response[0]);
+    asprintf(&responseStr[1], "%x", response[1]);
+    asprintf(&responseStr[2], "%x", response[2]);
+
+    if (count > 3)
+        asprintf(&responseStr[3], "%d", response[3]);
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, responseStr, count*sizeof(char*));
+    at_response_free(p_response);
+
+    return;
+error:
+    ALOGE("requestRegistrationState must never return an error when radio is on");
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+static void requestOperator(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    int err;
+    int i;
+    int skip;
+    ATLine *p_cur;
+    char *response[3];
+
+    memset(response, 0, sizeof(response));
+
+    ATResponse *p_response = NULL;
+
+    ALOGD("requestOperator(): inst_id = %d", inst_id);
+
+    err = at_send_command_multiline(
+        "AT+COPS=3,0;+COPS?;+COPS=3,1;+COPS?;+COPS=3,2;+COPS?",
+        "+COPS:", &p_response);
+
+    /* we expect 3 lines here:
+     * +COPS: 0,0,"T - Mobile"
+     * +COPS: 0,1,"TMO"
+     * +COPS: 0,2,"310170"
+     */
+
+    if (err != 0) goto error;
+
+    for (i = 0, p_cur = p_response->p_intermediates
+            ; p_cur != NULL
+            ; p_cur = p_cur->p_next, i++
+    ) {
+        char *line = p_cur->line;
+
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+
+        err = at_tok_nextint(&line, &skip);
+        if (err < 0) goto error;
+
+        // If we're unregistered, we may just get
+        // a "+COPS: 0" response
+        if (!at_tok_hasmore(&line)) {
+            response[i] = NULL;
+            continue;
+        }
+
+        err = at_tok_nextint(&line, &skip);
+        if (err < 0) goto error;
+
+        // a "+COPS: 0, n" response is also possible
+        if (!at_tok_hasmore(&line)) {
+            response[i] = NULL;
+            continue;
+        }
+
+        err = at_tok_nextstr(&line, &(response[i]));
+        if (err < 0) goto error;
+    }
+
+    if (i != 3) {
+        /* expect 3 lines exactly */
+        goto error;
+    }
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, response, sizeof(response));
+    at_response_free(p_response);
+
+    return;
+error:
+    ALOGE("requestOperator must not return error when radio is on");
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+static void requestSendSMS(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    int err;
+    const char *smsc;
+    const char *pdu;
+    int tpLayerLength;
+    char *cmd1, *cmd2;
+    RIL_SMS_Response response;
+    ATResponse *p_response = NULL;
+
+    ALOGD("requestSendSMS datalen =%d", datalen);
+    smsc = ((const char **)data)[0];
+    pdu = ((const char **)data)[1];
+
+    tpLayerLength = strlen(pdu)/2;
+
+    ALOGD("requestSendSMS(): inst_id = %d", inst_id);
+
+    // "NULL for default SMSC"
+    if (smsc == NULL) {
+        smsc= "00";
+    }
+    ALOGD("smsc=%s, pdu=%s", smsc, pdu);
+
+    asprintf(&cmd1, "AT+CMGS=%d", tpLayerLength);
+    asprintf(&cmd2, "%s%s", smsc, pdu);
+
+    err = at_send_command_sms(cmd1, cmd2, "+CMGS:", &p_response);
+
+    if (err != 0 || p_response->success == 0) goto error;
+
+    memset(&response, 0, sizeof(response));
+
+    /* FIXME fill in messageRef and ackPDU */
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, &response, sizeof(response));
+    at_response_free(p_response);
+
+    return;
+error:
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+static void requestSetupDataCall(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    const char *apn;
+    char *cmd;
+    int err;
+    ATResponse *p_response = NULL;
+
+    apn = ((const char **)data)[2];
+
+#ifdef USE_TI_COMMANDS
+    // Config for multislot class 10 (probably default anyway eh?)
+    err = at_send_command("AT%CPRIM=\"GMM\",\"CONFIG MULTISLOT_CLASS=<10>\"",
+                        NULL);
+
+    err = at_send_command("AT%DATA=2,\"UART\",1,,\"SER\",\"UART\",0", NULL);
+#endif /* USE_TI_COMMANDS */
+
+    int fd, qmistatus;
+    size_t cur = 0;
+    size_t len;
+    ssize_t written, rlen;
+    char status[32] = {0};
+    int retry = 10;
+    const char *pdp_type;
+
+    ALOGD("requesting data connection to APN '%s'", apn);
+
+    fd = open ("/dev/qmi", O_RDWR);
+    if (fd >= 0) { /* the device doesn't exist on the emulator */
+
+        ALOGD("opened the qmi device\n");
+        asprintf(&cmd, "up:%s", apn);
+        len = strlen(cmd);
+
+        while (cur < len) {
+            do {
+                written = write (fd, cmd + cur, len - cur);
+            } while (written < 0 && errno == EINTR);
+
+            if (written < 0) {
+                ALOGE("### ERROR writing to /dev/qmi");
+                close(fd);
+                goto error;
+            }
+
+            cur += written;
+        }
+
+        // wait for interface to come online
+
+        do {
+            sleep(1);
+            do {
+                rlen = read(fd, status, 31);
+            } while (rlen < 0 && errno == EINTR);
+
+            if (rlen < 0) {
+                ALOGE("### ERROR reading from /dev/qmi");
+                close(fd);
+                goto error;
+            } else {
+                status[rlen] = '\0';
+                ALOGD("### status: %s", status);
+            }
+        } while (strncmp(status, "STATE=up", 8) && strcmp(status, "online") && --retry);
+
+        close(fd);
+
+        if (retry == 0) {
+            ALOGE("### Failed to get data connection up\n");
+            goto error;
+        }
+
+        qmistatus = system("netcfg rmnet0 dhcp");
+
+        ALOGD("netcfg rmnet0 dhcp: status %d\n", qmistatus);
+
+        if (qmistatus < 0) goto error;
+
+    } else {
+
+        if (datalen > 6 * sizeof(char *)) {
+            pdp_type = ((const char **)data)[6];
+        } else {
+            pdp_type = "IP";
+        }
+
+        asprintf(&cmd, "AT+CGDCONT=1,\"%s\",\"%s\",,0,0", pdp_type, apn);
+        //FIXME check for error here
+        err = at_send_command(cmd, NULL);
+        free(cmd);
+
+        // Set required QoS params to default
+        err = at_send_command("AT+CGQREQ=1", NULL);
+
+        // Set minimum QoS params to default
+        err = at_send_command("AT+CGQMIN=1", NULL);
+
+        // packet-domain event reporting
+        err = at_send_command("AT+CGEREP=1,0", NULL);
+
+        // Hangup anything that's happening there now
+        err = at_send_command("AT+CGACT=1,0", NULL);
+
+        // Start data on PDP context 1
+        err = at_send_command("ATD*99***1#", &p_response);
+
+        if (err < 0 || p_response->success == 0) {
+            goto error;
+        }
+    }
+
+    requestOrSendDataCallList(inst_id, &t);
+
+    at_response_free(p_response);
+
+    return;
+error:
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+
+}
+
+static void requestSMSAcknowledge(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    int ackSuccess;
+    int err;
+
+    ackSuccess = ((int *)data)[0];
+
+    if (ackSuccess == 1) {
+        err = at_send_command("AT+CNMA=1", NULL);
+    } else if (ackSuccess == 0)  {
+        err = at_send_command("AT+CNMA=2", NULL);
+    } else {
+        ALOGE("unsupported arg to RIL_REQUEST_SMS_ACKNOWLEDGE\n");
+        goto error;
+    }
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+error:
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+
+}
+
+static void  requestSIM_IO(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    RIL_SIM_IO_Response sr;
+    int err;
+    char *cmd = NULL;
+    RIL_SIM_IO_v6 *p_args;
+    char *line;
+
+    memset(&sr, 0, sizeof(sr));
+
+    p_args = (RIL_SIM_IO_v6 *)data;
+
+    ALOGD("requestSIM_IO(): inst_id = %d fileid = %d", inst_id, p_args->fileid);
+
+    /* FIXME handle pin2 */
+
+    if (p_args->data == NULL) {
+        asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d",
+                    p_args->command, p_args->fileid,
+                    p_args->p1, p_args->p2, p_args->p3);
+    } else {
+        asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d,%s",
+                    p_args->command, p_args->fileid,
+                    p_args->p1, p_args->p2, p_args->p3, p_args->data);
+    }
+
+    err = at_send_command_singleline(cmd, "+CRSM:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(sr.sw1));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(sr.sw2));
+    if (err < 0) goto error;
+
+    if (at_tok_hasmore(&line)) {
+        err = at_tok_nextstr(&line, &(sr.simResponse));
+        if (err < 0) goto error;
+    }
+
+    if (p_args->fileid == 0x2FE2) {
+        if (p_args->command == 0xb0) {
+            if (inst_id == REF_RIL_SECOND_INSTANCE_ID) {
+                sr.simResponse = "88004433112288557700";
+            }
+            ALOGD("requestSIM_IO(): Read Request for ICCID on inst_id - %d. ICCID = %s",
+                    inst_id, sr.simResponse);
+        }
+    }
+
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, &sr, sizeof(sr));
+    at_response_free(p_response);
+    free(cmd);
+
+    return;
+error:
+    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+    free(cmd);
+
+}
+
+static void  requestEnterSimPin(int inst_id, void*  data, size_t  datalen, RIL_Token  t)
+{
+    ATResponse   *p_response = NULL;
+    int           err;
+    char*         cmd = NULL;
+    const char**  strings = (const char**)data;;
+
+    if ( datalen == sizeof(char*) ) {
+        asprintf(&cmd, "AT+CPIN=%s", strings[0]);
+    } else if ( datalen == 2*sizeof(char*) || datalen == 3 * sizeof(char*)) {
+        asprintf(&cmd, "AT+CPIN=%s,%s", strings[0], strings[1]);
+    } else {
+        goto error;
+    }
+
+    err = at_send_command_singleline(cmd, "+CPIN:", &p_response);
+    free(cmd);
+
+    if (err < 0 || p_response->success == 0) {
+error:
+        RIL_onRequestComplete(inst_id, t, RIL_E_PASSWORD_INCORRECT, NULL, 0);
+    } else {
+        RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+    }
+    at_response_free(p_response);
+}
+
+
+static void  requestSendUSSD(int inst_id, void *data, size_t datalen, RIL_Token t)
+{
+    const char *ussdRequest;
+
+    ussdRequest = (char *)(data);
+
+
+    RIL_onRequestComplete(inst_id, t, RIL_E_REQUEST_NOT_SUPPORTED, NULL, 0);
+
+// @@@ TODO
+
+}
+
+
+/*** Callback methods from the RIL library to us ***/
+
+/**
+ * Call from RIL to us to make a RIL_REQUEST
+ *
+ * Must be completed with a call to RIL_onRequestComplete()
+ *
+ * RIL_onRequestComplete() may be called from any thread, before or after
+ * this function returns.
+ *
+ * Will always be called from the same thread, so returning here implies
+ * that the radio is ready to process another command (whether or not
+ * the previous command has completed).
+ */
+static void
+onRequest (int inst_id, int request, void *data, size_t datalen, RIL_Token t)
+{
+    ATResponse *p_response;
+    int err;
+
+    ALOGD("onRequest: %s, inst_id = %d", requestToString(request), inst_id);
+
+    /* Ignore all requests except RIL_REQUEST_GET_SIM_STATUS
+     * when RADIO_STATE_UNAVAILABLE.
+     */
+    if (sState[inst_id] == RADIO_STATE_UNAVAILABLE
+        && !(request == RIL_REQUEST_GET_SIM_STATUS)
+    ) {
+        RIL_onRequestComplete(inst_id, t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
+        return;
+    }
+
+    /* Ignore all non-power requests when RADIO_STATE_OFF
+     * (except RIL_REQUEST_GET_SIM_STATUS)
+     */
+    if (sState[inst_id] == RADIO_STATE_OFF
+        && !(request == RIL_REQUEST_RADIO_POWER
+            || request == RIL_REQUEST_GET_SIM_STATUS)
+    ) {
+        RIL_onRequestComplete(inst_id, t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
+        return;
+    }
+
+    switch (request) {
+        case RIL_REQUEST_GET_SIM_STATUS: {
+            RIL_CardStatus_v6 *p_card_status;
+            char *p_buffer;
+            int buffer_size;
+
+            int result = getCardStatus(inst_id, &p_card_status);
+            if (result == RIL_E_SUCCESS) {
+                p_buffer = (char *)p_card_status;
+                buffer_size = sizeof(*p_card_status);
+            } else {
+                p_buffer = NULL;
+                buffer_size = 0;
+            }
+            RIL_onRequestComplete(inst_id, t, result, p_buffer, buffer_size);
+            freeCardStatus(p_card_status);
+            break;
+        }
+        case RIL_REQUEST_GET_CURRENT_CALLS:
+            requestGetCurrentCalls(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_DIAL:
+            requestDial(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_HANGUP:
+            requestHangup(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
+            // 3GPP 22.030 6.5.5
+            // "Releases all held calls or sets User Determined User Busy
+            //  (UDUB) for a waiting call."
+            at_send_command("AT+CHLD=0", NULL);
+
+            /* success or failure is ignored by the upper layer here.
+               it will call GET_CURRENT_CALLS and determine success that way */
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
+            // 3GPP 22.030 6.5.5
+            // "Releases all active calls (if any exist) and accepts
+            //  the other (held or waiting) call."
+            at_send_command("AT+CHLD=1", NULL);
+            mo_call = 0;
+
+            /* success or failure is ignored by the upper layer here.
+               it will call GET_CURRENT_CALLS and determine success that way */
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
+            // 3GPP 22.030 6.5.5
+            // "Places all active calls (if any exist) on hold and accepts
+            //  the other (held or waiting) call."
+            at_send_command("AT+CHLD=2", NULL);
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+            s_expectAnswer = 1;
+#endif /* WORKAROUND_ERRONEOUS_ANSWER */
+
+            /* success or failure is ignored by the upper layer here.
+               it will call GET_CURRENT_CALLS and determine success that way */
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        case RIL_REQUEST_ANSWER:
+            at_send_command("ATA", NULL);
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+            s_expectAnswer = 1;
+#endif /* WORKAROUND_ERRONEOUS_ANSWER */
+
+            /* success or failure is ignored by the upper layer here.
+               it will call GET_CURRENT_CALLS and determine success that way */
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        case RIL_REQUEST_CONFERENCE:
+            // 3GPP 22.030 6.5.5
+            // "Adds a held call to the conversation"
+            at_send_command("AT+CHLD=3", NULL);
+
+            /* success or failure is ignored by the upper layer here.
+               it will call GET_CURRENT_CALLS and determine success that way */
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        case RIL_REQUEST_UDUB:
+            /* user determined user busy */
+            /* sometimes used: ATH */
+            at_send_command("ATH", NULL);
+
+            /* success or failure is ignored by the upper layer here.
+               it will call GET_CURRENT_CALLS and determine success that way */
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            break;
+
+        case RIL_REQUEST_SEPARATE_CONNECTION:
+            {
+                char  cmd[12];
+                int   party = ((int*)data)[0];
+
+                // Make sure that party is in a valid range.
+                // (Note: The Telephony middle layer imposes a range of 1 to 7.
+                // It's sufficient for us to just make sure it's single digit.)
+                if (party > 0 && party < 10) {
+                    sprintf(cmd, "AT+CHLD=2%d", party);
+                    at_send_command(cmd, NULL);
+                    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+                } else {
+                    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                }
+            }
+            break;
+
+        case RIL_REQUEST_SIGNAL_STRENGTH:
+            requestSignalStrength(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
+        case RIL_REQUEST_DATA_REGISTRATION_STATE:
+            requestRegistrationState(inst_id, request, data, datalen, t);
+            break;
+        case RIL_REQUEST_OPERATOR:
+            requestOperator(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_RADIO_POWER:
+            requestRadioPower(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_DTMF: {
+            char c = ((char *)data)[0];
+            char *cmd;
+            asprintf(&cmd, "AT+VTS=%c", (int)c);
+            at_send_command(cmd, NULL);
+            free(cmd);
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        }
+        case RIL_REQUEST_SEND_SMS:
+            requestSendSMS(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_SETUP_DATA_CALL:
+            requestSetupDataCall(inst_id, data, datalen, t);
+            break;
+        case RIL_REQUEST_SMS_ACKNOWLEDGE:
+            requestSMSAcknowledge(inst_id, data, datalen, t);
+            break;
+
+        case RIL_REQUEST_GET_IMSI:
+            p_response = NULL;
+            err = at_send_command_numeric("AT+CIMI", &p_response);
+
+            if (err < 0 || p_response->success == 0) {
+                RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            } else {
+                RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS,
+                    p_response->p_intermediates->line, sizeof(char *));
+            }
+            at_response_free(p_response);
+            break;
+
+        case RIL_REQUEST_GET_IMEI:
+            ALOGD("RIL_REQUEST_GET_IMEI");
+            p_response = NULL;
+            err = at_send_command_numeric("AT+CGSN", &p_response);
+
+            if (err < 0 || p_response->success == 0) {
+                RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            } else {
+                RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS,
+                    p_response->p_intermediates->line, sizeof(char *));
+            }
+            at_response_free(p_response);
+            break;
+
+        case RIL_REQUEST_SIM_IO:
+            requestSIM_IO(inst_id, data,datalen,t);
+            break;
+
+        case RIL_REQUEST_SEND_USSD:
+            requestSendUSSD(inst_id, data, datalen, t);
+            break;
+
+        case RIL_REQUEST_CANCEL_USSD:
+            p_response = NULL;
+            err = at_send_command_numeric("AT+CUSD=2", &p_response);
+
+            if (err < 0 || p_response->success == 0) {
+                RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            } else {
+                RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS,
+                    p_response->p_intermediates->line, sizeof(char *));
+            }
+            at_response_free(p_response);
+            break;
+
+        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
+            at_send_command("AT+COPS=0", NULL);
+            break;
+
+        case RIL_REQUEST_DATA_CALL_LIST:
+            requestDataCallList(inst_id, data, datalen, t);
+            break;
+
+        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
+            requestQueryNetworkSelectionMode(inst_id, data, datalen, t);
+            break;
+
+        case RIL_REQUEST_OEM_HOOK_RAW:
+            // echo back data
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, data, datalen);
+            break;
+
+
+        case RIL_REQUEST_OEM_HOOK_STRINGS: {
+            int i;
+            const char ** cur;
+
+            ALOGD("got OEM_HOOK_STRINGS: 0x%8p %lu", data, (long)datalen);
+
+
+            for (i = (datalen / sizeof (char *)), cur = (const char **)data ;
+                    i > 0 ; cur++, i --) {
+                ALOGD("> '%s'", *cur);
+            }
+
+            // echo back strings
+            RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, data, datalen);
+            break;
+        }
+
+        case RIL_REQUEST_WRITE_SMS_TO_SIM:
+            requestWriteSmsToSim(inst_id, data, datalen, t);
+            break;
+
+        case RIL_REQUEST_DELETE_SMS_ON_SIM: {
+            char * cmd;
+            p_response = NULL;
+            asprintf(&cmd, "AT+CMGD=%d", ((int *)data)[0]);
+            err = at_send_command(cmd, &p_response);
+            free(cmd);
+            if (err < 0 || p_response->success == 0) {
+                RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            } else {
+                RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, NULL, 0);
+            }
+            at_response_free(p_response);
+            break;
+        }
+
+        case RIL_REQUEST_ENTER_SIM_PIN:
+        case RIL_REQUEST_ENTER_SIM_PUK:
+        case RIL_REQUEST_ENTER_SIM_PIN2:
+        case RIL_REQUEST_ENTER_SIM_PUK2:
+        case RIL_REQUEST_CHANGE_SIM_PIN:
+        case RIL_REQUEST_CHANGE_SIM_PIN2:
+            requestEnterSimPin(inst_id, data, datalen, t);
+            break;
+
+/* TODO:       case RIL_REQUEST_VOICE_RADIO_TECH:
+            {
+                int techfam = techFamilyFromModemType(TECH(sMdmInfo));
+                if (techfam < 0 )
+                    RIL_onRequestComplete(inst_id, t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                else
+                    RIL_onRequestComplete(inst_id, t, RIL_E_SUCCESS, &techfam, sizeof(&techfam));
+            }
+            break;*/
+
+        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
+            setUiccSubscriptionSource(inst_id, request, data, datalen, t);
+            break;
+        case RIL_REQUEST_SET_DATA_SUBSCRIPTION:
+            setDataSubscriptionSource(inst_id, request, data, datalen, t);
+            break;
+        case RIL_REQUEST_GET_UICC_SUBSCRIPTION:
+            getUiccSubscriptionSource(inst_id, request, data, datalen, t);
+            break;
+        case RIL_REQUEST_GET_DATA_SUBSCRIPTION:
+            getDataSubscriptionSource(inst_id, request, data, datalen, t);
+            break;
+        case RIL_REQUEST_SET_SUBSCRIPTION_MODE:
+            setSubscriptionMode(inst_id, request, data, datalen, t);
+            break;
+        default:
+            ALOGD("Request not supported. Tech:" );
+            RIL_onRequestComplete(inst_id, t, RIL_E_REQUEST_NOT_SUPPORTED, NULL, 0);
+            break;
+    }
+}
+
+/**
+ * Call from RIL instance 0 to us to make a RIL_REQUEST
+ *
+ * Must be completed with a call to RIL_onRequestComplete()
+ *
+ * RIL_onRequestComplete() may be called from any thread, before or after
+ * this function returns.
+ *
+ * Will always be called from the same thread, so returning here implies
+ * that the radio is ready to process another command (whether or not
+ * the previous command has completed).
+ */
+static void
+onRequest_func0 (int request, void *data, size_t datalen, RIL_Token t)
+{
+    onRequest (REF_RIL_FIRST_INSTANCE_ID, request, data, datalen, t);
+}
+
+/**
+ * Call from RIL instance 1 to us to make a RIL_REQUEST
+ *
+ * Must be completed with a call to RIL_onRequestComplete()
+ *
+ * RIL_onRequestComplete() may be called from any thread, before or after
+ * this function returns.
+ *
+ * Will always be called from the same thread, so returning here implies
+ * that the radio is ready to process another command (whether or not
+ * the previous command has completed).
+ */
+static void
+onRequest_func1 (int request, void *data, size_t datalen, RIL_Token t)
+{
+    onRequest (REF_RIL_SECOND_INSTANCE_ID, request, data, datalen, t);
+}
+
+
+/**
+ * Synchronous call from the RIL to us to return current radio state.
+ * RADIO_STATE_UNAVAILABLE should be the initial state.
+ */
+static RIL_RadioState
+currentState(int inst_id)
+{
+    if (inst_id == REF_RIL_FIRST_INSTANCE_ID) {
+        return sState[REF_RIL_FIRST_INSTANCE_ID];
+    } else {
+        return sState[REF_RIL_SECOND_INSTANCE_ID];
+    }
+}
+
+/**
+ * Call from RIL instance 0 for currentState
+ */
+static RIL_RadioState
+currentState_func0()
+{
+    ALOGD("currentState_func0");
+    return currentState(REF_RIL_FIRST_INSTANCE_ID);
+}
+
+/**
+ * Call from RIL instance 1 for currentState
+ */
+static RIL_RadioState
+currentState_func1()
+{
+    ALOGD("currentState_func1");
+    return currentState(REF_RIL_SECOND_INSTANCE_ID);
+}
+
+/**
+ * Call from RIL to us to find out whether a specific request code
+ * is supported by this implementation.
+ *
+ * Return 1 for "supported" and 0 for "unsupported"
+ */
+
+static int
+onSupports (int inst_id, int requestCode)
+{
+    //@@@ todo
+
+    return 1;
+}
+
+/**
+ * Call from RIL instance 0 to us to find out whether a specific request code
+ * is supported by this implementation.
+ *
+ * Return 1 for "supported" and 0 for "unsupported"
+ */
+static int
+onSupports_func0(int requestCode)
+{
+    return onSupports(REF_RIL_FIRST_INSTANCE_ID, requestCode);
+}
+
+/**
+ * Call from RIL instance 1 to us to find out whether a specific request code
+ * is supported by this implementation.
+ *
+ * Return 1 for "supported" and 0 for "unsupported"
+ */
+static int
+onSupports_func1(int requestCode)
+{
+    return onSupports(REF_RIL_SECOND_INSTANCE_ID, requestCode);
+}
+
+
+static void onCancel (int instance, RIL_Token t)
+{
+    //@@@todo
+
+}
+
+/**
+ * Call from RIL instance 2 for onCancel
+ */
+static void onCancel_func0 (RIL_Token t)
+{
+    onCancel(REF_RIL_FIRST_INSTANCE_ID, t);
+}
+
+/**
+ * Call from RIL instance 1 for onCancel
+ */
+static void onCancel_func1 (RIL_Token t)
+{
+    onCancel(REF_RIL_SECOND_INSTANCE_ID, t);
+}
+
+static const char * getVersion(int inst_id)
+{
+    return "android reference-ril 1.0";
+}
+
+/**
+ * Call from RIL instance 0 for getVersion
+ */
+static const char * getVersion_func0(void)
+{
+    return getVersion(REF_RIL_FIRST_INSTANCE_ID);
+}
+
+/**
+ * Call from RIL instance 1 for getVersion
+ */
+static const char * getVersion_func1(void)
+{
+    return getVersion(REF_RIL_SECOND_INSTANCE_ID);
+}
+
+/*static void
+setRadioTechnology(int inst_id, ModemInfo *mdm, int newtech)
+{
+    ALOGD("setRadioTechnology(%d, %d)", inst_id, newtech);
+
+    int oldtech = TECH(mdm);
+
+    if (newtech != oldtech) {
+        ALOGD("Tech change (%d => %d)", oldtech, newtech);
+        TECH(mdm) = newtech;
+        if (techFamilyFromModemType(newtech) != techFamilyFromModemType(oldtech)) {
+            RIL_onUnsolicitedResponse(inst_id, RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, NULL, 0);
+        }
+    }
+}
+*/
+
+static void
+setRadioState (int inst_id, RIL_RadioState newState)
+{
+    ALOGD("setRadioState (%d, %d)", inst_id, newState);
+    RIL_RadioState oldState;
+
+    pthread_mutex_lock(&s_state_mutex);
+
+    oldState = sState[inst_id];
+
+    if (s_closed > 0) {
+        // If we're closed, the only reasonable state is
+        // RADIO_STATE_UNAVAILABLE
+        // This is here because things on the main thread
+        // may attempt to change the radio state after the closed
+        // event happened in another thread
+        newState = RADIO_STATE_UNAVAILABLE;
+    }
+
+    if (sState[inst_id] != newState || s_closed > 0) {
+        sState[inst_id] = newState;
+        pthread_cond_broadcast (&s_state_cond);
+    }
+
+    pthread_mutex_unlock(&s_state_mutex);
+
+
+    /* do these outside of the mutex */
+    if (sState[inst_id] != oldState) {
+        RIL_onUnsolicitedResponse (inst_id, RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
+                                    NULL, 0);
+
+         //TODO: suresh check this is proper ?
+        /* FIXME onSimReady() and onRadioPowerOn() cannot be called
+         * from the AT reader thread
+         * Currently, this doesn't happen, but if that changes then these
+         * will need to be dispatched on the request thread
+         */
+     //   if (sState[inst_id] == RADIO_STATE_SIM_READY) {
+     //       onSIMReady();
+     //   } else
+        if (sState[inst_id] == RADIO_STATE_ON) {
+            onRadioPowerOn(inst_id);
+        }
+    }
+}
+
+/** Returns SIM_NOT_READY on error */
+static SIM_Status
+getSIMStatus(int inst_id)
+{
+    ATResponse *p_response = NULL;
+    int err;
+    int ret;
+    char *cpinLine;
+    char *cpinResult;
+
+    ALOGD("getSIMStatus(). sState[%d]: %d",inst_id, sState[inst_id]);
+    if (sState[inst_id] == RADIO_STATE_OFF || sState[inst_id] == RADIO_STATE_UNAVAILABLE) {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+
+    err = at_send_command_singleline("AT+CPIN?", "+CPIN:", &p_response);
+
+    if (err != 0) {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+
+    switch (at_get_cme_error(p_response)) {
+        case CME_SUCCESS:
+            break;
+
+        case CME_SIM_NOT_INSERTED:
+            ret = SIM_ABSENT;
+            goto done;
+
+        default:
+            ret = SIM_NOT_READY;
+            goto done;
+    }
+
+    /* CPIN? has succeeded, now look at the result */
+
+    cpinLine = p_response->p_intermediates->line;
+    err = at_tok_start (&cpinLine);
+
+    if (err < 0) {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+
+    err = at_tok_nextstr(&cpinLine, &cpinResult);
+
+    if (err < 0) {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+
+    if (0 == strcmp (cpinResult, "SIM PIN")) {
+        ret = SIM_PIN;
+        goto done;
+    } else if (0 == strcmp (cpinResult, "SIM PUK")) {
+        ret = SIM_PUK;
+        goto done;
+    } else if (0 == strcmp (cpinResult, "PH-NET PIN")) {
+        return SIM_NETWORK_PERSONALIZATION;
+    } else if (0 != strcmp (cpinResult, "READY"))  {
+        /* we're treating unsupported lock types as "sim absent" */
+        ret = SIM_ABSENT;
+        goto done;
+    }
+
+    at_response_free(p_response);
+    p_response = NULL;
+    cpinResult = NULL;
+
+    //ret = SIM_READY;
+    ret = mySimState[inst_id];
+
+done:
+    at_response_free(p_response);
+    return ret;
+}
+
+
+/**
+ * Get the current card status.
+ *
+ * This must be freed using freeCardStatus.
+ * @return: On success returns RIL_E_SUCCESS
+ */
+static int getCardStatus(int inst_id, RIL_CardStatus_v6 **pp_card_status) {
+    static RIL_AppStatus app_status_array[] = {
+        // SIM_ABSENT = 0
+        { RIL_APPTYPE_UNKNOWN, RIL_APPSTATE_UNKNOWN, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // SIM_NOT_READY = 1
+        { RIL_APPTYPE_SIM, RIL_APPSTATE_DETECTED, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // SIM_READY = 2
+        { RIL_APPTYPE_SIM, RIL_APPSTATE_READY, RIL_PERSOSUBSTATE_READY,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // SIM_PIN = 3
+        { RIL_APPTYPE_SIM, RIL_APPSTATE_PIN, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN },
+        // SIM_PUK = 4
+        { RIL_APPTYPE_SIM, RIL_APPSTATE_PUK, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_BLOCKED, RIL_PINSTATE_UNKNOWN },
+        // SIM_NETWORK_PERSONALIZATION = 5
+        { RIL_APPTYPE_SIM, RIL_APPSTATE_SUBSCRIPTION_PERSO, RIL_PERSOSUBSTATE_SIM_NETWORK,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN },
+        // RUIM_ABSENT = 6
+        { RIL_APPTYPE_UNKNOWN, RIL_APPSTATE_UNKNOWN, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // RUIM_NOT_READY = 7
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_DETECTED, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // RUIM_READY = 8
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_READY, RIL_PERSOSUBSTATE_READY,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // RUIM_PIN = 9
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_PIN, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN },
+        // RUIM_PUK = 10
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_PUK, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_BLOCKED, RIL_PINSTATE_UNKNOWN },
+        // RUIM_NETWORK_PERSONALIZATION = 11
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_SUBSCRIPTION_PERSO, RIL_PERSOSUBSTATE_SIM_NETWORK,
+           NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN }
+    };
+    RIL_CardState card_state;
+    int num_apps;
+
+    int sim_status = getSIMStatus(inst_id);
+
+    if (sim_status == SIM_ABSENT) {
+        card_state = RIL_CARDSTATE_ABSENT;
+        num_apps = 0;
+    } else {
+        card_state = RIL_CARDSTATE_PRESENT;
+        // Only one app here. get sim status for app index : 0.
+        if (isAppReady(inst_id, 0) == 0) {
+            sim_status = SIM_NOT_READY;
+        }
+        num_apps = 1;
+    }
+
+    // Allocate and initialize base card status.
+    RIL_CardStatus_v6 *p_card_status = malloc(sizeof(RIL_CardStatus_v6));
+    p_card_status->card_state = card_state;
+    p_card_status->universal_pin_state = RIL_PINSTATE_UNKNOWN;
+    p_card_status->gsm_umts_subscription_app_index = RIL_CARD_MAX_APPS;
+    p_card_status->cdma_subscription_app_index = RIL_CARD_MAX_APPS;
+    p_card_status->ims_subscription_app_index = RIL_CARD_MAX_APPS;
+    p_card_status->num_applications = num_apps;
+
+    // Initialize application status
+    int i;
+    for (i = 0; i < RIL_CARD_MAX_APPS; i++) {
+        p_card_status->applications[i] = app_status_array[SIM_ABSENT];
+    }
+
+    // Pickup the appropriate application status
+    // that reflects sim_status for gsm.
+    if (num_apps != 0) {
+        // Only support one app, gsm
+        p_card_status->num_applications = 1;
+//        TODO: Multiple application support
+        p_card_status->gsm_umts_subscription_app_index = 0;
+
+        // Get the correct app status
+        p_card_status->applications[0] = app_status_array[sim_status];
+    }
+
+    *pp_card_status = p_card_status;
+    return RIL_E_SUCCESS;
+}
+
+/**
+ * Free the card status returned by getCardStatus
+ */
+static void freeCardStatus(RIL_CardStatus_v6 *p_card_status) {
+    free(p_card_status);
+}
+
+/**
+ * SIM ready means any commands that access the SIM will work, including:
+ *  AT+CPIN, AT+CSMS, AT+CNMI, AT+CRSM
+ *  (all SMS-related commands)
+ */
+
+static void pollSIMState (void *param)
+{
+    ATResponse *p_response;
+    int ret;
+    int inst_id = (int)param;
+
+    if (sState[inst_id] != RADIO_STATE_SIM_NOT_READY) {
+        // no longer valid to poll
+        return;
+    }
+
+    switch(getSIMStatus(inst_id)) {
+        case SIM_ABSENT:
+        case SIM_PIN:
+        case SIM_PUK:
+        case SIM_NETWORK_PERSONALIZATION:
+        default:
+            setRadioState(inst_id, RADIO_STATE_SIM_LOCKED_OR_ABSENT);
+        return;
+
+        case SIM_NOT_READY:
+            RIL_requestTimedCallback (inst_id, pollSIMState, NULL, &TIMEVAL_SIMPOLL);
+        return;
+
+        case SIM_READY:
+            setRadioState(inst_id, RADIO_STATE_SIM_READY);
+        return;
+    }
+}
+
+/** returns 1 if on, 0 if off, and -1 on error */
+static int isRadioOn()
+{
+    ATResponse *p_response = NULL;
+    int err;
+    char *line;
+    char ret;
+
+    err = at_send_command_singleline("AT+CFUN?", "+CFUN:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        // assume radio is off
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextbool(&line, &ret);
+    if (err < 0) goto error;
+
+    at_response_free(p_response);
+
+    return (int)ret;
+
+error:
+
+    at_response_free(p_response);
+    return -1;
+}
+
+/**
+ * Initialize everything that can be configured while we're still in
+ * AT+CFUN=0
+ */
+static void initializeCallback(void *param)
+{
+    ATResponse *p_response = NULL;
+    int err;
+
+    int inst_id = (int)param;
+
+    ALOGD("initializeCallback(%d)", inst_id);
+
+    setRadioState (inst_id, RADIO_STATE_OFF);
+
+    at_handshake();
+
+    /* note: we don't check errors here. Everything important will
+       be handled in onATTimeout and onATReaderClosed */
+
+    /*  atchannel is tolerant of echo but it must */
+    /*  have verbose result codes */
+    at_send_command("ATE0Q0V1", NULL);
+
+    /*  No auto-answer */
+    at_send_command("ATS0=0", NULL);
+
+    /*  Extended errors */
+    at_send_command("AT+CMEE=1", NULL);
+
+    /*  Network registration events */
+    err = at_send_command("AT+CREG=2", &p_response);
+
+    /* some handsets -- in tethered mode -- don't support CREG=2 */
+    if (err < 0 || p_response->success == 0) {
+        at_send_command("AT+CREG=1", NULL);
+    }
+
+    at_response_free(p_response);
+
+    /*  GPRS registration events */
+    at_send_command("AT+CGREG=1", NULL);
+
+    /*  Call Waiting notifications */
+    at_send_command("AT+CCWA=1", NULL);
+
+    /*  Alternating voice/data off */
+    at_send_command("AT+CMOD=0", NULL);
+
+    /*  Not muted */
+    at_send_command("AT+CMUT=0", NULL);
+
+    /*  +CSSU unsolicited supp service notifications */
+    at_send_command("AT+CSSN=0,1", NULL);
+
+    /*  no connected line identification */
+    at_send_command("AT+COLP=0", NULL);
+
+    /*  HEX character set */
+    at_send_command("AT+CSCS=\"HEX\"", NULL);
+
+    /*  USSD unsolicited */
+    at_send_command("AT+CUSD=1", NULL);
+
+    /*  Enable +CGEV GPRS event notifications, but don't buffer */
+    at_send_command("AT+CGEREP=1,0", NULL);
+
+    /*  SMS PDU mode */
+    at_send_command("AT+CMGF=0", NULL);
+
+#ifdef USE_TI_COMMANDS
+
+    at_send_command("AT%CPI=3", NULL);
+
+    /*  TI specific -- notifications when SMS is ready (currently ignored) */
+    at_send_command("AT%CSTAT=1", NULL);
+
+#endif /* USE_TI_COMMANDS */
+
+
+    /* assume radio is off on error */
+    if (isRadioOn() > 0) {
+        setRadioState (inst_id, RADIO_STATE_ON);
+    }
+}
+
+static void waitForClose()
+{
+    pthread_mutex_lock(&s_state_mutex);
+
+    while (s_closed == 0) {
+        pthread_cond_wait(&s_state_cond, &s_state_mutex);
+    }
+
+    pthread_mutex_unlock(&s_state_mutex);
+}
+
+static void handleMyUnsolProactiveCommands(char *myUnsol) {
+    char *unsolCmd;
+    int err = at_tok_start(&myUnsol);
+    if (err < 0) {
+        ALOGE("Error ::: bailing out %d\n ", err);
+    }
+    at_tok_nextstr(&myUnsol, &unsolCmd);
+    ALOGD("--jiju--: unsolCmd = %s", unsolCmd);
+
+    if (strcmp(unsolCmd, "MY_UNSOL_CARD_REMOVED_0") == 0) {
+        ALOGD("--jiju--: MY_UNSOL: Card removed : 0");
+        mySimState[0] = SIM_ABSENT;
+        RIL_onUnsolicitedResponse(0, RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
+    } else if (strcmp(unsolCmd, "MY_UNSOL_CARD_INSERTED_0") == 0) {
+        ALOGD("--jiju--: MY_UNSOL: Card inserted : 0");
+        //mySimState[0] = SIM_READY;
+        mySimState[0] = SIM_NOT_READY;
+        RIL_onUnsolicitedResponse(0, RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
+    } else if (strcmp(unsolCmd, "MY_UNSOL_SUB_DEACTIVATED_0") == 0) {
+        ALOGD("--jiju--: MY_UNSOL: Subscription deactivated : 0");
+        int response = 0; // DEACTIVATED
+        RIL_onUnsolicitedResponse (
+            0, RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED,
+            &response, sizeof(response));
+        if (myDds == 0) {
+            ALOGD("--jiju--: sending all data disconnected on SUB: = %d", myDds);
+            RIL_onUnsolicitedResponse(myDds, RIL_UNSOL_DATA_CALL_LIST_CHANGED, NULL, 0);
+        }
+    } else if (strcmp(unsolCmd, "MY_UNSOL_DATA_DISCONNECTED") == 0) {
+        if (myDds != -1) {
+            RIL_onUnsolicitedResponse(myDds, RIL_UNSOL_DATA_CALL_LIST_CHANGED, NULL, 0);
+        }
+    } else if (strcmp(unsolCmd, "MY_UNSOL_RADIO_OFF") == 0) {
+        sState[0] = RADIO_STATE_OFF;
+        RIL_onUnsolicitedResponse (0, RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
+                                    NULL, 0);
+    } else {
+        ALOGD("--jiju--: MY_UNSOL: NONE!");
+    }
+}
+
+/**
+ * Called by atchannel when an unsolicited line appears
+ * This is called on atchannel's reader thread. AT commands may
+ * not be issued here
+ */
+static void onUnsolicited (const char *s, const char *sms_pdu)
+{
+    char *line = NULL, *p;
+    int err;
+    int inst_id = REF_RIL_FIRST_INSTANCE_ID;
+
+    /* Ignore unsolicited responses until we're initialized.
+     * This is OK because the RIL library will poll for initial state
+     */
+    if (sState[inst_id] == RADIO_STATE_UNAVAILABLE) {
+        return;
+    }
+
+    if (strStartsWith(s, "%CTZV:")) {
+        /* TI specific -- NITZ time */
+        char *response;
+
+        line = p = strdup(s);
+        at_tok_start(&p);
+
+        err = at_tok_nextstr(&p, &response);
+
+        free(line);
+        if (err != 0) {
+            ALOGE("invalid NITZ line %s\n", s);
+        } else {
+            RIL_onUnsolicitedResponse (
+                inst_id,
+                RIL_UNSOL_NITZ_TIME_RECEIVED,
+                response, strlen(response));
+        }
+    } else if (strStartsWith(s,"+CRING:")
+                || strStartsWith(s,"RING")
+                || strStartsWith(s,"NO CARRIER")
+                || strStartsWith(s,"+CCWA")
+    ) {
+        // Workarround for simulating the incomming call on instance 1 and 2
+        // Alternate unsol call state changed will be sent to each instances.
+        if (!mo_call) {
+            if (isMultiSimEnabled()) {
+                if (strStartsWith(s,"RING")) {
+                    mt_ring_counter++;
+                    if (mt_ring_counter % 2 == 0) {
+                        inst_id = REF_RIL_FIRST_INSTANCE_ID;
+                    } else {
+                        inst_id = REF_RIL_SECOND_INSTANCE_ID;
+                    }
+                    ALOGE("Incoming Ring. Sending UNSOL_RESPONSE_CALL_STATE_CHANGED on %d", inst_id);
+                }
+            }
+
+            RIL_onUnsolicitedResponse (
+                    inst_id,
+                    RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED,
+                    NULL, 0);
+        }
+#ifdef WORKAROUND_FAKE_CGEV
+        RIL_requestTimedCallback (inst_id, onDataCallListChanged, (void *)inst_id, NULL); //TODO use new function
+#endif /* WORKAROUND_FAKE_CGEV */
+    } else if (strStartsWith(s,"+CREG:")
+                || strStartsWith(s,"+CGREG:")
+    ) {
+        RIL_onUnsolicitedResponse (
+            inst_id,
+            RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED,
+            NULL, 0);
+#ifdef WORKAROUND_FAKE_CGEV
+        RIL_requestTimedCallback (inst_id, onDataCallListChanged, NULL, NULL);
+#endif /* WORKAROUND_FAKE_CGEV */
+    } else if (strStartsWith(s, "+CMT:")) {
+        // Workarround to simulate the incomming SMS on instance 1 and 2
+        // Alternate unsol new sms will be sent to each of the instances.
+        if (isMultiSimEnabled()) {
+            if (line_sms == 0) {
+                inst_id = REF_RIL_FIRST_INSTANCE_ID;
+                line_sms = 1;
+            } else {
+                inst_id = REF_RIL_SECOND_INSTANCE_ID;
+                line_sms = 0;
+            }
+        }
+
+        RIL_onUnsolicitedResponse (
+            inst_id,
+            RIL_UNSOL_RESPONSE_NEW_SMS,
+            sms_pdu, strlen(sms_pdu));
+    } else if (strStartsWith(s, "+CDS:")) {
+        RIL_onUnsolicitedResponse (
+            inst_id,
+            RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT,
+            sms_pdu, strlen(sms_pdu));
+    } else if (strStartsWith(s, "+CGEV:")) {
+        /* Really, we can ignore NW CLASS and ME CLASS events here,
+         * but right now we don't since extranous
+         * RIL_UNSOL_DATA_CALL_LIST_CHANGED calls are tolerated
+         */
+        /* can't issue AT commands here -- call on main thread */
+        RIL_requestTimedCallback (inst_id, onDataCallListChanged, (void *)inst_id, NULL);
+#ifdef WORKAROUND_FAKE_CGEV
+    } else if (strStartsWith(s, "+CME ERROR: 150")) {
+        RIL_requestTimedCallback (inst_id, onDataCallListChanged, (void *)inst_id, NULL);
+#endif /* WORKAROUND_FAKE_CGEV */
+    } else if(strStartsWith(s,"+MYUNSOL:")) {
+        char *myUnsol = NULL;
+        ALOGD("--jiju--: s = %s", s);
+        myUnsol = strdup(s);
+        handleMyUnsolProactiveCommands(myUnsol);
+    }
+}
+
+/* Called on command or reader thread */
+static void onATReaderClosed()
+{
+    ALOGI("AT channel closed\n");
+    at_close();
+    s_closed = 1;
+
+    setRadioState (REF_RIL_FIRST_INSTANCE_ID, RADIO_STATE_UNAVAILABLE);
+    if (isMultiSimEnabled()) {
+        setRadioState (REF_RIL_SECOND_INSTANCE_ID, RADIO_STATE_UNAVAILABLE);
+    }
+}
+
+/* Called on command thread */
+static void onATTimeout()
+{
+    ALOGI("AT channel timeout; closing\n");
+    at_close();
+
+    s_closed = 1;
+
+    /* FIXME cause a radio reset here */
+
+    setRadioState (REF_RIL_FIRST_INSTANCE_ID, RADIO_STATE_UNAVAILABLE);
+    if (isMultiSimEnabled()) {
+        setRadioState (REF_RIL_SECOND_INSTANCE_ID, RADIO_STATE_UNAVAILABLE);
+    }
+}
+
+static void usage(char *s)
+{
+#ifdef RIL_SHLIB
+    fprintf(stderr, "reference-ril requires: -p <tcp port> or -d /dev/tty_device\n");
+#else
+    fprintf(stderr, "usage: %s [-p <tcp port>] [-d /dev/tty_device]\n", s);
+    exit(-1);
+#endif
+}
+
+static int isMultiSimEnabled()
+{
+    int enabled = 0;
+    char prop_val[PROPERTY_VALUE_MAX];
+    int multisim_config_len = property_get("persist.multisim.config", prop_val, "0");
+    if (multisim_config_len > 0) {
+        if ((strncmp(prop_val, DSDS_PROPERTY, DSDS_PROPERTY_LENGTH) == 0
+                    && multisim_config_len == DSDS_PROPERTY_LENGTH)
+                || (strncmp(prop_val, DSDA_PROPERTY, DSDA_PROPERTY_LENGTH) == 0
+                    && multisim_config_len == DSDA_PROPERTY_LENGTH)) {
+            enabled = 1;
+        }
+    }
+    ALOGD("REF_RIL: isMultiSimEnabled: prop_val = %s enabled = %d", prop_val, enabled);
+    return enabled;
+}
+
+static void *
+mainLoop(void *param)
+{
+    int fd;
+    int ret;
+
+    int inst_id = (int)param;
+
+    ALOGD("mainLoop(%d)", inst_id);
+
+    AT_DUMP("== ", "entering mainLoop()", -1 );
+    at_set_on_reader_closed(onATReaderClosed);
+    at_set_on_timeout(onATTimeout);
+
+    for (;;) {
+        // Open the socket and initialize the at channel only once.
+        if (inst_id == REF_RIL_FIRST_INSTANCE_ID) {
+        fd = -1;
+        while  (fd < 0) {
+            if (s_port > 0) {
+                fd = socket_loopback_client(s_port, SOCK_STREAM);
+            } else if (s_device_socket) {
+                if (!strcmp(s_device_path, "/dev/socket/qemud")) {
+                    /* Before trying to connect to /dev/socket/qemud (which is
+                     * now another "legacy" way of communicating with the
+                     * emulator), we will try to connecto to gsm service via
+                     * qemu pipe. */
+                    fd = qemu_pipe_open("qemud:gsm");
+                    if (fd < 0) {
+                        /* Qemu-specific control socket */
+                        fd = socket_local_client( "qemud",
+                                                  ANDROID_SOCKET_NAMESPACE_RESERVED,
+                                                  SOCK_STREAM );
+                        if (fd >= 0 ) {
+                            char  answer[2];
+
+                            if ( write(fd, "gsm", 3) != 3 ||
+                                 read(fd, answer, 2) != 2 ||
+                                 memcmp(answer, "OK", 2) != 0)
+                            {
+                                close(fd);
+                                fd = -1;
+                            }
+                       }
+                    }
+                }
+                else
+                    fd = socket_local_client( s_device_path,
+                                            ANDROID_SOCKET_NAMESPACE_FILESYSTEM,
+                                            SOCK_STREAM );
+            } else if (s_device_path != NULL) {
+                fd = open (s_device_path, O_RDWR);
+                if ( fd >= 0 && !memcmp( s_device_path, "/dev/ttyS", 9 ) ) {
+                    /* disable echo on serial ports */
+                    struct termios  ios;
+                    tcgetattr( fd, &ios );
+                    ios.c_lflag = 0;  /* disable ECHO, ICANON, etc... */
+                    tcsetattr( fd, TCSANOW, &ios );
+                }
+            }
+
+            if (fd < 0) {
+                perror ("opening AT interface. retrying...");
+                sleep(10);
+                /* never returns */
+            }
+        }
+
+        s_closed = 0;
+        ret = at_open(fd, onUnsolicited);
+
+        if (ret < 0) {
+            ALOGE ("AT error %d on at_open\n", ret);
+            return 0;
+        }
+        }
+
+        RIL_requestTimedCallback(inst_id, initializeCallback, (void *)inst_id, &TIMEVAL_0);
+
+        // Give initializeCallback a chance to dispatched, since
+        // we don't presently have a cancellation mechanism
+        sleep(1);
+
+        waitForClose();
+        ALOGI("Re-opening after close");
+    }
+}
+
+#ifdef RIL_SHLIB
+
+pthread_t s_tid_mainloop_0;
+pthread_t s_tid_mainloop_1;
+
+const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **argv)
+{
+    int ret;
+    int fd = -1;
+    int opt;
+    pthread_attr_t attr;
+    int inst_id = REF_RIL_FIRST_INSTANCE_ID;
+
+    optind = 1;
+
+    while ( -1 != (opt = getopt(argc, argv, "p:d:s:c:"))) {
+        switch (opt) {
+            case 'p':
+                s_port = atoi(optarg);
+                if (s_port == 0) {
+                    usage(argv[0]);
+                    return NULL;
+                }
+                ALOGI("Opening loopback port %d\n", s_port);
+            break;
+
+            case 'd':
+                s_device_path = optarg;
+                ALOGI("Opening tty device %s\n", s_device_path);
+            break;
+
+            case 's':
+                s_device_path   = optarg;
+                s_device_socket = 1;
+                ALOGI("Opening socket %s\n", s_device_path);
+            break;
+
+            case 'c':
+                inst_id = atoi(optarg);
+                ALOGI("instance Id : %d", inst_id);
+            break;
+
+            default:
+                usage(argv[0]);
+                return NULL;
+        }
+    }
+
+    s_rilenv[inst_id] = env;
+    ALOGD("RIL_Init : inst_id = %d", inst_id);
+
+    if (s_port < 0 && s_device_path == NULL) {
+        usage(argv[0]);
+        return NULL;
+    }
+
+    pthread_attr_init (&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    // Create mainLoop thread for instance 1 or 2.
+    if (inst_id == REF_RIL_FIRST_INSTANCE_ID) {
+        ret = pthread_create(&s_tid_mainloop_0, &attr, mainLoop, (void *)inst_id);
+    } else {
+        ret = pthread_create(&s_tid_mainloop_1, &attr, mainLoop, (void *)inst_id);
+    }
+
+    return &s_callbacks[inst_id];
+}
+#else /* RIL_SHLIB */
+int main (int argc, char **argv)
+{
+    int ret;
+    int fd = -1;
+    int opt;
+
+    while ( -1 != (opt = getopt(argc, argv, "p:d:"))) {
+        switch (opt) {
+            case 'p':
+                s_port = atoi(optarg);
+                if (s_port == 0) {
+                    usage(argv[0]);
+                }
+                ALOGI("Opening loopback port %d\n", s_port);
+            break;
+
+            case 'd':
+                s_device_path = optarg;
+                ALOGI("Opening tty device %s\n", s_device_path);
+            break;
+
+            case 's':
+                s_device_path   = optarg;
+                s_device_socket = 1;
+                ALOGI("Opening socket %s\n", s_device_path);
+            break;
+
+            default:
+                usage(argv[0]);
+        }
+    }
+
+    if (s_port < 0 && s_device_path == NULL) {
+        usage(argv[0]);
+    }
+
+    RIL_register(&s_callbacks);
+
+    mainLoop(NULL);
+
+    return 0;
+}
+
+#endif /* RIL_SHLIB */
diff --git a/reference-ril/reference-ril.c b/reference-ril/reference-ril.c
index 81fbeee..11bebe1 100644
--- a/reference-ril/reference-ril.c
+++ b/reference-ril/reference-ril.c
@@ -1,8 +1,10 @@
 /* //device/system/reference-ril/reference-ril.c
 **
-** Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
-** Not a Contribution
-** Copyright 2006 The Android Open Source Project
+** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2012, The Linux Foundation. All rights reserved.
+**
+** Not a Contribution, Apache license notifications and license are retained
+** for attribution purposes only.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -18,7 +20,6 @@
 */
 
 #include <telephony/ril_cdma_sms.h>
-#include <telephony/librilutils.h>
 #include <stdio.h>
 #include <assert.h>
 #include <string.h>
@@ -40,10 +41,14 @@
 
 #include "ril.h"
 #include "hardware/qemu_pipe.h"
+#include <cutils/properties.h>
+
 
 #define LOG_TAG "RIL"
 #include <utils/Log.h>
 
+#include <telephony/ril_log.h>
+
 #define MAX_AT_RESPONSE 0x1000
 
 /* pathname returned from RIL_REQUEST_SETUP_DATA_CALL / RIL_REQUEST_SETUP_DEFAULT_PDP */
@@ -201,7 +206,6 @@ static pthread_cond_t s_state_cond = PTHREAD_COND_INITIALIZER;
 static int s_port = -1;
 static const char * s_device_path = NULL;
 static int          s_device_socket = 0;
-const char * ril_inst_id = NULL;
 
 /* trigger change to this with s_state_cond */
 static int s_closed = 0;
@@ -235,12 +239,6 @@ static int s_repollCallsCount = 0;
 static int s_expectAnswer = 0;
 #endif /* WORKAROUND_ERRONEOUS_ANSWER */
 
-static int s_cell_info_rate_ms = INT_MAX;
-static int s_mcc = 0;
-static int s_mnc = 0;
-static int s_lac = 0;
-static int s_cid = 0;
-
 static void pollSIMState (void *param);
 static void setRadioState(RIL_RadioState newState);
 static void setRadioTechnology(ModemInfo *mdm, int newtech);
@@ -321,7 +319,7 @@ static int callFromCLCCLine(char *line, RIL_Call *p_call)
     return 0;
 
 error:
-    RLOGE("invalid CLCC line\n");
+    ALOGE("invalid CLCC line\n");
     return -1;
 }
 
@@ -437,9 +435,7 @@ static void requestOrSendDataCallList(RIL_Token *t)
     int i;
     for (i = 0; i < n; i++) {
         responses[i].status = -1;
-#ifndef HCRADIO
         responses[i].suggestedRetryTime = -1;
-#endif
         responses[i].cid = -1;
         responses[i].active = -1;
         responses[i].type = "";
@@ -632,7 +628,7 @@ static void requestQueryNetworkSelectionMode(
     return;
 error:
     at_response_free(p_response);
-    RLOGE("requestQueryNetworkSelectionMode must never return error when radio is on");
+    ALOGE("requestQueryNetworkSelectionMode must never return error when radio is on");
     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
 }
 
@@ -733,7 +729,7 @@ static void requestGetCurrentCalls(void *data, size_t datalen, RIL_Token t)
                     && p_calls[i].state == RIL_CALL_ACTIVE
                     && s_repollCallsCount < REPOLL_CALLS_COUNT_MAX
             ) {
-                RLOGI(
+                ALOGI(
                     "Hit WORKAROUND_ERRONOUS_ANSWER case."
                     " Repoll count: %d\n", s_repollCallsCount);
                 s_repollCallsCount++;
@@ -766,13 +762,14 @@ error:
     at_response_free(p_response);
 }
 
+#ifdef RIL_VARIANT_LEGACY
 static void setUiccSubscription(int request, void *data, size_t datalen, RIL_Token t)
 {
     RIL_SelectUiccSub *uiccSubscrInfo;
     uiccSubscrInfo = (RIL_SelectUiccSub *)data;
     int response = 0;
 
-    RLOGD("setUiccSubscription() RILD=%s instance.", ril_inst_id);
+    RLOGD("setUiccSubscription()");
     // TODO: DSDS: Need to implement this.
     // workaround: send success for now.
     RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
@@ -795,6 +792,7 @@ static void setDataSubscription(int request, void *data, size_t datalen, RIL_Tok
     // workaround: send success for now.
     RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
 }
+#endif
 
 static void requestDial(void *data, size_t datalen, RIL_Token t)
 {
@@ -903,7 +901,7 @@ static void requestSignalStrength(void *data, size_t datalen, RIL_Token t)
     return;
 
 error:
-    RLOGE("requestSignalStrength must never return an error when radio is on");
+    ALOGE("requestSignalStrength must never return an error when radio is on");
     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
     at_response_free(p_response);
 }
@@ -929,7 +927,7 @@ static void requestSetPreferredNetworkType( int request, void *data,
     int err;
     int32_t preferred = net2pmask[value];
 
-    RLOGD("requestSetPreferredNetworkType: current: %x. New: %x", PREFERRED_NETWORK(sMdmInfo), preferred);
+    ALOGD("requestSetPreferredNetworkType: current: %x. New: %x", PREFERRED_NETWORK(sMdmInfo), preferred);
     if (!networkModePossible(sMdmInfo, value)) {
         RIL_onRequestComplete(t, RIL_E_MODE_NOT_SUPPORTED, NULL, 0);
         return;
@@ -939,10 +937,10 @@ static void requestSetPreferredNetworkType( int request, void *data,
         return;
     }
     old = PREFERRED_NETWORK(sMdmInfo);
-    RLOGD("old != preferred: %d", old != preferred);
+    ALOGD("old != preferred: %d", old != preferred);
     if (old != preferred) {
         asprintf(&cmd, "AT+CTEC=%d,\"%x\"", current, preferred);
-        RLOGD("Sending command: <%s>", cmd);
+        ALOGD("Sending command: <%s>", cmd);
         err = at_send_command_singleline(cmd, "+CTEC:", &p_response);
         free(cmd);
         if (err || !p_response->success) {
@@ -984,7 +982,7 @@ static void requestGetPreferredNetworkType(int request, void *data,
                     return;
                 }
             }
-            RLOGE("Unknown preferred mode received from modem: %d", preferred);
+            ALOGE("Unknown preferred mode received from modem: %d", preferred);
             RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
             break;
     }
@@ -1066,7 +1064,7 @@ static void requestCdmaDeviceIdentity(int request, void *data,
 
     return;
 error:
-    RLOGE("requestCdmaDeviceIdentity must never return an error when radio is on");
+    ALOGE("requestCdmaDeviceIdentity must never return an error when radio is on");
     at_response_free(p_response);
     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
 }
@@ -1113,7 +1111,7 @@ static void requestCdmaSetSubscriptionSource(int request, void *data,
     char *cmd = NULL;
 
     if (!ss || !datalen) {
-        RLOGE("RIL_REQUEST_CDMA_SET_SUBSCRIPTION without data!");
+        ALOGE("RIL_REQUEST_CDMA_SET_SUBSCRIPTION without data!");
         RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
         return;
     }
@@ -1160,7 +1158,7 @@ static void requestCdmaSubscription(int request, void *data,
 
     return;
 error:
-    RLOGE("requestRegistrationState must never return an error when radio is on");
+    ALOGE("requestRegistrationState must never return an error when radio is on");
     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
 }
 
@@ -1223,7 +1221,7 @@ static int parseRegistrationState(char *str, int *type, int *items, int **respon
     int count = 3;
     int commas;
 
-    RLOGD("parseRegistrationState. Parsing: %s",str);
+    ALOGD("parseRegistrationState. Parsing: %s",str);
     err = at_tok_start(&line);
     if (err < 0) goto error;
 
@@ -1311,8 +1309,6 @@ static int parseRegistrationState(char *str, int *type, int *items, int **respon
         default:
             goto error;
     }
-    s_lac = resp[1];
-    s_cid = resp[2];
     if (response)
         *response = resp;
     if (items)
@@ -1341,7 +1337,7 @@ static void requestRegistrationState(int request, void *data,
     int count = 3;
     int type, startfrom;
 
-    RLOGD("requestRegistrationState");
+    ALOGD("requestRegistrationState");
     if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE) {
         cmd = "AT+CREG?";
         prefix = "+CREG:";
@@ -1372,7 +1368,7 @@ static void requestRegistrationState(int request, void *data,
      * the 5th and 6th byte(s) are optional.
      */
     if (is3gpp2(type) == 1) {
-        RLOGD("registration state type: 3GPP2");
+        ALOGD("registration state type: 3GPP2");
         // TODO: Query modem
         startfrom = 3;
         if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE) {
@@ -1392,7 +1388,7 @@ static void requestRegistrationState(int request, void *data,
             asprintf(&responseStr[3], "8");   // Available data radio technology
       }
     } else { // type == RADIO_TECH_3GPP
-        RLOGD("registration state type: 3GPP");
+        ALOGD("registration state type: 3GPP");
         startfrom = 0;
         asprintf(&responseStr[1], "%x", registration[1]);
         asprintf(&responseStr[2], "%x", registration[2]);
@@ -1436,7 +1432,7 @@ error:
         free(responseStr);
         responseStr = NULL;
     }
-    RLOGE("requestRegistrationState must never return an error when radio is on");
+    ALOGE("requestRegistrationState must never return an error when radio is on");
     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
     at_response_free(p_response);
 }
@@ -1495,12 +1491,6 @@ static void requestOperator(void *data, size_t datalen, RIL_Token t)
 
         err = at_tok_nextstr(&line, &(response[i]));
         if (err < 0) goto error;
-        // Simple assumption that mcc and mnc are 3 digits each
-        if (strlen(response[i]) == 6) {
-            if (sscanf(response[i], "%3d%3d", &s_mcc, &s_mnc) != 2) {
-                RLOGE("requestOperator expected mccmnc to be 6 decimal digits");
-            }
-        }
     }
 
     if (i != 3) {
@@ -1513,7 +1503,7 @@ static void requestOperator(void *data, size_t datalen, RIL_Token t)
 
     return;
 error:
-    RLOGE("requestOperator must not return error when radio is on");
+    ALOGE("requestOperator must not return error when radio is on");
     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
     at_response_free(p_response);
 }
@@ -1524,12 +1514,12 @@ static void requestCdmaSendSMS(void *data, size_t datalen, RIL_Token t)
     RIL_SMS_Response response;
     RIL_CDMA_SMS_Message* rcsm;
 
-    RLOGD("requestCdmaSendSMS datalen=%d, sizeof(RIL_CDMA_SMS_Message)=%d",
+    ALOGD("requestCdmaSendSMS datalen=%d, sizeof(RIL_CDMA_SMS_Message)=%d",
             datalen, sizeof(RIL_CDMA_SMS_Message));
 
     // verify data content to test marshalling/unmarshalling:
     rcsm = (RIL_CDMA_SMS_Message*)data;
-    RLOGD("TeleserviceID=%d, bIsServicePresent=%d, \
+    ALOGD("TeleserviceID=%d, bIsServicePresent=%d, \
             uServicecategory=%d, sAddress.digit_mode=%d, \
             sAddress.Number_mode=%d, sAddress.number_type=%d, ",
             rcsm->uTeleserviceID,  rcsm->bIsServicePresent,
@@ -1563,7 +1553,7 @@ static void requestSendSMS(void *data, size_t datalen, RIL_Token t)
     ATResponse *p_response = NULL;
 
     memset(&response, 0, sizeof(response));
-    RLOGD("requestSendSMS datalen =%d", datalen);
+    ALOGD("requestSendSMS datalen =%d", datalen);
 
     if (s_ims_gsm_fail != 0) goto error;
     if (s_ims_gsm_retry != 0) goto error2;
@@ -1602,7 +1592,7 @@ error2:
     RIL_onRequestComplete(t, RIL_E_SMS_SEND_FAIL_RETRY, &response, sizeof(response));
     at_response_free(p_response);
     return;
-    }
+}
 
 static void requestImsSendSMS(void *data, size_t datalen, RIL_Token t)
 {
@@ -1611,7 +1601,7 @@ static void requestImsSendSMS(void *data, size_t datalen, RIL_Token t)
 
     memset(&response, 0, sizeof(response));
 
-    RLOGD("requestImsSendSMS: datalen=%d, "
+    ALOGD("requestImsSendSMS: datalen=%d, "
         "registered=%d, service=%d, format=%d, ims_perm_fail=%d, "
         "ims_retry=%d, gsm_fail=%d, gsm_retry=%d",
         datalen, s_ims_registered, s_ims_services, s_ims_format,
@@ -1636,7 +1626,7 @@ static void requestImsSendSMS(void *data, size_t datalen, RIL_Token t)
                 datalen - sizeof(RIL_RadioTechnologyFamily),
                 t);
     } else {
-        RLOGE("requestImsSendSMS invalid format value =%d", p_args->tech);
+        ALOGE("requestImsSendSMS invalid format value =%d", p_args->tech);
     }
 
 error:
@@ -1674,12 +1664,12 @@ static void requestSetupDataCall(void *data, size_t datalen, RIL_Token t)
     int retry = 10;
     const char *pdp_type;
 
-    RLOGD("requesting data connection to APN '%s'", apn);
+    ALOGD("requesting data connection to APN '%s'", apn);
 
     fd = open ("/dev/qmi", O_RDWR);
     if (fd >= 0) { /* the device doesn't exist on the emulator */
 
-        RLOGD("opened the qmi device\n");
+        ALOGD("opened the qmi device\n");
         asprintf(&cmd, "up:%s", apn);
         len = strlen(cmd);
 
@@ -1689,7 +1679,7 @@ static void requestSetupDataCall(void *data, size_t datalen, RIL_Token t)
             } while (written < 0 && errno == EINTR);
 
             if (written < 0) {
-                RLOGE("### ERROR writing to /dev/qmi");
+                ALOGE("### ERROR writing to /dev/qmi");
                 close(fd);
                 goto error;
             }
@@ -1706,25 +1696,25 @@ static void requestSetupDataCall(void *data, size_t datalen, RIL_Token t)
             } while (rlen < 0 && errno == EINTR);
 
             if (rlen < 0) {
-                RLOGE("### ERROR reading from /dev/qmi");
+                ALOGE("### ERROR reading from /dev/qmi");
                 close(fd);
                 goto error;
             } else {
                 status[rlen] = '\0';
-                RLOGD("### status: %s", status);
+                ALOGD("### status: %s", status);
             }
         } while (strncmp(status, "STATE=up", 8) && strcmp(status, "online") && --retry);
 
         close(fd);
 
         if (retry == 0) {
-            RLOGE("### Failed to get data connection up\n");
+            ALOGE("### Failed to get data connection up\n");
             goto error;
         }
 
         qmistatus = system("netcfg rmnet0 dhcp");
 
-        RLOGD("netcfg rmnet0 dhcp: status %d\n", qmistatus);
+        ALOGD("netcfg rmnet0 dhcp: status %d\n", qmistatus);
 
         if (qmistatus < 0) goto error;
 
@@ -1800,14 +1790,14 @@ static void requestGetDataCallProfile(void *data, size_t datalen, RIL_Token t)
         // Adding arbitrary values for the dummy response
         dummyProfile.profileId = i+1;
         dummyProfile.priority = i+10;
-        RLOGI("profileId %d priority %d", dummyProfile.profileId, dummyProfile.priority);
+        ALOGI("profileId %d priority %d", dummyProfile.profileId, dummyProfile.priority);
 
         responseLen += sizeof(RIL_DataCallProfileInfo);
         memcpy(respPtr, (char*)&dummyProfile, sizeof(RIL_DataCallProfileInfo));
         respPtr += sizeof(RIL_DataCallProfileInfo);
     }
 
-    RLOGI("requestGetDataCallProfile():reponseLen:%d, %d profiles", responseLen, i);
+    ALOGI("requestGetDataCallProfile():reponseLen:%d, %d profiles", responseLen, i);
     RIL_onRequestComplete(t, RIL_E_SUCCESS, response, responseLen);
 
     // at_response_free(p_response);
@@ -1826,7 +1816,7 @@ static void requestSMSAcknowledge(void *data, size_t datalen, RIL_Token t)
     } else if (ackSuccess == 0)  {
         err = at_send_command("AT+CNMA=2", NULL);
     } else {
-        RLOGE("unsupported arg to RIL_REQUEST_SMS_ACKNOWLEDGE\n");
+        ALOGE("unsupported arg to RIL_REQUEST_SMS_ACKNOWLEDGE\n");
         goto error;
     }
 
@@ -1974,45 +1964,159 @@ static int techFromModemType(int mdmtype)
     return ret;
 }
 
-static void requestGetCellInfoList(void *data, size_t datalen, RIL_Token t)
+static void  requestSetupQos(void*  data, size_t  datalen, RIL_Token  t)
 {
-    uint64_t curTime = ril_nano_time();
-    RIL_CellInfo ci[1] =
-    {
-        { // ci[0]
-            1, // cellInfoType
-            1, // registered
-            curTime - 1000, // Fake some time in the past
-            { // union CellInfo
-                {  // RIL_CellInfoGsm gsm
-                    {  // gsm.cellIdneityGsm
-                        s_mcc, // mcc
-                        s_mnc, // mnc
-                        s_lac, // lac
-                        s_cid, // cid
-                        0  // psc
-                    },
-                    {  // gsm.signalStrengthGsm
-                        10, // signalStrength
-                        0  // bitErrorRate
-                    }
-                }
-            }
-        }
-    };
+    const char* in_callId = ((const char **)data)[0];
+    const char* in_qosSpec = ((const char **)data)[1];
+
+    const int RESPONSE1_PARAM_NUM = 2;
+    // string length of the largest qosid
+    const int MAX_QOSID_STRLEN = 5;
+    char qosIdStr[MAX_QOSID_STRLEN];
+
+    const char* p_buffer1[RESPONSE1_PARAM_NUM];
+    int buffer_size1 = RESPONSE1_PARAM_NUM*sizeof(char*);
+    const char* out_code = "0";
+    // Static variable that keeps track of the QoS IDs thats given out. For
+    // each QoS request QoS ID is incremented.
+    static int out_qosId = 0;
+
+    p_buffer1[0] = out_code;
+    // increment out_qosId
+    out_qosId++;
+    snprintf(qosIdStr, MAX_QOSID_STRLEN, "%d", out_qosId);
+
+    p_buffer1[1] = qosIdStr;
+
+    ALOGE("requestSetupQos:RIL_onRequestComplete len: %d", buffer_size1);
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_buffer1, buffer_size1);
+
+
+    const int RESPONSE2_PARAM_NUM = 2;
+    const char* p_buffer2[RESPONSE2_PARAM_NUM];
+    int buffer_size2 = RESPONSE2_PARAM_NUM*sizeof(char*);
+
+    // Copy the same qos Id for follow up QoS Ind
+    p_buffer2[0] = qosIdStr;
+    p_buffer2[1] = "0"; // QosInd state as ACTIVATED
 
-    RIL_onRequestComplete(t, RIL_E_SUCCESS, ci, sizeof(ci));
+    ALOGE("requestSetupQos:RIL_onUnsolicitedResponse");
+    RIL_onUnsolicitedResponse ( RIL_UNSOL_QOS_STATE_CHANGED_IND,
+            p_buffer2, buffer_size2);
 }
 
+static void  requestReleaseQos(void*  data, size_t  datalen, RIL_Token  t)
+{
+    const char* in_qosId = ((const char **)data)[0];
+    const int RESPONSE1_PARAM_NUM =1;
+    const char* p_buffer1[RESPONSE1_PARAM_NUM];
+    int buffer_size1 = RESPONSE1_PARAM_NUM*sizeof(char*);
+    const char* out_code = "1";
+    p_buffer1[0] = out_code;
+
+    ALOGE("requestReleaseQos:RIL_onRequestComplete");
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_buffer1, buffer_size1);
+
+    const int RESPONSE2_PARAM_NUM = 2;
+    const char* p_buffer2[RESPONSE2_PARAM_NUM];
+    int buffer_size2 = RESPONSE2_PARAM_NUM*sizeof(char*);
 
-static void requestSetCellInfoListRate(void *data, size_t datalen, RIL_Token t)
+    p_buffer2[0] = in_qosId;
+    p_buffer2[1] = "2"; // User Release
+    ALOGE("requestRelease:RIL_onUnsolicitedResponse");
+    RIL_onUnsolicitedResponse ( RIL_UNSOL_QOS_STATE_CHANGED_IND,
+            p_buffer2, buffer_size2);
+}
+
+static void  requestModifyQos(void*  data, size_t  datalen, RIL_Token  t)
 {
-    // For now we'll save the rate but no RIL_UNSOL_CELL_INFO_LIST messages
-    // will be sent.
-    assert (datalen == sizeof(int));
-    s_cell_info_rate_ms = ((int *)data)[0];
+    const char* in_qosId = ((const char **)data)[0];
+    const char* in_qosSpec = ((const char **)data)[1];
 
-    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    const int RESPONSE1_PARAM_NUM = 1;
+    const char* p_buffer1[RESPONSE1_PARAM_NUM];
+    int buffer_size1 = RESPONSE1_PARAM_NUM*sizeof(char*);
+    const char* out_code = "0";
+    p_buffer1[0] = out_code;
+
+    ALOGE("requestModifyQos:RIL_onRequestComplete");
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_buffer1, buffer_size1);
+
+    const int RESPONSE2_PARAM_NUM = 2;
+    const char* p_buffer2[RESPONSE2_PARAM_NUM];
+    int buffer_size2 = RESPONSE2_PARAM_NUM*sizeof(char*);
+
+    p_buffer2[0] = in_qosId;
+    p_buffer2[1] = "5"; //Modified
+    ALOGE("requestModify:RIL_onUnsolicitedResponse");
+    RIL_onUnsolicitedResponse ( RIL_UNSOL_QOS_STATE_CHANGED_IND,
+            p_buffer2, buffer_size2);
+}
+
+static void  requestSuspendQos(void*  data, size_t  datalen, RIL_Token  t)
+{
+    const char* in_qosId = ((const char **)data)[0];
+    const int RESPONSE1_PARAM_NUM = 1;
+    const char* p_buffer1[RESPONSE1_PARAM_NUM];
+    int buffer_size1 = RESPONSE1_PARAM_NUM*sizeof(char*);
+    const char* out_code = "0";
+    p_buffer1[0] = out_code;
+
+    ALOGE("requestSuspendQos:RIL_onRequestComplete len: %d", buffer_size1);
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_buffer1, buffer_size1);
+
+    const int RESPONSE2_PARAM_NUM = 2;
+    const char* p_buffer2[RESPONSE2_PARAM_NUM];
+    int buffer_size2 = RESPONSE2_PARAM_NUM*sizeof(char*);
+
+    p_buffer2[0] = in_qosId;
+    p_buffer2[1] = "4"; // Suspended
+    ALOGE("requestSuspendQos:RIL_onUnsolicitedResponse");
+    RIL_onUnsolicitedResponse ( RIL_UNSOL_QOS_STATE_CHANGED_IND,
+            p_buffer2, buffer_size2);
+}
+
+static void  requestResumeQos(void*  data, size_t  datalen, RIL_Token  t)
+{
+    const char* in_qosId = ((const char **)data)[0];
+    const int RESPONSE1_PARAM_NUM = 1;
+    const char* p_buffer1[RESPONSE1_PARAM_NUM];
+    int buffer_size1 = RESPONSE1_PARAM_NUM*sizeof(char*);
+    const char* out_code = "0";
+    p_buffer1[0] = out_code;
+
+    ALOGE("requestResumeQos:RIL_onRequestComplete");
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_buffer1, buffer_size1);
+
+    const int RESPONSE2_PARAM_NUM = 2;
+    const char* p_buffer2[RESPONSE2_PARAM_NUM];
+    int buffer_size2 = RESPONSE2_PARAM_NUM*sizeof(char*);
+
+    p_buffer2[0] = in_qosId;
+    p_buffer2[1] = "0"; // Activated
+    ALOGE("requestResumeQos:RIL_onUnsolicitedResponse");
+    RIL_onUnsolicitedResponse ( RIL_UNSOL_QOS_STATE_CHANGED_IND,
+            p_buffer2, buffer_size2);
+}
+
+static void  requestGetQosStatus(void*  data, size_t  datalen, RIL_Token  t)
+{
+
+    const char* in_qosId = ((const char **)data)[0];
+    const int RESPONSE_PARAM_NUM = 3;
+    char* p_buffer[RESPONSE_PARAM_NUM];
+    int buffer_size = RESPONSE_PARAM_NUM*sizeof(char*);
+    char* out_code = "0";
+    char* out_status = "1";
+    char* out_qosSpec = "RIL_QOS_SPEC_INDEX=0,RIL_QOS_FLOW_DIRECTION=0,RIL_QOS_FLOW_DATA_RATE_MIN=64000,RIL_QOS_FLOW_DATA_RATE_MAX=128000,RIL_QOS_FLOW_LATENCY=50,RIL_QOS_FILTER_DIRECTION=0,RIL_QOS_FILTER_IPV4_DESTINATION_ADDR=10.2.5.111,RIL_QOS_FILTER_UDP_DESTINATION_PORT_START=4040,RIL_QOS_FILTER_UDP_DESTINATION_PORT_RANGE=20";
+
+    p_buffer[0] = out_code;
+    p_buffer[1] = out_status;
+    p_buffer[2] = out_qosSpec;
+
+
+    ALOGE("requestGetQosStatus:RIL_onRequestComplete");
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_buffer, buffer_size);
 }
 
 /*** Callback methods from the RIL library to us ***/
@@ -2035,7 +2139,7 @@ onRequest (int request, void *data, size_t datalen, RIL_Token t)
     ATResponse *p_response;
     int err;
 
-    RLOGD("onRequest: %s", requestToString(request));
+    ALOGD("onRequest: %s", requestToString(request));
 
     /* Ignore all requests except RIL_REQUEST_GET_SIM_STATUS
      * when RADIO_STATE_UNAVAILABLE.
@@ -2279,12 +2383,12 @@ onRequest (int request, void *data, size_t datalen, RIL_Token t)
             int i;
             const char ** cur;
 
-            RLOGD("got OEM_HOOK_STRINGS: 0x%8p %lu", data, (long)datalen);
+            ALOGD("got OEM_HOOK_STRINGS: 0x%8p %lu", data, (long)datalen);
 
 
             for (i = (datalen / sizeof (char *)), cur = (const char **)data ;
                     i > 0 ; cur++, i --) {
-                RLOGD("> '%s'", *cur);
+                ALOGD("> '%s'", *cur);
             }
 
             // echo back strings
@@ -2320,7 +2424,8 @@ onRequest (int request, void *data, size_t datalen, RIL_Token t)
             requestEnterSimPin(data, datalen, t);
             break;
 
-        case RIL_REQUEST_IMS_REGISTRATION_STATE: {
+       case RIL_REQUEST_IMS_REGISTRATION_STATE:
+        {
             int reply[2];
             //0==unregistered, 1==registered
             reply[0] = s_ims_registered;
@@ -2331,7 +2436,7 @@ onRequest (int request, void *data, size_t datalen, RIL_Token t)
             // FORMAT_3GPP(1) vs FORMAT_3GPP2(2);
             reply[1] = s_ims_format;
 
-            RLOGD("IMS_REGISTRATION=%d, format=%d ",
+            ALOGD("IMS_REGISTRATION=%d, format=%d ",
                     reply[0], reply[1]);
             if (reply[1] != -1) {
                 RIL_onRequestComplete(t, RIL_E_SUCCESS, reply, sizeof(reply));
@@ -2358,14 +2463,31 @@ onRequest (int request, void *data, size_t datalen, RIL_Token t)
             requestGetPreferredNetworkType(request, data, datalen, t);
             break;
 
-        case RIL_REQUEST_GET_CELL_INFO_LIST:
-            requestGetCellInfoList(data, datalen, t);
+        case RIL_REQUEST_SETUP_QOS:
+            requestSetupQos(data, datalen, t);
+            break;
+
+        case RIL_REQUEST_RELEASE_QOS:
+            requestReleaseQos(data, datalen, t);
+            break;
+
+        case RIL_REQUEST_MODIFY_QOS:
+            requestModifyQos(data, datalen, t);
+            break;
+
+        case RIL_REQUEST_SUSPEND_QOS:
+            requestSuspendQos(data, datalen, t);
             break;
 
-        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
-            requestSetCellInfoListRate(data, datalen, t);
+        case RIL_REQUEST_RESUME_QOS:
+            requestResumeQos(data, datalen, t);
             break;
 
+        case RIL_REQUEST_GET_QOS_STATUS:
+            requestGetQosStatus(data, datalen, t);
+            break;
+
+#ifdef RIL_VARIANT_LEGACY
         case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
             setUiccSubscription(request, data, datalen, t);
             break;
@@ -2373,7 +2495,7 @@ onRequest (int request, void *data, size_t datalen, RIL_Token t)
         case RIL_REQUEST_SET_DATA_SUBSCRIPTION:
             setDataSubscription(request, data, datalen, t);
             break;
-
+#endif
         /* CDMA Specific Requests */
         case RIL_REQUEST_BASEBAND_VERSION:
             if (TECH_BIT(sMdmInfo) == MDM_CDMA) {
@@ -2424,7 +2546,7 @@ onRequest (int request, void *data, size_t datalen, RIL_Token t)
             } // Fall-through if tech is not cdma
 
         default:
-            RLOGD("Request not supported. Tech: %d",TECH(sMdmInfo));
+            ALOGD("Request not supported. Tech: %d",TECH(sMdmInfo));
             RIL_onRequestComplete(t, RIL_E_REQUEST_NOT_SUPPORTED, NULL, 0);
             break;
     }
@@ -2468,12 +2590,12 @@ static const char * getVersion(void)
 static void
 setRadioTechnology(ModemInfo *mdm, int newtech)
 {
-    RLOGD("setRadioTechnology(%d)", newtech);
+    ALOGD("setRadioTechnology(%d)", newtech);
 
     int oldtech = TECH(mdm);
 
     if (newtech != oldtech) {
-        RLOGD("Tech change (%d => %d)", oldtech, newtech);
+        ALOGD("Tech change (%d => %d)", oldtech, newtech);
         TECH(mdm) = newtech;
         if (techFromModemType(newtech) != techFromModemType(oldtech)) {
             int tech = techFromModemType(TECH(sMdmInfo));
@@ -2488,7 +2610,7 @@ setRadioTechnology(ModemInfo *mdm, int newtech)
 static void
 setRadioState(RIL_RadioState newState)
 {
-    RLOGD("setRadioState(%d)", newState);
+    ALOGD("setRadioState(%d)", newState);
     RIL_RadioState oldState;
 
     pthread_mutex_lock(&s_state_mutex);
@@ -2517,9 +2639,6 @@ setRadioState(RIL_RadioState newState)
     if (sState != oldState) {
         RIL_onUnsolicitedResponse (RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
                                     NULL, 0);
-        // Sim state can change as result of radio state change
-        RIL_onUnsolicitedResponse (RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED,
-                                    NULL, 0);
 
         /* FIXME onSimReady() and onRadioPowerOn() cannot be called
          * from the AT reader thread
@@ -2619,7 +2738,7 @@ getSIMStatus()
     char *cpinLine;
     char *cpinResult;
 
-    RLOGD("getSIMStatus(). sState: %d",sState);
+    ALOGD("getSIMStatus(). sState: %d",sState);
     if (sState == RADIO_STATE_OFF || sState == RADIO_STATE_UNAVAILABLE) {
         ret = SIM_NOT_READY;
         goto done;
@@ -2806,7 +2925,7 @@ static void pollSIMState (void *param)
         case SIM_PUK:
         case SIM_NETWORK_PERSONALIZATION:
         default:
-            RLOGI("SIM ABSENT or LOCKED");
+            ALOGI("SIM ABSENT or LOCKED");
             RIL_onUnsolicitedResponse(RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
         return;
 
@@ -2815,7 +2934,7 @@ static void pollSIMState (void *param)
         return;
 
         case SIM_READY:
-            RLOGI("SIM_READY");
+            ALOGI("SIM_READY");
             onSIMReady();
             RIL_onUnsolicitedResponse(RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
         return;
@@ -2873,10 +2992,10 @@ int parse_technology_response( const char *response, int *current, int32_t *pref
     char *str_pt;
 
     line = p = strdup(response);
-    RLOGD("Response: %s", line);
+    ALOGD("Response: %s", line);
     err = at_tok_start(&p);
     if (err || !at_tok_hasmore(&p)) {
-        RLOGD("err: %d. p: %s", err, p);
+        ALOGD("err: %d. p: %s", err, p);
         free(line);
         return -1;
     }
@@ -2888,7 +3007,7 @@ int parse_technology_response( const char *response, int *current, int32_t *pref
     }
     if (current) *current = ct;
 
-    RLOGD("line remaining after int: %s", p);
+    ALOGD("line remaining after int: %s", p);
 
     err = at_tok_nexthexint(&p, &pt);
     if (err) {
@@ -2910,7 +3029,7 @@ int query_supported_techs( ModemInfo *mdm, int *supported )
     char *tok;
     char *line;
 
-    RLOGD("query_supported_techs");
+    ALOGD("query_supported_techs");
     err = at_send_command_singleline("AT+CTEC=?", "+CTEC:", &p_response);
     if (err || !p_response->success)
         goto error;
@@ -2948,14 +3067,14 @@ int query_ctec(ModemInfo *mdm, int *current, int32_t *preferred)
     int err;
     int res;
 
-    RLOGD("query_ctec. current: %d, preferred: %d", (int)current, (int) preferred);
+    ALOGD("query_ctec. current: %d, preferred: %d", (int)current, (int) preferred);
     err = at_send_command_singleline("AT+CTEC?", "+CTEC:", &response);
     if (!err && response->success) {
         res = parse_technology_response(response->p_intermediates->line, current, preferred);
         at_response_free(response);
         return res;
     }
-    RLOGE("Error executing command: %d. response: %x. status: %d", err, (int)response, response? response->success : -1);
+    ALOGE("Error executing command: %d. response: %x. status: %d", err, (int)response, response? response->success : -1);
     at_response_free(response);
     return -1;
 }
@@ -2992,7 +3111,7 @@ static void probeForModemMode(ModemInfo *info)
     // Try that first
 
     if (is_multimode_modem(info)) {
-        RLOGI("Found Multimode Modem. Supported techs mask: %8.8x. Current tech: %d",
+        ALOGI("Found Multimode Modem. Supported techs mask: %8.8x. Current tech: %d",
             info->supportedTechs, info->currentTech);
         return;
     }
@@ -3007,14 +3126,14 @@ static void probeForModemMode(ModemInfo *info)
         // TODO: find out if we really support EvDo
         info->supportedTechs = MDM_CDMA | MDM_EVDO;
         info->currentTech = MDM_CDMA;
-        RLOGI("Found CDMA Modem");
+        ALOGI("Found CDMA Modem");
         return;
     }
     if (!err) at_response_free(response);
     // TODO: find out if modem really supports WCDMA/LTE
     info->supportedTechs = MDM_GSM | MDM_WCDMA | MDM_LTE;
     info->currentTech = MDM_GSM;
-    RLOGI("Found GSM Modem");
+    ALOGI("Found GSM Modem");
 }
 
 /**
@@ -3113,7 +3232,7 @@ static void waitForClose()
 
 static void sendUnsolImsNetworkStateChanged()
 {
-#if 0 // to be used when unsol is changed to return data.
+#if 0  // to be used when unsol is changed to return data.
     int reply[2];
     reply[0] = s_ims_registered;
     reply[1] = s_ims_services;
@@ -3151,7 +3270,7 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
 
         free(line);
         if (err != 0) {
-            RLOGE("invalid NITZ line %s\n", s);
+            ALOGE("invalid NITZ line %s\n", s);
         } else {
             RIL_onUnsolicitedResponse (
                 RIL_UNSOL_NITZ_TIME_RECEIVED,
@@ -3168,6 +3287,111 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
 #ifdef WORKAROUND_FAKE_CGEV
         RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL); //TODO use new function
 #endif /* WORKAROUND_FAKE_CGEV */
+    } else if(strStartsWith(s,"+STK:")) {
+
+        int nSTKCmd = 0;
+        char *response = NULL;
+        char *str;
+        int nEvent = RIL_UNSOL_STK_PROACTIVE_COMMAND;
+        line = strdup(s);
+        err = at_tok_start(&line);
+        if (err < 0) {
+            ALOGE("Error ::: bailing out %d\n ", err);
+        }
+
+        int err = at_tok_nextint(&line, &nSTKCmd);
+        //err = at_tok_nextstr(&line, &str);
+        if (err < 0) {
+            ALOGE("Error :: bailing out %d\n ", err);
+        }
+        ALOGE("STK Command %d \n", nSTKCmd);
+        /*
+         * TBD: To make the case labels more meaningful and more orderly,
+         * instead of plain numbers.
+         * Reference TS for following payloads : 3GPP TS 31.124 v9.2.0
+        */
+        switch (nSTKCmd) {
+            case 0:
+                // SETUP MENU
+                response = strdup("D03B810301258082028182850C546F6F6C6B6974204D656E758F07014974656D20318F07024974656D20328F07034974656D20338F07044974656D2034");
+                break;
+            case 1:
+                // IDLE MODE TEXT 1.1.1
+                response = strdup("D01A8103012800820281828D0F0449646C65204D6F64652054657874");
+                break;
+            case 2:
+                // DISPLAY TEXT 1.4.1
+                response = strdup("D01A8103012180820281028D0F04546F6F6C6B697420546573742031");
+                break;
+            case 3:
+                // DISPLAY TEXT SEQ 1.2
+                response = strdup("D01A8103012180820281028D0F04546F6F6C6B697420546573742031");
+                break;
+            case 4:
+                // DISPLAY TEXT SEQ 1.3
+                response = strdup("D01A8103012181820281028D0F04546F6F6C6B697420546573742032");
+                break;
+            case 5:
+                // SEND DTMF
+                response = strdup("D01C810301140082028183850953656E642044544D46AC02C1F29E020101");
+                nEvent = RIL_UNSOL_STK_EVENT_NOTIFY;
+                break;
+            case 6:
+                // GETINKEY 7.1.1
+                response = strdup("D0158103012280820281828D0A04456E74657220222B22");
+                break;
+            case 7:
+                // DISPLAY TEXT 7.1.1
+                response = strdup("D01C8103012180820281028D110448656C7020696E666F726D6174696F6E");
+                break;
+            case 8:
+                //GETINKEY 7.1.2
+                response = strdup("D0158103012280820281828D0A04456E74657220222B22");
+                break;
+            case 9:
+                //27.22.4.22.2 SET UP IDLE MODE TEXT SEQ 2.4
+                response = strdup("D00F8103012800820281828D009E020101");
+                break;
+            case 10:
+                //Remove Idle screen 1.3
+                response = strdup("D00B8103012800820281828D00");
+                break;
+            case 11:
+                //SET UP IDLE MODE TEXT 2.1.1
+                response = strdup("D0198103012800820281828D0A0449646C6520746578749E020001");
+                break;
+            case 12:
+                //SET UP IDLE MODE TEXT 2.2.1A
+                response = strdup("D0198103012800820281828D0A0449646C6520746578749E020101");
+                break;
+            case 13:
+                // 27.22.4.26.2 LAUNCH BROWSER SEQ 2.3
+                response = strdup("D00B8103011500820281823100");
+                break;
+            case 14:
+                // PROVILE LOCAL INFO: Qualifier is LANG SETTING
+                response = strdup("D009810301260482028182");
+                break;
+            case 15:
+                //LAUNCH BROWSER 1.2.1
+                response = strdup("D01F8103011500820281823112687474703A2F2F7878782E7979792E7A7A7A0500");
+                break;
+            case 100:
+                // SESSION END
+                RIL_onUnsolicitedResponse (RIL_UNSOL_STK_SESSION_END,
+                                       NULL, 0);
+                break;
+            default:
+                ALOGE("Error: Wrong STK CMD option %d\n ", err);
+                break;
+        }
+        if(NULL != response) {
+            RIL_onUnsolicitedResponse (nEvent, //RIL_UNSOL_STK_PROACTIVE_COMMAND,
+                                       response, strlen(response));
+        } else {
+            ALOGE("Error: Something wrong with response string...");
+        }
+        free(line);
     } else if (strStartsWith(s,"+CREG:")
                 || strStartsWith(s,"+CGREG:")
     ) {
@@ -3201,14 +3425,14 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
         switch (parse_technology_response(s, &tech, NULL))
         {
             case -1: // no argument could be parsed.
-                RLOGE("invalid CTEC line %s\n", s);
+                ALOGE("invalid CTEC line %s\n", s);
                 break;
             case 1: // current mode correctly parsed
             case 0: // preferred mode correctly parsed
                 mask = 1 << tech;
                 if (mask != MDM_GSM && mask != MDM_CDMA &&
                      mask != MDM_WCDMA && mask != MDM_LTE) {
-                    RLOGE("Unknown technology %d\n", tech);
+                    ALOGE("Unknown technology %d\n", tech);
                 } else {
                     setRadioTechnology(sMdmInfo, tech);
                 }
@@ -3218,7 +3442,7 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
         int source = 0;
         line = p = strdup(s);
         if (!line) {
-            RLOGE("+CCSS: Unable to allocate memory");
+            ALOGE("+CCSS: Unable to allocate memory");
             return;
         }
         if (at_tok_start(&p) < 0) {
@@ -3226,7 +3450,7 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
             return;
         }
         if (at_tok_nextint(&p, &source) < 0) {
-            RLOGE("invalid +CCSS response: %s", line);
+            ALOGE("invalid +CCSS response: %s", line);
             free(line);
             return;
         }
@@ -3238,7 +3462,7 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
         int unsol;
         line = p = strdup(s);
         if (!line) {
-            RLOGE("+WSOS: Unable to allocate memory");
+            ALOGE("+WSOS: Unable to allocate memory");
             return;
         }
         if (at_tok_start(&p) < 0) {
@@ -3246,7 +3470,7 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
             return;
         }
         if (at_tok_nextbool(&p, &state) < 0) {
-            RLOGE("invalid +WSOS response: %s", line);
+            ALOGE("invalid +WSOS response: %s", line);
             free(line);
             return;
         }
@@ -3261,16 +3485,16 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
         int version = -1;
         line = p = strdup(s);
         if (!line) {
-            RLOGE("+WPRL: Unable to allocate memory");
+            ALOGE("+WPRL: Unable to allocate memory");
             return;
         }
         if (at_tok_start(&p) < 0) {
-            RLOGE("invalid +WPRL response: %s", s);
+            ALOGE("invalid +WPRL response: %s", s);
             free(line);
             return;
         }
         if (at_tok_nextint(&p, &version) < 0) {
-            RLOGE("invalid +WPRL response: %s", s);
+            ALOGE("invalid +WPRL response: %s", s);
             free(line);
             return;
         }
@@ -3284,7 +3508,7 @@ static void onUnsolicited (const char *s, const char *sms_pdu)
 /* Called on command or reader thread */
 static void onATReaderClosed()
 {
-    RLOGI("AT channel closed\n");
+    ALOGI("AT channel closed\n");
     at_close();
     s_closed = 1;
 
@@ -3294,7 +3518,7 @@ static void onATReaderClosed()
 /* Called on command thread */
 static void onATTimeout()
 {
-    RLOGI("AT channel timeout; closing\n");
+    ALOGI("AT channel timeout; closing\n");
     at_close();
 
     s_closed = 1;
@@ -3335,14 +3559,7 @@ mainLoop(void *param)
                      * now another "legacy" way of communicating with the
                      * emulator), we will try to connecto to gsm service via
                      * qemu pipe. */
-                    char qemuPipe[MAX_QEMU_PIPE_NAME_LENGTH] = "qemud:gsm";
-                    if (ril_inst_id != NULL
-                    		&& strlen(ril_inst_id) <= MAX_CLIENT_ID_LENGTH ) {
-                        strncat(qemuPipe, ril_inst_id ,MAX_QEMU_PIPE_NAME_LENGTH);
-                    }
-                    RLOGD("qemu pipe name : %s\n", qemuPipe);
-                    fd = qemu_pipe_open(qemuPipe);
-
+                    fd = qemu_pipe_open("qemud:gsm");
                     if (fd < 0) {
                         /* Qemu-specific control socket */
                         fd = socket_local_client( "qemud",
@@ -3387,7 +3604,7 @@ mainLoop(void *param)
         ret = at_open(fd, onUnsolicited);
 
         if (ret < 0) {
-            RLOGE ("AT error %d on at_open\n", ret);
+            ALOGE ("AT error %d on at_open\n", ret);
             return 0;
         }
 
@@ -3398,7 +3615,7 @@ mainLoop(void *param)
         sleep(1);
 
         waitForClose();
-        RLOGI("Re-opening after close");
+        ALOGI("Re-opening after close");
     }
 }
 
@@ -3423,23 +3640,22 @@ const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **a
                     usage(argv[0]);
                     return NULL;
                 }
-                RLOGI("Opening loopback port %d\n", s_port);
+                ALOGI("Opening loopback port %d\n", s_port);
             break;
 
             case 'd':
                 s_device_path = optarg;
-                RLOGI("Opening tty device %s\n", s_device_path);
+                ALOGI("Opening tty device %s\n", s_device_path);
             break;
 
             case 's':
                 s_device_path   = optarg;
                 s_device_socket = 1;
-                RLOGI("Opening socket %s\n", s_device_path);
+                ALOGI("Opening socket %s\n", s_device_path);
             break;
 
             case 'c':
-                ril_inst_id = optarg;
-                RLOGI("ReferRil is using instance %s ", ril_inst_id);
+                //TODO:This will be handled when DSDS two rild emualtor support is mainlined.
             break;
 
             default:
@@ -3455,7 +3671,7 @@ const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **a
 
     sMdmInfo = calloc(1, sizeof(ModemInfo));
     if (!sMdmInfo) {
-        RLOGE("Unable to alloc memory for ModemInfo");
+        ALOGE("Unable to alloc memory for ModemInfo");
         return NULL;
     }
     pthread_attr_init (&attr);
@@ -3478,18 +3694,18 @@ int main (int argc, char **argv)
                 if (s_port == 0) {
                     usage(argv[0]);
                 }
-                RLOGI("Opening loopback port %d\n", s_port);
+                ALOGI("Opening loopback port %d\n", s_port);
             break;
 
             case 'd':
                 s_device_path = optarg;
-                RLOGI("Opening tty device %s\n", s_device_path);
+                ALOGI("Opening tty device %s\n", s_device_path);
             break;
 
             case 's':
                 s_device_path   = optarg;
                 s_device_socket = 1;
-                RLOGI("Opening socket %s\n", s_device_path);
+                ALOGI("Opening socket %s\n", s_device_path);
             break;
 
             default:
diff --git a/rild/Android.mk b/rild/Android.mk
index 1f616b1..c782933 100644
--- a/rild/Android.mk
+++ b/rild/Android.mk
@@ -8,15 +8,10 @@ LOCAL_SRC_FILES:= \
 
 
 LOCAL_SHARED_LIBRARIES := \
-	liblog \
 	libcutils \
 	libril \
 	libdl
 
-# temporary hack for broken vendor rils
-LOCAL_WHOLE_STATIC_LIBRARIES := \
-	librilutils_static
-
 LOCAL_CFLAGS := -DRIL_SHLIB
 
 LOCAL_MODULE:= rild
@@ -32,7 +27,6 @@ LOCAL_SRC_FILES:= \
 	radiooptions.c
 
 LOCAL_SHARED_LIBRARIES := \
-	liblog \
 	libcutils \
 
 LOCAL_CFLAGS := \
diff --git a/rild/rild.c b/rild/rild.c
index 4496cdd..a670c2c 100644
--- a/rild/rild.c
+++ b/rild/rild.c
@@ -1,8 +1,10 @@
 /* //device/system/rild/rild.c
 **
-** Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
-** Not a Contribution
-** Copyright 2006 The Android Open Source Project
+** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2012 The Linux Foundation. All rights reserved.
+**
+** Not a Contribution, Apache license notifications and license are retained
+** for attribution purposes only.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -31,38 +33,48 @@
 #include <utils/Log.h>
 #include <cutils/properties.h>
 #include <cutils/sockets.h>
-#include <sys/capability.h>
+#include <linux/capability.h>
 #include <linux/prctl.h>
 
 #include <private/android_filesystem_config.h>
 #include "hardware/qemu_pipe.h"
 
+#include <telephony/ril_log.h>
+
 #define LIB_PATH_PROPERTY   "rild.libpath"
 #define LIB_ARGS_PROPERTY   "rild.libargs"
 #define MAX_LIB_ARGS        16
+#define NUM_CLIENTS 2
+
+#define DSDS_PROPERTY        "dsds"
+#define DSDS_PROPERTY_LENGTH 4
+#define DSDA_PROPERTY        "dsda"
+#define DSDA_PROPERTY_LENGTH 4
+
 
 static void usage(const char *argv0)
 {
     fprintf(stderr, "Usage: %s -l <ril impl library> [-- <args for impl library>]\n", argv0);
-    exit(EXIT_FAILURE);
+    exit(-1);
 }
 
-#ifdef QCOM_HARDWARE
-extern char rild[MAX_SOCKET_NAME_LENGTH] __attribute__((weak));
-#endif
-
-extern void RIL_register (const RIL_RadioFunctions *callbacks);
+extern void RIL_register (const RIL_RadioFunctions *callbacks, int client_id);
 
 extern void RIL_onRequestComplete(RIL_Token t, RIL_Errno e,
                            void *response, size_t responselen);
-
+//In case of DSDS two unsol functions are needed, corresponding to each of the commands interface.
 extern void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
                                 size_t datalen);
 
 extern void RIL_requestTimedCallback (RIL_TimedCallback callback,
                                void *param, const struct timeval *relativeTime);
 
-extern void RIL_setRilSocketName(char * s) __attribute__((weak));
+extern void RIL_setMaxNumClients(int num_clients);
+
+extern void RIL_setRilSocketName(char * s);
+
+static int isMultiSimEnabled();
+static int isMultiRild();
 
 static struct RIL_Env s_rilEnv = {
     RIL_onRequestComplete,
@@ -70,6 +82,12 @@ static struct RIL_Env s_rilEnv = {
     RIL_requestTimedCallback
 };
 
+static struct RIL_Env s_rilEnv2 = {
+    RIL_onRequestComplete,
+    RIL_onUnsolicitedResponse2,
+    RIL_requestTimedCallback
+};
+
 extern void RIL_startEventLoop();
 
 static int make_argv(char * args, char ** argv)
@@ -96,72 +114,58 @@ void switchUser() {
     setuid(AID_RADIO);
 
     struct __user_cap_header_struct header;
-    memset(&header, 0, sizeof(header));
-    header.version = _LINUX_CAPABILITY_VERSION_3;
+    struct __user_cap_data_struct cap;
+    header.version = _LINUX_CAPABILITY_VERSION;
     header.pid = 0;
-
-    struct __user_cap_data_struct data[2];
-    memset(&data, 0, sizeof(data));
-
-    data[CAP_TO_INDEX(CAP_NET_ADMIN)].effective |= CAP_TO_MASK(CAP_NET_ADMIN);
-    data[CAP_TO_INDEX(CAP_NET_ADMIN)].permitted |= CAP_TO_MASK(CAP_NET_ADMIN);
-
-    data[CAP_TO_INDEX(CAP_NET_RAW)].effective |= CAP_TO_MASK(CAP_NET_RAW);
-    data[CAP_TO_INDEX(CAP_NET_RAW)].permitted |= CAP_TO_MASK(CAP_NET_RAW);
-
-    if (capset(&header, &data[0]) == -1) {
-        RLOGE("capset failed: %s", strerror(errno));
-        exit(EXIT_FAILURE);
-    }
+    cap.effective = cap.permitted = (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW);
+    cap.inheritable = 0;
+    capset(&header, &cap);
 }
 
 int main(int argc, char **argv)
 {
     const char * rilLibPath = NULL;
     char **rilArgv;
+    static char * s_argv[MAX_LIB_ARGS] = {NULL};
     void *dlHandle;
     const RIL_RadioFunctions *(*rilInit)(const struct RIL_Env *, int, char **);
-    const RIL_RadioFunctions *funcs;
+    const RIL_RadioFunctions *funcs_inst[NUM_CLIENTS] = {NULL, NULL};
     char libPath[PROPERTY_VALUE_MAX];
     unsigned char hasLibArgs = 0;
-
+    int j = 0;
     int i;
-    const char *clientId = NULL;
-    RLOGD("**RIL Daemon Started**");
-    RLOGD("**RILd param count=%d**", argc);
+    static char client[3] = {'0'};
+    int numClients = 1;
+
+    ALOGI("**RIL Daemon Started**");
+    ALOGI("**RILd param count=%d**", argc);
+    memset(s_argv, 0, sizeof(s_argv));
+
+    s_argv[0] = argv[0];
 
     umask(S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
-    for (i = 1; i < argc ;) {
+    for (i = 1, j = 1; i < argc ;) {
         if (0 == strcmp(argv[i], "-l") && (argc - i > 1)) {
             rilLibPath = argv[i + 1];
             i += 2;
+        } else if (0 == strcmp(argv[i], "-c") && (argc - i > 1)) {
+            strncpy(client, argv[i+1], strlen(client));
+            i += 2;
         } else if (0 == strcmp(argv[i], "--")) {
             i++;
             hasLibArgs = 1;
+            memcpy(&s_argv[j], &argv[i], argc-i);
             break;
-        } else if (0 == strcmp(argv[i], "-c") &&  (argc - i > 1)) {
-            clientId = argv[i+1];
-            i += 2;
         } else {
             usage(argv[0]);
         }
     }
 
-#ifdef QCOM_HARDWARE
-    if (clientId == NULL) {
-        clientId = "0";
-    } else if (atoi(clientId) >= MAX_RILDS) {
-        RLOGE("Max Number of rild's supported is: %d", MAX_RILDS);
-        exit(0);
-    }
-    if (strncmp(clientId, "0", MAX_CLIENT_ID_LENGTH)) {
-        if (RIL_setRilSocketName) {
-            RIL_setRilSocketName(strncat(rild, clientId, MAX_SOCKET_NAME_LENGTH));
-        } else {
-            RLOGE("Trying to instantiate multiple rild sockets without a compatible libril!");
-        }
+    if (strcmp(client, "0") == 0) {
+        RIL_setRilSocketName("rild");
+    } else if (strcmp(client, "1") == 0) {
+        RIL_setRilSocketName("rild1");
     }
-#endif
 
     if (rilLibPath == NULL) {
         if ( 0 == property_get(LIB_PATH_PROPERTY, libPath, NULL)) {
@@ -176,19 +180,18 @@ int main(int argc, char **argv)
     /* special override when in the emulator */
 #if 1
     {
-        static char*  arg_overrides[5];
         static char   arg_device[32];
         int           done = 0;
 
 #define  REFERENCE_RIL_PATH  "/system/lib/libreference-ril.so"
 
         /* first, read /proc/cmdline into memory */
-        char          buffer[1024] = {'\0'}, *p, *q;
+        char          buffer[1024], *p, *q;
         int           len;
         int           fd = open("/proc/cmdline",O_RDONLY);
 
         if (fd < 0) {
-            RLOGD("could not open /proc/cmdline:%s", strerror(errno));
+            ALOGD("could not open /proc/cmdline:%s", strerror(errno));
             goto OpenLib;
         }
 
@@ -197,7 +200,7 @@ int main(int argc, char **argv)
         while (len == -1 && errno == EINTR);
 
         if (len < 0) {
-            RLOGD("could not read /proc/cmdline:%s", strerror(errno));
+            ALOGD("could not read /proc/cmdline:%s", strerror(errno));
             close(fd);
             goto OpenLib;
         }
@@ -228,18 +231,19 @@ int main(int argc, char **argv)
                     snprintf( arg_device, sizeof(arg_device), "%s/%s",
                                 ANDROID_SOCKET_DIR, QEMUD_SOCKET_NAME );
 
-                    arg_overrides[1] = "-s";
-                    arg_overrides[2] = arg_device;
+                    memset(s_argv, 0, sizeof(s_argv));
+                    s_argv[1] = "-s";
+                    s_argv[2] = arg_device;
                     done = 1;
                     break;
                 }
-                RLOGD("could not connect to %s socket: %s",
+                ALOGD("could not connect to %s socket: %s",
                     QEMUD_SOCKET_NAME, strerror(errno));
                 if (--tries == 0)
                     break;
             }
             if (!done) {
-                RLOGE("could not connect to %s socket (giving up): %s",
+                ALOGE("could not connect to %s socket (giving up): %s",
                     QEMUD_SOCKET_NAME, strerror(errno));
                 while(1)
                     sleep(0x00ffffff);
@@ -262,20 +266,19 @@ int main(int argc, char **argv)
 
             snprintf( arg_device, sizeof(arg_device), DEV_PREFIX "%s", p );
             arg_device[sizeof(arg_device)-1] = 0;
-            arg_overrides[1] = "-d";
-            arg_overrides[2] = arg_device;
+            memset(s_argv, 0, sizeof(s_argv));
+            s_argv[1] = "-d";
+            s_argv[2] = arg_device;
             done = 1;
 
         } while (0);
 
         if (done) {
-            argv = arg_overrides;
             argc = 3;
             i    = 1;
             hasLibArgs = 1;
             rilLibPath = REFERENCE_RIL_PATH;
-
-            RLOGD("overriding with %s %s", arg_overrides[1], arg_overrides[2]);
+            ALOGD("overriding with %s %s", s_argv[1], s_argv[2]);
         }
     }
 OpenLib:
@@ -285,8 +288,8 @@ OpenLib:
     dlHandle = dlopen(rilLibPath, RTLD_NOW);
 
     if (dlHandle == NULL) {
-        RLOGE("dlopen failed: %s", dlerror());
-        exit(EXIT_FAILURE);
+        ALOGE("dlopen failed: %s", dlerror());
+        exit(-1);
     }
 
     RIL_startEventLoop();
@@ -294,50 +297,78 @@ OpenLib:
     rilInit = (const RIL_RadioFunctions *(*)(const struct RIL_Env *, int, char **))dlsym(dlHandle, "RIL_Init");
 
     if (rilInit == NULL) {
-        RLOGE("RIL_Init not defined or exported in %s\n", rilLibPath);
-        exit(EXIT_FAILURE);
+        ALOGE("RIL_Init not defined or exported in %s\n", rilLibPath);
+        exit(-1);
     }
 
     if (hasLibArgs) {
-        rilArgv = argv + i - 1;
-        argc = argc -i + 1;
+        argc = argc-i+1;
     } else {
         static char * newArgv[MAX_LIB_ARGS];
         static char args[PROPERTY_VALUE_MAX];
-        rilArgv = newArgv;
         property_get(LIB_ARGS_PROPERTY, args, "");
-        argc = make_argv(args, rilArgv);
+        argc = make_argv(args, s_argv);
     }
 
-#ifdef QCOM_HARDWARE
-    rilArgv[argc++] = "-c";
-    rilArgv[argc++] = clientId;
-    RLOGD("RIL_Init argc = %d clientId = %s", argc, rilArgv[argc-1]);
-#endif
-
     // Make sure there's a reasonable argv[0]
-    rilArgv[0] = argv[0];
-
-    funcs = rilInit(&s_rilEnv, argc, rilArgv);
-
-#ifdef QCOM_HARDWARE
-    if (funcs == NULL) {
-        /* Pre-multi-client qualcomm vendor libraries won't support "-c" either, so
-         * try again without it. This should only happen on ancient qcoms, so raise
-         * a big fat warning
-         */
-        argc -= 2;
-        RLOGE("============= Retrying RIL_Init without a client id. This is only required for very old versions,");
-        RLOGE("============= and you're likely to have more radio breakage elsewhere!");
-        funcs = rilInit(&s_rilEnv, argc, rilArgv);
+    s_argv[0] = argv[0];
+
+    s_argv[argc++] = "-c";
+    s_argv[argc++] = client;
+
+    ALOGI("RIL_Init argc = %d client = %s",argc, s_argv[argc-1]);
+
+    funcs_inst[0] = rilInit(&s_rilEnv, argc, s_argv);
+
+    if (isMultiSimEnabled() && !isMultiRild()) {
+        s_argv[argc-1] = "1";  //client id incase of single rild managing two instances of RIL
+        ALOGI("RIL_Init argc = %d client = %s",argc, s_argv[argc-1]);
+        funcs_inst[1] = rilInit(&s_rilEnv2, argc, s_argv);
+        numClients++;
     }
-#endif
 
-    RIL_register(funcs);
+    RIL_setMaxNumClients(numClients);
+
+    ALOGD("Register the callbacks func received from RIL Init");
+    for (i = 0; i < numClients; i++) {
+        RIL_register(funcs_inst[i], i);
+    }
 
 done:
 
-    while (true) {
-        sleep(UINT32_MAX);
+    while(1) {
+        // sleep(UINT32_MAX) seems to return immediately on bionic
+        sleep(0x00ffffff);
+    }
+}
+
+static int isMultiSimEnabled()
+{
+    int enabled = 0;
+    char prop_val[PROPERTY_VALUE_MAX];
+    int multisim_config_len = property_get("persist.multisim.config", prop_val, "0");
+    if (multisim_config_len > 0) {
+        if ((strncmp(prop_val, DSDS_PROPERTY, DSDS_PROPERTY_LENGTH) == 0
+                    && multisim_config_len == DSDS_PROPERTY_LENGTH)
+                || (strncmp(prop_val, DSDA_PROPERTY, DSDA_PROPERTY_LENGTH) == 0
+                    && multisim_config_len == DSDA_PROPERTY_LENGTH)) {
+            enabled = 1;
+        }
+        ALOGI("isMultiSimEnabled: prop_val = %s enabled = %d", prop_val, enabled);
+    }
+    return enabled;
+}
+
+static int isMultiRild()
+{
+    int enabled = 0;
+    char prop_val[PROPERTY_VALUE_MAX];
+    if (property_get("ro.multi.rild", prop_val, "0") > 0)
+    {
+        if (strncmp(prop_val, "true", 4) == 0) {
+            enabled = 1;
+        }
+        ALOGD("isMultiRild: prop_val = %s enabled = %d", prop_val, enabled);
     }
+    return enabled;
 }
-- 
2.10.1

